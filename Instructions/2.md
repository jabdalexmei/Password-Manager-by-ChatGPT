

# ТЗ №1 — Backend: SQLite Vault + Folders/DataCards/Settings (по BACKEND.md)

## 0) Цель

Добавить в `src-tauri` каноничный слой хранения и доменные команды:

* SQLite база `vault.db` на профиль.
* CRUD и корзина (soft delete) для **Folders** и **DataCards**.
* Профильные настройки `user_settings.json` (полная структура + дефолты + валидация).
* Все команды доступны как `#[tauri::command]` и возвращают `Result<T, ErrorCodeString>`.

> В этом ТЗ **шифрование “at rest” для vault.db НЕ внедряем** (это будет отдельное ТЗ по crypto/cipher). Но схема/слои делаются так, чтобы шифрование можно было воткнуть без ломки API.

---

## 1) Ветка и базовые требования

* Ветка: `feature/step2-backend-vault-core`
* Язык: Rust (Tauri v2), стиль: как в текущем проекте.
* Команды: строго по канону из `BACKEND.md`:

  * DataCards: `list_datacards`, `get_datacard`, `create_datacard`, `update_datacard`, `move_datacard_to_folder`, `delete_datacard`, `list_deleted_datacards`, `restore_datacard`, `purge_datacard`
  * Folders: `list_folders`, `create_folder`, `rename_folder`, `move_folder`, `delete_folder`, `list_deleted_folders`, `restore_folder`, `purge_folder`
  * Settings: `get_settings`, `update_settings`

---

## 2) Изменения в зависимостях

Файл: `src-tauri/Cargo.toml`

Добавить зависимости:

```toml
rusqlite = { version = "0.31", features = ["bundled"] }
chrono = { version = "0.4", features = ["serde"] }
```

> `bundled` нужен, чтобы SQLite работал без плясок на Windows.

---

## 3) Новый backend tree (добавить файлы)

Добавить папки/файлы:

```
src-tauri/src/commands/datacards.rs
src-tauri/src/commands/folders.rs
src-tauri/src/commands/settings.rs

src-tauri/src/services/datacards_service.rs
src-tauri/src/services/folders_service.rs
src-tauri/src/services/settings_service.rs

src-tauri/src/data/sqlite/schema.sql
src-tauri/src/data/sqlite/init.rs
src-tauri/src/data/sqlite/migrations.rs
src-tauri/src/data/sqlite/repo_impl.rs
```

Изменить существующие:

```
src-tauri/src/main.rs
src-tauri/src/commands/mod.rs
src-tauri/src/types.rs
src-tauri/src/app_state.rs
src-tauri/src/data/profiles/paths.rs
src-tauri/src/services/profiles_service.rs
src-tauri/src/services/security_service.rs
```

---

## 4) Paths: профильные файлы и директории

Файл: `src-tauri/src/data/profiles/paths.rs`

### 4.1 Добавить функции

Добавить функции **без изменения существующих сигнатур** (чтобы не ломать step-1):

```rust
pub fn vault_db_path(profile_id: &str) -> PathBuf;
pub fn user_settings_path(profile_id: &str) -> PathBuf;
pub fn attachments_dir(profile_id: &str) -> PathBuf;
pub fn backups_dir(profile_id: &str) -> PathBuf;

pub fn ensure_profile_dirs(profile_id: &str) -> std::io::Result<()>;
```

### 4.2 Поведение ensure_profile_dirs(profile_id)

Должно создавать:

* `profiles_root()/profile_id/`
* `profiles_root()/profile_id/attachments/`
* `profiles_root()/profile_id/backups/`

---

## 5) AppState: логин должен быть привязан к профилю

Файл: `src-tauri/src/app_state.rs`

Заменить `logged_in: Mutex<bool>` на профильную сессию:

```rust
pub struct AppState {
  pub active_profile: Mutex<Option<String>>,
  pub logged_in_profile: Mutex<Option<String>>,
}
```

Правила:

* После успешного `login_vault(id, ...)`: `logged_in_profile = Some(id)`
* После `lock_vault()`: `logged_in_profile = None`
* Любая команда vault-домена (datacards/folders/settings) должна проверять, что:

  * `active_profile == Some(id)` и `logged_in_profile == Some(id)`
  * иначе ошибка: `VAULT_LOCKED`

---

## 6) Types: каноничные структуры

Файл: `src-tauri/src/types.rs`

### 6.1 Добавить доменные модели (строго поля/нейминг)

**Folder**:

```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Folder {
  pub id: String,
  pub name: String,
  pub parent_id: Option<String>,
  pub is_system: bool,
  pub created_at: String,
  pub updated_at: String,
  pub deleted_at: Option<String>,
}
```

**BankCard**:

```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct BankCard {
  pub holder: String,
  pub number: String,
  pub expiry_mm_yy: String,
  pub cvc: String,
  pub note: Option<String>,
}
```

**CustomField**:

```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "lowercase")]
pub enum CustomFieldType { Text, Secret, Url, Number, Date }

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CustomField {
  pub key: String,
  pub value: String,
  #[serde(rename = "type")]
  pub field_type: CustomFieldType,
}
```

**DataCard** (по канону):

```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DataCard {
  pub id: String,
  pub folder_id: Option<String>,

  pub title: String,
  pub url: Option<String>,
  pub email: Option<String>,
  pub username: Option<String>,
  pub mobile_phone: Option<String>,
  pub note: Option<String>,
  pub tags: Vec<String>,

  pub created_at: String,
  pub updated_at: String,
  pub deleted_at: Option<String>,

  // На этом этапе храним как plain string/JSON (шифрование будет отдельным ТЗ)
  pub password: Option<String>,
  pub bank_card: Option<BankCard>,
  pub custom_fields: Vec<CustomField>,
}
```

### 6.2 Settings структура (строго по FRONTEND.md/BACKEND.md)

Добавить:

```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "snake_case")]
pub struct UserSettings {
  // Security
  pub auto_hide_secret_timeout_seconds: i64,
  pub auto_lock_enabled: bool,
  pub auto_lock_timeout: i64,
  pub reveal_requires_confirmation: bool,

  // Clipboard
  pub clipboard_clear_timeout_seconds: i64,

  // Data Management
  pub soft_delete_enabled: bool,
  pub trash_retention_days: i64,

  // Backups
  pub backups_enabled: bool,
  pub backup_frequency: String, // "daily" | "weekly" | "monthly"
  pub backup_retention_days: i64,

  // Sorting
  pub default_sort_field: String,      // "created_at" | "updated_at" | "title"
  pub default_sort_direction: String,  // "ASC" | "DESC"

  // Display
  pub mask_password_by_default: bool,
}
```

И функцию (или impl Default) с дефолтами **строго**:

* `auto_hide_secret_timeout_seconds`: 15
* `clipboard_clear_timeout_seconds`: 30
* `auto_lock_enabled`: true
* `auto_lock_timeout`: 300
* `reveal_requires_confirmation`: false
* `soft_delete_enabled`: true
* `trash_retention_days`: 30
* `backups_enabled`: false
* `backup_frequency`: "weekly"
* `backup_retention_days`: 30
* `default_sort_field`: "updated_at"
* `default_sort_direction`: "DESC"
* `mask_password_by_default`: true

### 6.3 DTO для команд (в `types.rs`)

Добавить входные структуры:

* `CreateFolderInput { name: String, parent_id: Option<String> }`

* `RenameFolderInput { id: String, name: String }`

* `MoveFolderInput { id: String, parent_id: Option<String> }`

* `CreateDataCardInput { folder_id: Option<String>, title: String, url: Option<String>, email: Option<String>, username: Option<String>, mobile_phone: Option<String>, note: Option<String>, tags: Vec<String>, password: Option<String>, bank_card: Option<BankCard>, custom_fields: Vec<CustomField> }`

* `UpdateDataCardInput` — то же + `id: String`

* `MoveDataCardInput { id: String, folder_id: Option<String> }`

---

## 7) SQLite: схема и миграции

### 7.1 schema.sql

Файл: `src-tauri/src/data/sqlite/schema.sql`

Содержимое **буквально** (без импровизаций):

```sql
PRAGMA foreign_keys = ON;

CREATE TABLE IF NOT EXISTS folders (
  id         TEXT PRIMARY KEY,
  name       TEXT NOT NULL,
  parent_id  TEXT NULL,
  is_system  INTEGER NOT NULL DEFAULT 0,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_folders_unique_name
ON folders(parent_id, name)
WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_folders_parent
ON folders(parent_id);

CREATE TABLE IF NOT EXISTS datacards (
  id           TEXT PRIMARY KEY,
  folder_id    TEXT NULL,

  title        TEXT NOT NULL,
  url          TEXT NULL,
  email        TEXT NULL,
  username     TEXT NULL,
  mobile_phone TEXT NULL,
  note         TEXT NULL,

  tags_json           TEXT NOT NULL DEFAULT '[]',
  password_value      TEXT NULL,
  bank_card_json      TEXT NULL,
  custom_fields_json  TEXT NOT NULL DEFAULT '[]',

  created_at   TEXT NOT NULL,
  updated_at   TEXT NOT NULL,
  deleted_at   TEXT NULL
);

CREATE INDEX IF NOT EXISTS idx_datacards_folder
ON datacards(folder_id);

CREATE INDEX IF NOT EXISTS idx_datacards_deleted
ON datacards(deleted_at);
```

### 7.2 init/migrations

Файлы:

* `src-tauri/src/data/sqlite/migrations.rs`
* `src-tauri/src/data/sqlite/init.rs`

Правила:

* Использовать `PRAGMA user_version` как версию схемы.
* Версия 1 = применение `schema.sql`.
* `init_database(profile_id)`:

  1. `ensure_profile_dirs(profile_id)`
  2. открыть/создать файл `vault_db_path(profile_id)`
  3. включить `PRAGMA foreign_keys = ON`
  4. прогнать миграции до актуальной версии

---

## 8) Repo слой

Файл: `src-tauri/src/data/sqlite/repo_impl.rs`

Репозиторий (внутренний), который работает только с SQLite и не знает про Tauri/State.

Минимальные функции (строго нужны для команд):

### Folders (repo)

* `list_folders(conn) -> Vec<Folder>` (только `deleted_at IS NULL`, сорт `name ASC`)
* `list_deleted_folders(conn) -> Vec<Folder>` (только `deleted_at IS NOT NULL`, сорт `deleted_at DESC`)
* `insert_folder(conn, folder: Folder)`
* `update_folder_name(conn, id, name, updated_at)`
* `update_folder_parent(conn, id, parent_id, updated_at)`
* `soft_delete_folder(conn, id, deleted_at, updated_at)`
* `restore_folder(conn, id, updated_at)`
* `purge_folder(conn, id)` (DELETE)

### DataCards (repo)

* `list_datacards(conn, settings: &UserSettings) -> Vec<DataCard>` (только не удалённые, сорт по settings)
* `list_deleted_datacards(conn) -> Vec<DataCard>`
* `get_datacard(conn, id) -> Option<DataCard>` (разрешено возвращать удалённую — сервис решает)
* `insert_datacard(conn, card: DataCard)`
* `update_datacard(conn, card: DataCard)`
* `move_datacard(conn, id, folder_id, updated_at)`
* `soft_delete_datacard(conn, id, deleted_at, updated_at)`
* `restore_datacard(conn, id, updated_at)`
* `purge_datacard(conn, id)`

Сериализация в БД:

* `tags_json` = `serde_json::to_string(&tags)`
* `bank_card_json` = `serde_json::to_string(&bank_card)` (или NULL)
* `custom_fields_json` = `serde_json::to_string(&custom_fields)`

---

## 9) Services слой: бизнес-правила и ошибки

### 9.1 Общие ошибки (ErrorCodeString.code)

Использовать такие коды (в этом ТЗ добавить их по месту):

* `VAULT_LOCKED` — команда вызвана без залогиненного активного профиля
* `PROFILE_NOT_FOUND` — профиль не найден (если потребуется)
* `DB_OPEN_FAILED`, `DB_QUERY_FAILED`, `DB_MIGRATION_FAILED`
* `FOLDER_NAME_REQUIRED`
* `FOLDER_NAME_EXISTS`
* `FOLDER_NOT_FOUND`
* `FOLDER_IS_SYSTEM`
* `DATACARD_TITLE_REQUIRED`
* `DATACARD_NOT_FOUND`
* `SETTINGS_READ`, `SETTINGS_WRITE`, `SETTINGS_PARSE`
* `SETTINGS_VALIDATION_FAILED`

### 9.2 folders_service.rs

Файл: `src-tauri/src/services/folders_service.rs`

Правила:

* `name` всегда `trim()`, пустое → `FOLDER_NAME_REQUIRED`
* Уникальность имени обеспечивается в рамках `(parent_id, name)` среди не удалённых:

  * конфликт → `FOLDER_NAME_EXISTS` (ловить UNIQUE constraint и мапить)
* `delete_folder`:

  * если `is_system == true` → `FOLDER_IS_SYSTEM`
  * soft-delete папку (`deleted_at=now`)
  * **также soft-delete все datacards**, у которых `folder_id == id`
* `purge_folder`:

  * физически удалить папку
  * **физически удалить все datacards** из этой папки
* `restore_folder`:

  * восстановить папку (deleted_at=NULL)
  * восстановить datacards, которые были удалены из-за удаления папки (упрощение в этом ТЗ: восстановить все datacards folder_id==id у которых deleted_at не null)

### 9.3 datacards_service.rs

Файл: `src-tauri/src/services/datacards_service.rs`

Правила:

* `title.trim()` пустое → `DATACARD_TITLE_REQUIRED`
* `tags`: каждую `trim()`, удалить пустые, убрать дубликаты (case-sensitive), сохранять порядок первого вхождения.
* `get_datacard`:

  * если не найден → `DATACARD_NOT_FOUND`
* `delete_datacard`:

  * если `settings.soft_delete_enabled == true` → soft delete
  * если false → сразу purge (DELETE)
* `list_datacards` сортировка:

  * `default_sort_field=updated_at`: `updated_at {dir}, title ASC`
  * `created_at`: `created_at {dir}, title ASC`
  * `title`: `title {dir}, updated_at DESC`

### 9.4 settings_service.rs

Файл: `src-tauri/src/services/settings_service.rs`

Хранение:

* `user_settings.json` лежит **в каталоге профиля**: `user_settings_path(profile_id)`

`get_settings`:

* если файла нет → создать дефолтный settings и сохранить
* вернуть актуальные settings

`update_settings`:

* принимает **полный объект** `UserSettings`
* валидирует:

  * `auto_hide_secret_timeout_seconds`: 1..=600
  * `clipboard_clear_timeout_seconds`: 1..=600
  * `auto_lock_timeout`: 30..=86400
  * `trash_retention_days`: 1..=3650
  * `backup_retention_days`: 1..=3650
  * `backup_frequency` ∈ {"daily","weekly","monthly"}
  * `default_sort_field` ∈ {"created_at","updated_at","title"}
  * `default_sort_direction` ∈ {"ASC","DESC"}
* если что-то не так → `SETTINGS_VALIDATION_FAILED`

---

## 10) Commands слой: Tauri API

### 10.1 commands/mod.rs

Файл: `src-tauri/src/commands/mod.rs`

Добавить:

```rust
pub mod datacards;
pub mod folders;
pub mod settings;
```

### 10.2 main.rs

Файл: `src-tauri/src/main.rs`

1. Подключить модули `data::sqlite` (init/migrations/repo) в `mod data { ... }`.
2. В `invoke_handler` добавить команды:

* из `commands::datacards::*`
* из `commands::folders::*`
* из `commands::settings::*`

### 10.3 Сигнатуры команд (строго)

Пример (для всех по аналогии):

* `list_folders(state: State<Arc<AppState>>) -> Result<Vec<Folder>>`
* `create_folder(input: CreateFolderInput, state: State<Arc<AppState>>) -> Result<Folder>`
* `rename_folder(input: RenameFolderInput, state: State<Arc<AppState>>) -> Result<bool>`
* `move_folder(input: MoveFolderInput, state: State<Arc<AppState>>) -> Result<bool>`
* `delete_folder(id: String, state: State<Arc<AppState>>) -> Result<bool>`
* `list_deleted_folders(state: State<Arc<AppState>>) -> Result<Vec<Folder>>`
* `restore_folder(id: String, state: State<Arc<AppState>>) -> Result<bool>`
* `purge_folder(id: String, state: State<Arc<AppState>>) -> Result<bool>`

Аналогично для datacards/settings.

---

## 11) Встраивание в существующий step-1 (минимальные правки)

### 11.1 profiles_service.rs

Файл: `src-tauri/src/services/profiles_service.rs`

В `create_profile(...)` после создания записи профиля:

* вызвать `ensure_profile_dirs(profile_id)`
* вызвать `init_database(profile_id)`
* вызвать `get_settings(profile_id)` (чтобы файл дефолтов появился сразу)

### 11.2 security_service.rs

Файл: `src-tauri/src/services/security_service.rs`

После успешного логина:

* выставить `logged_in_profile = Some(id)`
* (опционально) `init_database(id)` (если ещё не был создан)

---

## 12) Критерии приёмки (чеклист)

Считаем ТЗ выполненным, если:

1. Проект собирается (`pnpm tauri dev` / `npm run tauri dev` — как у тебя принято).
2. При создании профиля на диске появляется:

   * `profiles/<id>/vault.db`
   * `profiles/<id>/user_settings.json`
   * `profiles/<id>/attachments/`
   * `profiles/<id>/backups/`
3. После логина любая команда vault-домена работает, а без логина возвращает `VAULT_LOCKED`.
4. Folders:

   * create/list/rename/move работают
   * delete → уходит в deleted list
   * restore возвращает
   * purge удаляет навсегда
   * уникальность имён на одном уровне реально enforced (`FOLDER_NAME_EXISTS`)
5. DataCards:

   * create/get/update/move/list работают
   * delete делает soft delete (при soft_delete_enabled=true)
   * list_deleted_datacards показывает удалённые
   * restore возвращает
   * purge удаляет навсегда
   * сортировка `list_datacards` реально зависит от `user_settings.json`
6. Settings:

   * `get_settings` создаёт дефолты при отсутствии файла
   * `update_settings` валидирует и сохраняет

---

