

# ТЗ FIX-01 — Приведение текущего проекта к канону backend-vault (SQLite + commands + services)

## 0) Цель

Сделать так, чтобы backend соответствовал канону step-2:

1. `main.rs` подключает `data::sqlite`, `services::*` и регистрирует **все** команды `folders/datacards/settings`.
2. `types.rs` соответствует каноничным структурам (Folder/DataCard/UserSettings + DTO input).
3. `schema.sql` соответствует канону (json-поля, индексы, unique, deleted_at, PRAGMA foreign_keys).
4. `init_database` использует миграции через `PRAGMA user_version`.
5. Убрать SQL-инъекцию через `ORDER BY {order}` и убрать `unwrap()` из парсинга дат.
6. `require_logged_in` проверяет **и logged_in_profile, и active_profile** (они должны совпадать).
7. Реализовать бизнес-правила папок и карточек (валидация, каскадные soft delete/restore/purge).
8. Проект собирается без ошибок.

---

## 1) Скоуп

Только backend (`src-tauri/src/**`). Фронт сейчас не трогаем.

---

## 2) Обязательные изменения по файлам

## 2.1 `src-tauri/src/main.rs` — подключить модули и команды

### Проблема

Сейчас `commands/mod.rs` объявляет `datacards/folders/settings`, но `main.rs`:

* не подключает `data::sqlite::*`
* не подключает `services::{datacards_service, folders_service, settings_service}`
* не импортирует команды `datacards/folders/settings`
* не регистрирует их в `invoke_handler`

### Требование

В `src-tauri/src/main.rs`:

1. В `mod data { ... }` добавить:

```rust
pub mod sqlite {
    pub mod init;
    pub mod migrations;
    pub mod repo_impl;
}
```

2. В `mod services { ... }` добавить:

```rust
pub mod datacards_service;
pub mod folders_service;
pub mod settings_service;
```

3. Обновить импорт команд:

```rust
use commands::{profiles::*, security::*, datacards::*, folders::*, settings::*};
```

4. В `invoke_handler(tauri::generate_handler![ ... ])` добавить **полный список** команд:

**Folders**

* `list_folders`
* `create_folder`
* `rename_folder`
* `move_folder`
* `delete_folder`
* `list_deleted_folders`
* `restore_folder`
* `purge_folder`

**DataCards**

* `list_datacards`
* `get_datacard`
* `create_datacard`
* `update_datacard`
* `move_datacard_to_folder` (см. пункт 2.6 — переименование)
* `delete_datacard`
* `list_deleted_datacards`
* `restore_datacard`
* `purge_datacard`

**Settings**

* `get_settings`
* `update_settings`

---

## 2.2 `src-tauri/src/types.rs` — привести структуры к канону

### Проблема

Сейчас `Folder/DataCard/UserSettings` урезаны и несовместимы с каноном (нет `is_system`, нет json-полей, даты `DateTime<Utc>`, поля `notes` вместо `note`, нет `tags`, `custom_fields`, `bank_card` и т.д.).

### Требование

Полностью переписать `src-tauri/src/types.rs` так, чтобы:

#### 2.2.1 Даты

Во всех публичных структурах **строки RFC3339**:

* `created_at: String`
* `updated_at: String`
* `deleted_at: Option<String>`

`chrono::DateTime<Utc>` в публичных моделях **не использовать**.

#### 2.2.2 Folder (канон)

```rust
pub struct Folder {
  pub id: String,
  pub name: String,
  pub parent_id: Option<String>,
  pub is_system: bool,
  pub created_at: String,
  pub updated_at: String,
  pub deleted_at: Option<String>,
}
```

#### 2.2.3 DataCard (канон)

Добавить `BankCard`, `CustomField`, `CustomFieldType` и сам `DataCard`:

* `note` (не `notes`)
* `tags: Vec<String>`
* `password: Option<String>`
* `bank_card: Option<BankCard>`
* `custom_fields: Vec<CustomField>`
* дополнительные поля `email`, `mobile_phone`

Структура:

```rust
pub struct DataCard {
  pub id: String,
  pub folder_id: Option<String>,

  pub title: String,
  pub url: Option<String>,
  pub email: Option<String>,
  pub username: Option<String>,
  pub mobile_phone: Option<String>,
  pub note: Option<String>,
  pub tags: Vec<String>,

  pub created_at: String,
  pub updated_at: String,
  pub deleted_at: Option<String>,

  pub password: Option<String>,
  pub bank_card: Option<BankCard>,
  pub custom_fields: Vec<CustomField>,
}
```

#### 2.2.4 UserSettings (канон + дефолты)

Заменить текущий `UserSettings` на полный каноничный набор полей:

```rust
pub struct UserSettings {
  pub auto_hide_secret_timeout_seconds: i64,
  pub auto_lock_enabled: bool,
  pub auto_lock_timeout: i64,
  pub reveal_requires_confirmation: bool,

  pub clipboard_clear_timeout_seconds: i64,

  pub soft_delete_enabled: bool,
  pub trash_retention_days: i64,

  pub backups_enabled: bool,
  pub backup_frequency: String, // daily|weekly|monthly
  pub backup_retention_days: i64,

  pub default_sort_field: String,     // created_at|updated_at|title
  pub default_sort_direction: String, // ASC|DESC

  pub mask_password_by_default: bool,
}
```

Сделать `impl Default for UserSettings` с дефолтами строго:

* `auto_hide_secret_timeout_seconds = 15`
* `clipboard_clear_timeout_seconds = 30`
* `auto_lock_enabled = true`
* `auto_lock_timeout = 300`
* `reveal_requires_confirmation = false`
* `soft_delete_enabled = true`
* `trash_retention_days = 30`
* `backups_enabled = false`
* `backup_frequency = "weekly"`
* `backup_retention_days = 30`
* `default_sort_field = "updated_at"`
* `default_sort_direction = "DESC"`
* `mask_password_by_default = true`

#### 2.2.5 DTO input (канон)

Добавить/обновить DTO:

Folders:

* `CreateFolderInput { name, parent_id }`
* `RenameFolderInput { id, name }`
* `MoveFolderInput { id, parent_id }`

DataCards:

* `CreateDataCardInput` (все поля как в каноне + `tags/custom_fields/bank_card`)
* `UpdateDataCardInput` (то же + `id`)
* `MoveDataCardInput { id, folder_id }`

---

## 2.3 `src-tauri/src/data/sqlite/schema.sql` — заменить на каноничный

### Проблема

Схема сейчас минимальная (нет `is_system`, нет json-колонок, нет индексов, нет unique на имя папки).

### Требование

Заменить содержимое `src-tauri/src/data/sqlite/schema.sql` **полностью** на:

```sql
PRAGMA foreign_keys = ON;

CREATE TABLE IF NOT EXISTS folders (
  id         TEXT PRIMARY KEY,
  name       TEXT NOT NULL,
  parent_id  TEXT NULL,
  is_system  INTEGER NOT NULL DEFAULT 0,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_folders_unique_name
ON folders(parent_id, name)
WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_folders_parent
ON folders(parent_id);

CREATE TABLE IF NOT EXISTS datacards (
  id           TEXT PRIMARY KEY,
  folder_id    TEXT NULL,

  title        TEXT NOT NULL,
  url          TEXT NULL,
  email        TEXT NULL,
  username     TEXT NULL,
  mobile_phone TEXT NULL,
  note         TEXT NULL,

  tags_json           TEXT NOT NULL DEFAULT '[]',
  password_value      TEXT NULL,
  bank_card_json      TEXT NULL,
  custom_fields_json  TEXT NOT NULL DEFAULT '[]',

  created_at   TEXT NOT NULL,
  updated_at   TEXT NOT NULL,
  deleted_at   TEXT NULL
);

CREATE INDEX IF NOT EXISTS idx_datacards_folder
ON datacards(folder_id);

CREATE INDEX IF NOT EXISTS idx_datacards_deleted
ON datacards(deleted_at);
```

---

## 2.4 `src-tauri/src/data/sqlite/migrations.rs` и `init.rs` — реальные миграции

### Проблема

`migrations.rs` заглушка. `init_database` просто применяет schema без `user_version` и без `ensure_profile_dirs`.

### Требование

#### 2.4.1 `src-tauri/src/data/sqlite/migrations.rs`

Реализовать миграции через `PRAGMA user_version`.

Константы:

* `const CURRENT_SCHEMA_VERSION: i32 = 1;`

Функции:

* `pub fn migrate_to_latest(conn: &Connection) -> Result<()>;`

Алгоритм `migrate_to_latest`:

1. `conn.execute_batch("PRAGMA foreign_keys = ON;")`
2. Прочитать `user_version`:

   * `let v: i32 = conn.query_row("PRAGMA user_version;", [], |r| r.get(0))?;`
3. Если `v == 0`:

   * `conn.execute_batch(include_str!("schema.sql"))`
   * `conn.execute_batch("PRAGMA user_version = 1;")`
4. Если `v == 1`: ничего не делать
5. Если `v > 1`: вернуть `DB_MIGRATION_FAILED`

Ошибки маппить в:

* `DB_QUERY_FAILED`
* `DB_MIGRATION_FAILED`

#### 2.4.2 `src-tauri/src/data/sqlite/init.rs`

Сделать:

```rust
pub fn init_database(profile_id: &str) -> Result<()>
```

Алгоритм строго:

1. `ensure_profile_dirs(profile_id)` (из `data/profiles/paths.rs`), ошибка → `PROFILE_STORAGE_WRITE`
2. `Connection::open(vault_db_path(profile_id))`, ошибка → `DB_OPEN_FAILED`
3. Вызвать `migrations::migrate_to_latest(&conn)`
4. Вернуть `Ok(())`

---

## 2.5 `src-tauri/src/data/sqlite/repo_impl.rs` — убрать SQL-инъекцию и unwrap, обновить под канон

### Проблемы

1. `ORDER BY {order}` строится из строк настроек → **SQL injection**.
2. `parse_datetime(...).unwrap()` → потенциальный краш.
3. Репозиторий работает со старой схемой (columns `notes/password`, нет json-колонок).

### Требования

#### 2.5.1 Сортировка — только через whitelisted SQL

Удалить сигнатуру:

```rust
pub fn list_datacards(profile_id: &str, include_deleted: bool, order: &str)
```

Заменить на:

```rust
pub fn list_datacards(
  profile_id: &str,
  include_deleted: bool,
  sort_field: &str,
  sort_dir: &str,
) -> Result<Vec<DataCard>>;
```

Внутри `repo_impl` сделать `match` по значениям (только эти):

* field: `created_at|updated_at|title`
* dir: `ASC|DESC`

И строить запрос только из **заранее заданных строк**, например:

* `updated_at DESC, title ASC`
* `created_at ASC, title ASC`
* `title DESC, updated_at DESC`

Если вход невалидный → вернуть `DB_QUERY_FAILED` (но по ТЗ валидировать ещё на уровне settings_service, так что сюда не должно долетать).

#### 2.5.2 Убрать unwrap

`parse_datetime` удалить вообще (публичные модели теперь хранят RFC3339 как строки).
Repo читает `created_at/updated_at/deleted_at` как `String/Option<String>` и возвращает как есть.

#### 2.5.3 CRUD под новую схему

Обновить mapping:

* `note` вместо `notes`
* `password_value` вместо `password`
* `tags_json/custom_fields_json/bank_card_json`

Сериализация/десериализация:

* `tags_json` ↔ `Vec<String>`
* `custom_fields_json` ↔ `Vec<CustomField>`
* `bank_card_json` ↔ `Option<BankCard>`

#### 2.5.4 Обновить/добавить repo-функции (минимум)

Folders:

* `list_folders(profile_id, include_deleted)`
* `create_folder(profile_id, name, parent_id)`
* `rename_folder(profile_id, id, name)`
* `move_folder(profile_id, id, parent_id)`
* `soft_delete_folder(profile_id, id)`
* `restore_folder(profile_id, id)`
* `purge_folder(profile_id, id)`

DataCards:

* `list_datacards(profile_id, include_deleted, sort_field, sort_dir)`
* `get_datacard(profile_id, id)`
* `create_datacard(profile_id, input: &CreateDataCardInput)`
* `update_datacard(profile_id, input: &UpdateDataCardInput)`
* `move_datacard(profile_id, id, folder_id)`
* `soft_delete_datacard(profile_id, id)`
* `restore_datacard(profile_id, id)`
* `purge_datacard(profile_id, id)`

---

## 2.6 Commands/API — привести имена и сигнатуры к канону

### Проблема

Команда перемещения карточки сейчас называется/используется неканонично (`move_datacard`), а в каноне — `move_datacard_to_folder`.

### Требование

1. В `src-tauri/src/commands/datacards.rs`:

   * экспортировать именно `move_datacard_to_folder(...)`
2. В `src-tauri/src/services/datacards_service.rs`:

   * публичная функция должна быть `move_datacard_to_folder(input, state)`
3. В `main.rs` зарегистрировать `move_datacard_to_folder` (а не старое имя).
4. Старые имена удалить, чтобы не было “двух правд”.

---

## 2.7 `require_logged_in` — проверка active_profile == logged_in_profile

### Проблема

Сейчас `require_logged_in` смотрит только `logged_in_profile`. Это позволяет дергать vault-команды, если active_profile другой.

### Требование

Во всех трёх сервисах:

* `services/datacards_service.rs`
* `services/folders_service.rs`
* `services/settings_service.rs`

Заменить `require_logged_in` на общий алгоритм:

1. Прочитать `active_profile` (Mutex) → `Option<String>`
2. Прочитать `logged_in_profile` (Mutex) → `Option<String>`
3. Если любое из них `None` → `VAULT_LOCKED`
4. Если `active_profile != logged_in_profile` → `VAULT_LOCKED`
5. Вернуть `active_profile.unwrap()` как `profile_id`

Ошибка на poisoned mutex → `STATE_UNAVAILABLE`.

---

## 2.8 `services/settings_service.rs` — расширить настройки до канона

### Проблема

Settings урезан, дефолты/поля не совпадают с каноном.

### Требование

1. После переписывания `types.rs` (пункт 2.2) обновить `settings_service.rs` под новый `UserSettings`.
2. `validate_settings` сделать по канону:

   * `auto_hide_secret_timeout_seconds`: 1..=600
   * `clipboard_clear_timeout_seconds`: 1..=600
   * `auto_lock_timeout`: 30..=86400
   * `trash_retention_days`: 1..=3650
   * `backup_retention_days`: 1..=3650
   * `backup_frequency` ∈ {daily, weekly, monthly}
   * `default_sort_field` ∈ {created_at, updated_at, title}
   * `default_sort_direction` ∈ {ASC, DESC}
3. `get_settings(profile_id)`:

   * если файла нет → создать дефолт и записать
4. Командные функции остаются:

   * `get_settings_command(state)`
   * `update_settings_command(state, settings)`

---

## 2.9 `services/datacards_service.rs` — каноничная логика + безопасная сортировка

### Проблемы

* Сортировка сейчас = строка из settings → инъекция.
* DTO/структуры неканоничны.

### Требование

1. После обновления `types.rs` обновить все функции под новые поля.
2. `sort_clause` **удалить**. Вместо него:

   * брать из `settings` `default_sort_field`/`default_sort_direction`
   * передавать в repo как (`sort_field`, `sort_dir`) и repo делает whitelist-match.
3. Валидация:

   * `title.trim().is_empty()` → `DATACARD_TITLE_REQUIRED`
   * `tags`: trim каждого, убрать пустые, убрать дубли (case-sensitive), сохранить порядок первого появления
4. `delete_datacard`:

   * если `settings.soft_delete_enabled == true` → soft delete
   * иначе → purge
5. `get_datacard`:

   * если repo не нашёл → `DATACARD_NOT_FOUND`

---

## 2.10 `services/folders_service.rs` — каноничная логика папок (имя/уникальность/каскады)

### Проблемы

Сейчас нет trim-валидации, нет `is_system`, нет каскада на datacards при delete/restore/purge.

### Требование

1. `create_folder`:

   * `name = name.trim()`; если пусто → `FOLDER_NAME_REQUIRED`
   * попытка вставить дубликат (уникальный индекс) → `FOLDER_NAME_EXISTS`
2. `rename_folder`:

   * `trim`, пусто → `FOLDER_NAME_REQUIRED`
   * duplicate → `FOLDER_NAME_EXISTS`
3. `delete_folder(id)`:

   * если `is_system == true` → `FOLDER_IS_SYSTEM`
   * выполнить soft delete папки
   * выполнить soft delete всех datacards с `folder_id == id`
4. `restore_folder(id)`:

   * восстановить папку (deleted_at=NULL)
   * восстановить все datacards из этой папки (deleted_at=NULL)
5. `purge_folder(id)`:

   * удалить физически папку
   * физически удалить все datacards этой папки

Для каскада добавить в `repo_impl` функции:

* `soft_delete_datacards_in_folder(profile_id, folder_id)`
* `restore_datacards_in_folder(profile_id, folder_id)`
* `purge_datacards_in_folder(profile_id, folder_id)`

---

## 3) Ошибки (ErrorCodeString.code) — фиксированный набор

Использовать эти коды (как минимум):

* `VAULT_LOCKED`
* `STATE_UNAVAILABLE`

DB:

* `DB_OPEN_FAILED`
* `DB_QUERY_FAILED`
* `DB_MIGRATION_FAILED`
* `DB_SCHEMA_APPLY` (если оставишь отдельно) / либо маппить в `DB_MIGRATION_FAILED`

Folders:

* `FOLDER_NAME_REQUIRED`
* `FOLDER_NAME_EXISTS`
* `FOLDER_NOT_FOUND`
* `FOLDER_IS_SYSTEM`

DataCards:

* `DATACARD_TITLE_REQUIRED`
* `DATACARD_NOT_FOUND`

Settings:

* `SETTINGS_READ`
* `SETTINGS_WRITE`
* `SETTINGS_PARSE`
* `SETTINGS_VALIDATION_FAILED`

---

## 4) Критерии приёмки (обязательные)

Считаем фиксы выполненными, если:

1. `src-tauri` собирается без ошибок.
2. После логина команды `folders/datacards/settings` доступны через `invoke`.
3. Без логина любая vault-команда возвращает `VAULT_LOCKED`.
4. `active_profile` и `logged_in_profile` должны совпадать — иначе `VAULT_LOCKED`.
5. В БД реально есть:

   * таблицы и индексы по канону
   * `PRAGMA user_version == 1`
6. Сортировка datacards не использует сырые строки в `ORDER BY` (никаких `format!("... {order}")`).
7. Нет `.unwrap()` при чтении БД/дат.
8. Папки:

   * имя trim и обязателен
   * дубликаты на одном уровне ловятся как `FOLDER_NAME_EXISTS`
   * delete/restore/purge делают каскад по карточкам
9. DataCards:

   * title обязателен
   * tags нормализуются
   * delete учитывает `soft_delete_enabled`
10. Settings:

* дефолты строго как в каноне
* update валидирует диапазоны и перечисления

---

