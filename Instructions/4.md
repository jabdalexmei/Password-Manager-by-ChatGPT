

# ТЗ FIX-02 — Доведение backend-vault до канона (подключение + типы + schema + миграции + безопасность)

## 0) Цель

Сделать так, чтобы backend строго соответствовал канону step-2:

* Все vault-команды (`folders`, `datacards`, `settings`) доступны через Tauri `invoke`.
* `types.rs` = каноничные структуры и DTO.
* SQLite `schema.sql` = канон.
* `init_database` = миграции через `PRAGMA user_version`.
* Убрана SQL-инъекция сортировки.
* `require_logged_in` проверяет и `active_profile`, и `logged_in_profile` (должны совпадать).
* Команда перемещения карточки называется **`move_datacard_to_folder`**.

---

# 1) Подключение модулей и команд в `main.rs`

## 1.1 Файл: `src-tauri/src/main.rs`

### 1.1.1 Подключить `data::sqlite`

Найти блок `mod data { ... }` и **добавить** внутрь:

```rust
pub mod sqlite {
  pub mod init;
  pub mod migrations;
  pub mod repo_impl;
}
```

### 1.1.2 Подключить services vault

Найти блок `mod services { ... }` и **добавить**:

```rust
pub mod datacards_service;
pub mod folders_service;
pub mod settings_service;
```

### 1.1.3 Импортировать новые команды

Найти строку импорта команд вида:

```rust
use commands::{profiles::*, security::*};
```

Заменить на:

```rust
use commands::{profiles::*, security::*, datacards::*, folders::*, settings::*};
```

### 1.1.4 Зарегистрировать команды в invoke_handler

Найти `tauri::generate_handler![ ... ]` и **добавить** команды (строго эти имена):

**Folders:**

* `list_folders`
* `create_folder`
* `rename_folder`
* `move_folder`
* `delete_folder`
* `list_deleted_folders`
* `restore_folder`
* `purge_folder`

**DataCards:**

* `list_datacards`
* `get_datacard`
* `create_datacard`
* `update_datacard`
* `move_datacard_to_folder`
* `delete_datacard`
* `list_deleted_datacards`
* `restore_datacard`
* `purge_datacard`

**Settings:**

* `get_settings`
* `update_settings`

⚠️ Если у тебя сейчас есть `move_datacard` — он должен быть переименован (см. раздел 5).

---

# 2) Каноничные структуры и DTO

## 2.1 Файл: `src-tauri/src/types.rs`

### Требование: полностью привести к канону

**Переписать** (или заменить соответствующие структуры) так, чтобы публичные модели имели даты **строками RFC3339**, а не `DateTime<Utc>`.

### 2.1.1 Folder

Добавить/исправить:

```rust
pub struct Folder {
  pub id: String,
  pub name: String,
  pub parent_id: Option<String>,
  pub is_system: bool,
  pub created_at: String,
  pub updated_at: String,
  pub deleted_at: Option<String>,
}
```

### 2.1.2 Custom fields + Bank card

Добавить:

```rust
#[serde(rename_all = "lowercase")]
pub enum CustomFieldType { Text, Secret, Url, Number, Date }

pub struct CustomField {
  pub key: String,
  pub value: String,
  #[serde(rename = "type")]
  pub field_type: CustomFieldType,
}

pub struct BankCard {
  pub holder: String,
  pub number: String,
  pub expiry_mm_yy: String,
  pub cvc: String,
  pub note: Option<String>,
}
```

### 2.1.3 DataCard

Исправить поля:

* `note` (не `notes`)
* добавить `email`, `mobile_phone`, `tags`, `bank_card`, `custom_fields`

```rust
pub struct DataCard {
  pub id: String,
  pub folder_id: Option<String>,

  pub title: String,
  pub url: Option<String>,
  pub email: Option<String>,
  pub username: Option<String>,
  pub mobile_phone: Option<String>,
  pub note: Option<String>,
  pub tags: Vec<String>,

  pub created_at: String,
  pub updated_at: String,
  pub deleted_at: Option<String>,

  pub password: Option<String>,
  pub bank_card: Option<BankCard>,
  pub custom_fields: Vec<CustomField>,
}
```

### 2.1.4 UserSettings (полный)

Заменить текущий `UserSettings` на:

```rust
#[serde(rename_all = "snake_case")]
pub struct UserSettings {
  pub auto_hide_secret_timeout_seconds: i64,
  pub auto_lock_enabled: bool,
  pub auto_lock_timeout: i64,
  pub reveal_requires_confirmation: bool,

  pub clipboard_clear_timeout_seconds: i64,

  pub soft_delete_enabled: bool,
  pub trash_retention_days: i64,

  pub backups_enabled: bool,
  pub backup_frequency: String, // daily|weekly|monthly
  pub backup_retention_days: i64,

  pub default_sort_field: String,     // created_at|updated_at|title
  pub default_sort_direction: String, // ASC|DESC

  pub mask_password_by_default: bool,
}
```

И `impl Default` (строго значения):

* `auto_hide_secret_timeout_seconds = 15`
* `clipboard_clear_timeout_seconds = 30`
* `auto_lock_enabled = true`
* `auto_lock_timeout = 300`
* `reveal_requires_confirmation = false`
* `soft_delete_enabled = true`
* `trash_retention_days = 30`
* `backups_enabled = false`
* `backup_frequency = "weekly"`
* `backup_retention_days = 30`
* `default_sort_field = "updated_at"`
* `default_sort_direction = "DESC"`
* `mask_password_by_default = true`

### 2.1.5 DTO input

Добавить/исправить:

Folders:

* `CreateFolderInput { name: String, parent_id: Option<String> }`
* `RenameFolderInput { id: String, name: String }`
* `MoveFolderInput { id: String, parent_id: Option<String> }`

DataCards:

* `CreateDataCardInput` (все поля DataCard кроме id/created/updated/deleted)
* `UpdateDataCardInput` (то же + `id`)
* `MoveDataCardInput { id: String, folder_id: Option<String> }`

---

# 3) SQLite schema: заменить на канон

## 3.1 Файл: `src-tauri/src/data/sqlite/schema.sql`

**Полностью заменить содержимое** на:

```sql
PRAGMA foreign_keys = ON;

CREATE TABLE IF NOT EXISTS folders (
  id         TEXT PRIMARY KEY,
  name       TEXT NOT NULL,
  parent_id  TEXT NULL,
  is_system  INTEGER NOT NULL DEFAULT 0,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_folders_unique_name
ON folders(parent_id, name)
WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_folders_parent
ON folders(parent_id);

CREATE TABLE IF NOT EXISTS datacards (
  id           TEXT PRIMARY KEY,
  folder_id    TEXT NULL,

  title        TEXT NOT NULL,
  url          TEXT NULL,
  email        TEXT NULL,
  username     TEXT NULL,
  mobile_phone TEXT NULL,
  note         TEXT NULL,

  tags_json           TEXT NOT NULL DEFAULT '[]',
  password_value      TEXT NULL,
  bank_card_json      TEXT NULL,
  custom_fields_json  TEXT NOT NULL DEFAULT '[]',

  created_at   TEXT NOT NULL,
  updated_at   TEXT NOT NULL,
  deleted_at   TEXT NULL
);

CREATE INDEX IF NOT EXISTS idx_datacards_folder
ON datacards(folder_id);

CREATE INDEX IF NOT EXISTS idx_datacards_deleted
ON datacards(deleted_at);
```

---

# 4) Миграции: user_version (не заглушка)

## 4.1 Файл: `src-tauri/src/data/sqlite/migrations.rs`

### Требование

Сделать реальные миграции:

* `CURRENT_SCHEMA_VERSION = 1`
* использовать `PRAGMA user_version`
* применять `include_str!("schema.sql")` при версии 0

Алгоритм:

1. `PRAGMA foreign_keys = ON`
2. прочитать `user_version`
3. если 0 → применить schema.sql → set user_version=1
4. если 1 → ничего
5. если >1 → ошибка `DB_MIGRATION_FAILED`

## 4.2 Файл: `src-tauri/src/data/sqlite/init.rs`

### Требование

`init_database(profile_id)` должен:

1. `ensure_profile_dirs(profile_id)` (из `data/profiles/paths.rs`)
2. открыть `vault_db_path(profile_id)`
3. вызвать `migrate_to_latest(&conn)`

Ошибки:

* open → `DB_OPEN_FAILED`
* миграция → `DB_MIGRATION_FAILED`

---

# 5) Команда перемещения карточки: переименовать в канон

## 5.1 Файл: `src-tauri/src/commands/datacards.rs`

Если есть команда `move_datacard`, то:

* **удалить/переименовать** её в `move_datacard_to_folder`
* сигнатура принимает `MoveDataCardInput`

Пример:

```rust
#[tauri::command]
pub fn move_datacard_to_folder(input: MoveDataCardInput, state: State<Arc<AppState>>) -> Result<bool, ErrorCodeString>
```

## 5.2 Файл: `src-tauri/src/services/datacards_service.rs`

* функция сервиса также должна называться `move_datacard_to_folder`
* и она вызывается командой с тем же именем

---

# 6) Vault auth: require_logged_in должен проверять active_profile == logged_in_profile

## 6.1 Файлы:

* `src-tauri/src/services/datacards_service.rs`
* `src-tauri/src/services/folders_service.rs`
* `src-tauri/src/services/settings_service.rs`

### Требование

В каждом сервисе заменить `require_logged_in` на один и тот же алгоритм:

1. `active = state.active_profile.lock()?`
2. `logged = state.logged_in_profile.lock()?`
3. если `active.is_none()` или `logged.is_none()` → `VAULT_LOCKED`
4. если `active != logged` → `VAULT_LOCKED`
5. вернуть `active.unwrap()` как `profile_id`

Если poisoned mutex → `STATE_UNAVAILABLE`.

---

# 7) Убрать SQL-инъекцию сортировки (обязательный фикс)

## 7.1 Файл: `src-tauri/src/services/datacards_service.rs`

### Требование

Удалить генерацию сортировки через `format!("{} {}", ...)`.

Вместо этого:

* брать `default_sort_field` и `default_sort_direction` из settings
* передавать в repo как два аргумента `sort_field`, `sort_dir`

## 7.2 Файл: `src-tauri/src/data/sqlite/repo_impl.rs`

### Требование

Запрещено делать SQL вида:

```rust
format!("... ORDER BY {}", order)
```

Нужно whitelist:

* field ∈ {`created_at`,`updated_at`,`title`}
* dir ∈ {`ASC`,`DESC`}

И строить ORDER BY только из заранее заданных констант:

* если field=updated_at → `ORDER BY updated_at {dir}, title ASC`
* если created_at → `ORDER BY created_at {dir}, title ASC`
* если title → `ORDER BY title {dir}, updated_at DESC`

---

# 8) Repo и mapping под новую схему (json поля)

## 8.1 Файл: `src-tauri/src/data/sqlite/repo_impl.rs`

### Требование

Обновить чтение/запись datacards:

* `note` колонка = `note` (не `notes`)
* `password_value` колонка = password
* `tags_json` ↔ `Vec<String>`
* `bank_card_json` ↔ `Option<BankCard>`
* `custom_fields_json` ↔ `Vec<CustomField>`

Любая ошибка JSON parse → `DB_QUERY_FAILED` (без паники).

### Убрать unwrap

Ни одного `.unwrap()` при чтении из БД/парсинге.

---

# 9) Бизнес-правила папок/карточек (канон)

## 9.1 `src-tauri/src/services/folders_service.rs`

* `name.trim()` обязателен:

  * пусто → `FOLDER_NAME_REQUIRED`
* конфликт уникальности (idx_folders_unique_name) → `FOLDER_NAME_EXISTS`
* delete_folder:

  * если `is_system == true` → `FOLDER_IS_SYSTEM`
  * soft-delete папку
  * soft-delete все datacards с `folder_id=id`
* restore_folder:

  * восстановить папку
  * восстановить datacards в этой папке
* purge_folder:

  * удалить папку физически
  * удалить datacards физически

Для этого добавить в repo функции:

* `soft_delete_datacards_in_folder(profile_id, folder_id)`
* `restore_datacards_in_folder(profile_id, folder_id)`
* `purge_datacards_in_folder(profile_id, folder_id)`

## 9.2 `src-tauri/src/services/datacards_service.rs`

* `title.trim()` обязателен → `DATACARD_TITLE_REQUIRED`
* нормализация tags:

  * trim
  * удалить пустые
  * убрать дубликаты (case-sensitive)
* delete_datacard:

  * если `settings.soft_delete_enabled` → soft delete
  * иначе → purge
* get_datacard:

  * не найден → `DATACARD_NOT_FOUND`

---

# 10) Settings: канон + валидация

## 10.1 `src-tauri/src/services/settings_service.rs`

* `get_settings`:

  * если нет файла → создать дефолтный `UserSettings::default()` и сохранить
* `update_settings`:

  * принимает полный объект
  * валидирует:

    * `auto_hide_secret_timeout_seconds`: 1..=600
    * `clipboard_clear_timeout_seconds`: 1..=600
    * `auto_lock_timeout`: 30..=86400
    * `trash_retention_days`: 1..=3650
    * `backup_retention_days`: 1..=3650
    * `backup_frequency`: daily|weekly|monthly
    * `default_sort_field`: created_at|updated_at|title
    * `default_sort_direction`: ASC|DESC
  * при ошибке → `SETTINGS_VALIDATION_FAILED`

---

# 11) Критерии приёмки (обязательные)

Считать работу выполненной, если:

1. `src-tauri` собирается.
2. В `invoke_handler` реально есть все команды vault-домена.
3. Без логина vault-команды возвращают `VAULT_LOCKED`.
4. При активном профиле A и залогиненном B vault-команды возвращают `VAULT_LOCKED`.
5. SQLite схема соответствует канону (есть `is_system`, `tags_json`, `custom_fields_json`, `bank_card_json`, unique index, индексы).
6. `PRAGMA user_version == 1`.
7. Нет SQL-инъекции (никаких сырых строк из settings в SQL).
8. Нет `.unwrap()` на путях чтения БД/JSON.
9. delete/restore/purge folders делает каскад по datacards.
10. дефолты `UserSettings` строго как в каноне, валидация работает.

---

