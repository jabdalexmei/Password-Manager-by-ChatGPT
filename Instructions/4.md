

# 1) `src-tauri/src/types.rs`

## 1.1 Заменить `BankCard`

**Найти (1 вхождение):**

```rust
pub struct BankCard {
    pub cardholder_name: Option<String>,
    pub number: Option<String>,
    pub exp_month: Option<i64>,
    pub exp_year: Option<i64>,
    pub security_code: Option<String>,
}
```

**Заменить на:**

```rust
pub struct BankCard {
    pub holder: String,
    pub number: String,
    pub expiry_mm_yy: String,
    pub cvc: String,
    pub note: Option<String>,
}
```

## 1.2 Заменить `CustomFieldType`

**Найти:**

```rust
#[serde(rename_all = "snake_case")]
pub enum CustomFieldType {
    Text,
    Secret,
    Number,
    Date,
}
```

**Заменить на:**

```rust
#[serde(rename_all = "lowercase")]
pub enum CustomFieldType { Text, Secret, Url, Number, Date }
```

## 1.3 Заменить `CustomField`

**Найти:**

```rust
pub struct CustomField {
    pub name: String,
    pub field_type: CustomFieldType,
    pub value: Option<String>,
}
```

**Заменить на:**

```rust
pub struct CustomField {
    pub key: String,
    pub value: String,
    #[serde(rename = "type")]
    pub field_type: CustomFieldType,
}
```

---

# 2) `src-tauri/src/data/sqlite/repo_impl.rs`

## 2.1 Заменить `list_folders(...)` и добавить `list_deleted_folders(...)`

**Найти целиком функцию:**

```rust
pub fn list_folders(profile_id: &str, include_deleted: bool) -> Result<Vec<Folder>> {
    let conn = open_connection(profile_id)?;
    let mut stmt = if include_deleted {
        conn.prepare("SELECT * FROM folders")
    } else {
        conn.prepare("SELECT * FROM folders WHERE deleted_at IS NULL")
    }
    .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    let folders = stmt
        .query_map([], map_folder)
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?
        .collect::<rusqlite::Result<Vec<_>>>()
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    Ok(folders)
}
```

**Заменить на (вставить ровно):**

```rust
pub fn list_folders(profile_id: &str) -> Result<Vec<Folder>> {
    let conn = open_connection(profile_id)?;
    let mut stmt = conn
        .prepare("SELECT * FROM folders WHERE deleted_at IS NULL ORDER BY name ASC")
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    let folders = stmt
        .query_map([], map_folder)
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?
        .collect::<rusqlite::Result<Vec<_>>>()
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    Ok(folders)
}

pub fn list_deleted_folders(profile_id: &str) -> Result<Vec<Folder>> {
    let conn = open_connection(profile_id)?;
    let mut stmt = conn
        .prepare("SELECT * FROM folders WHERE deleted_at IS NOT NULL ORDER BY deleted_at DESC")
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    let folders = stmt
        .query_map([], map_folder)
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?
        .collect::<rusqlite::Result<Vec<_>>>()
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    Ok(folders)
}
```

## 2.2 Обновлять `updated_at` при delete/restore папки

### `soft_delete_folder`

**Найти:**

```rust
"UPDATE folders SET deleted_at = ?1 WHERE id = ?2",
params![Utc::now().to_rfc3339(), id],
```

**Заменить на:**

```rust
"UPDATE folders SET deleted_at = ?1, updated_at = ?2 WHERE id = ?3",
params![Utc::now().to_rfc3339(), Utc::now().to_rfc3339(), id],
```

### `restore_folder`

**Найти:**

```rust
"UPDATE folders SET deleted_at = NULL WHERE id = ?1",
params![id],
```

**Заменить на:**

```rust
"UPDATE folders SET deleted_at = NULL, updated_at = ?1 WHERE id = ?2",
params![Utc::now().to_rfc3339(), id],
```

## 2.3 Обновлять `updated_at` при delete/restore карточки

### `soft_delete_datacard`

**Найти:**

```rust
"UPDATE datacards SET deleted_at = ?1 WHERE id = ?2",
params![Utc::now().to_rfc3339(), id],
```

**Заменить на:**

```rust
"UPDATE datacards SET deleted_at = ?1, updated_at = ?2 WHERE id = ?3",
params![Utc::now().to_rfc3339(), Utc::now().to_rfc3339(), id],
```

### `restore_datacard`

**Найти:**

```rust
"UPDATE datacards SET deleted_at = NULL WHERE id = ?1",
params![id],
```

**Заменить на:**

```rust
"UPDATE datacards SET deleted_at = NULL, updated_at = ?1 WHERE id = ?2",
params![Utc::now().to_rfc3339(), id],
```

## 2.4 Обновлять `updated_at` при каскадных delete/restore карточек в папке

### `soft_delete_datacards_in_folder`

**Найти:**

```rust
"UPDATE datacards SET deleted_at = ?1 WHERE folder_id = ?2",
params![Utc::now().to_rfc3339(), folder_id],
```

**Заменить на:**

```rust
"UPDATE datacards SET deleted_at = ?1, updated_at = ?2 WHERE folder_id = ?3",
params![Utc::now().to_rfc3339(), Utc::now().to_rfc3339(), folder_id],
```

### `restore_datacards_in_folder`

**Найти:**

```rust
"UPDATE datacards SET deleted_at = NULL WHERE folder_id = ?1",
params![folder_id],
```

**Заменить на:**

```rust
"UPDATE datacards SET deleted_at = NULL, updated_at = ?1 WHERE folder_id = ?2",
params![Utc::now().to_rfc3339(), folder_id],
```

## 2.5 Добавить `list_deleted_datacards(...)`

**Вставить новый метод** (лучше сразу перед `pub fn get_datacard(...)` в этом файле):

```rust
pub fn list_deleted_datacards(profile_id: &str) -> Result<Vec<DataCard>> {
    let conn = open_connection(profile_id)?;
    let mut stmt = conn
        .prepare("SELECT * FROM datacards WHERE deleted_at IS NOT NULL ORDER BY deleted_at DESC")
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    let cards = stmt
        .query_map([], map_datacard)
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?
        .collect::<rusqlite::Result<Vec<_>>>()
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    Ok(cards)
}
```

---

# 3) `src-tauri/src/services/folders_service.rs`

## 3.1 Исправить `list_folders`

**Найти:**

```rust
repo_impl::list_folders(&profile_id, false)
```

**Заменить на:**

```rust
repo_impl::list_folders(&profile_id)
```

## 3.2 Исправить `list_deleted_folders` (убрать retain)

**Найти целиком функцию:**

```rust
pub fn list_deleted_folders(state: &State<Arc<AppState>>) -> Result<Vec<Folder>> {
    let profile_id = require_logged_in(state)?;
    repo_impl::list_folders(&profile_id, true).map(|mut folders| {
        folders.retain(|f| f.deleted_at.is_some());
        folders
    })
}
```

**Заменить на:**

```rust
pub fn list_deleted_folders(state: &State<Arc<AppState>>) -> Result<Vec<Folder>> {
    let profile_id = require_logged_in(state)?;
    repo_impl::list_deleted_folders(&profile_id)
}
```

---

# 4) `src-tauri/src/services/datacards_service.rs`

## 4.1 Исправить `list_deleted_datacards` (убрать retain + settings)

**Найти функцию целиком:**

```rust
pub fn list_deleted_datacards(state: &State<Arc<AppState>>) -> Result<Vec<DataCard>> {
    let profile_id = require_logged_in(state)?;
    let settings = get_settings(&profile_id)?;
    let mut cards = repo_impl::list_datacards(
        &profile_id,
        true,
        &settings.default_sort_field,
        &settings.default_sort_direction,
    )?;
    cards.retain(|c| c.deleted_at.is_some());
    Ok(cards)
}
```

**Заменить на:**

```rust
pub fn list_deleted_datacards(state: &State<Arc<AppState>>) -> Result<Vec<DataCard>> {
    let profile_id = require_logged_in(state)?;
    repo_impl::list_deleted_datacards(&profile_id)
}
```

---

# 5) Мини-проверка приёмки (ручная)

1. `cd src-tauri && cargo build`
2. В UI/через invoke:

* создать профиль → логин
* создать папку → создать карточку
* удалить папку → карточка попадает в deleted (каскад)
* restore папку → карточка восстановилась
* при delete/restore у папки и карточки обновляется `updated_at`

---

