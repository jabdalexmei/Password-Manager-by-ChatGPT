

# Technical Specification (EN): Fix “no such table” on in-memory vault by routing all unlocked-vault queries through keeper connection + strengthen schema validation

## Background / Root Cause

When a protected vault is opened, the decrypted SQLite bytes are loaded via `Connection::deserialize(...)` into a **single keeper connection** stored in `state.vault_keeper_conn`.
However, all repository calls (`list_folders`, `list_datacards_summary`, `list_bank_cards_summary`, etc.) obtain connections from the **r2d2 pool** (`data/sqlite/pool.rs`). Those pooled connections open `file:pm_vault_<id>?mode=memory&cache=shared` but can still observe an empty schema. This results in runtime errors: `no such table: folders/datacards/bank_cards`. ([SQLite][1])

## Goal

1. When vault is unlocked and stored in memory, **all DB operations must use the keeper connection** (single source of truth).
2. Keep pooling only for file-based (passwordless) vaults.
3. Add **schema validation** after deserialize/migrate to fail fast (VAULT_CORRUPTED) instead of spamming logs.

---

## 1) Repository refactor: use keeper connection for unlocked vault

### 1.1 Add a helper that executes a closure with the correct connection

**File:** `src-tauri/src/data/sqlite/repo_impl.rs`

#### Replace the current `open_connection()` / `db_target()` approach with `with_connection()`

**Before (current patterns):**

* `db_target(...) -> DbTarget`
* `open_connection(...) -> PooledConnection<SqliteConnectionManager>`
* each repo fn does `let conn = open_connection(...)?;`

**After (exact code to add near top, replacing `db_target` + `open_connection`):**

```rust
use rusqlite::Connection;
use std::sync::Arc;

fn with_connection<T>(
    state: &Arc<AppState>,
    profile_id: &str,
    f: impl FnOnce(&Connection) -> Result<T>,
) -> Result<T> {
    // If this profile is the currently unlocked protected vault,
    // use the keeper connection (contains the deserialized in-memory DB).
    if let Ok(active_guard) = state.logged_in_profile.lock() {
        if active_guard.as_deref() == Some(profile_id) {
            if let Ok(mut keeper_guard) = state.vault_keeper_conn.lock() {
                if let Some(conn) = keeper_guard.as_ref() {
                    return f(conn);
                }
            }
        }
    }

    // Otherwise use file DB pool (passwordless vault on disk).
    let storage_paths = state.get_storage_paths()?;
    let target = DbTarget::File(vault_db_path(&storage_paths, profile_id)?);
    let pooled = pool::get_conn(profile_id, target)?;
    f(&pooled)
}
```

### 1.2 Update ALL repo functions to use `with_connection(...)`

**File:** `src-tauri/src/data/sqlite/repo_impl.rs`

For every function that currently starts like:

```rust
let conn = open_connection(state, profile_id)?;
```

Rewrite to:

```rust
with_connection(state, profile_id, |conn| {
    // existing function body, replacing `conn` variable accordingly
})
```

#### Example: `list_folders`

**Before:**

```rust
pub fn list_folders(state: &Arc<AppState>, profile_id: &str) -> Result<Vec<Folder>> {
    let conn = open_connection(state, profile_id)?;
    let sql = "SELECT * FROM folders WHERE deleted_at IS NULL ORDER BY name ASC";
    let mut stmt = conn.prepare(sql).map_err(|e| { ... })?;
    let folders = stmt.query_map([], map_folder) ...?;
    Ok(folders)
}
```

**After (exact):**

```rust
pub fn list_folders(state: &Arc<AppState>, profile_id: &str) -> Result<Vec<Folder>> {
    with_connection(state, profile_id, |conn| {
        let sql = "SELECT * FROM folders WHERE deleted_at IS NULL ORDER BY name ASC";
        let mut stmt = conn.prepare(sql).map_err(|e| {
            log_sqlite_err("list_folders.prepare", sql, &e);
            ErrorCodeString::new("DB_QUERY_FAILED")
        })?;

        let folders = stmt
            .query_map([], map_folder)
            .map_err(|e| {
                log_sqlite_err("list_folders.query_map", sql, &e);
                ErrorCodeString::new("DB_QUERY_FAILED")
            })?
            .collect::<rusqlite::Result<Vec<_>>>()
            .map_err(|e| {
                log_sqlite_err("list_folders.collect", sql, &e);
                ErrorCodeString::new("DB_QUERY_FAILED")
            })?;

        Ok(folders)
    })
}
```

#### Apply the same pattern to ALL functions in this file:

* folders CRUD
* datacards CRUD + summaries
* bank_cards CRUD + summaries
* attachments, password history, etc.

> This is a mechanical refactor inside a single file; no changes to public API surface are required.

### 1.3 Remove unused imports after refactor

After converting, `PooledConnection<SqliteConnectionManager>` and related r2d2 imports may become unused.

**File:** `src-tauri/src/data/sqlite/repo_impl.rs`

Remove if no longer used:

```rust
use r2d2::PooledConnection;
use r2d2_sqlite::SqliteConnectionManager;
```

---

## 2) Schema validation: fail fast if tables are missing (avoid log spam)

### 2.1 Add required-table validation in migrations module

**File:** `src-tauri/src/data/sqlite/migrations.rs`

Add below `migrate_to_latest`:

```rust
fn has_table(conn: &Connection, name: &str) -> Result<bool> {
    let sql = "SELECT 1 FROM sqlite_master WHERE type='table' AND name=?1 LIMIT 1";
    let exists: Option<i32> = conn
        .query_row(sql, [name], |row| row.get(0))
        .optional()
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
    Ok(exists.is_some())
}

pub fn validate_core_schema(conn: &Connection) -> Result<()> {
    // core tables expected by repository queries
    let required = ["folders", "datacards", "bank_cards"];
    for t in required {
        if !has_table(conn, t)? {
            return Err(ErrorCodeString::new("DB_SCHEMA_MISSING"));
        }
    }
    Ok(())
}
```

This uses `sqlite_master` which is SQLite’s system catalog for tables. ([Stack Overflow][2])

### 2.2 Call schema validation after migrate on vault open

**File:** `src-tauri/src/services/security_service.rs`

Inside `open_protected_vault_session(...)`, immediately after:

```rust
migrations::migrate_to_latest(&conn)?;
```

Add:

```rust
migrations::validate_core_schema(&conn)
    .map_err(|_| ErrorCodeString::new("VAULT_CORRUPTED"))?;
```

Rationale:

* If decrypt/deserialize produced a DB without required tables, treating it as corrupted is safer than silently continuing and spamming “no such table”.
* We intentionally **do not** auto-recreate schema here to avoid accidental data loss.

---

## 3) Clipboard reliability (mandatory): increase retry window to ~1.5s

(твоя обязательная хотелка, фикс “до идеала”)

**File:** `src-tauri/src/services/clipboard_service.rs`

Set:

```rust
const ATTEMPTS: usize = 60; // 60 * 25ms ~= 1500ms
const SLEEP_MS: u64 = 25;
```

This reduces false failures when clipboard is temporarily locked by other processes (very common on Windows). ([Microsoft Learn][3])

---

## 4) Post-fix verification steps

1. Unlock protected vault.
2. Observe logs: migration runs once, then no `[DB][list_*] no such table` errors.
3. UI loads folders/datacards/bank cards correctly.
4. Lock vault → ensure persistence still works (`serialize` uses keeper conn as before).
5. Copy secret → wait timeout → clipboard should clear; if another app locks clipboard briefly, it still clears within ~1.5s retry window.

---

## Why this is the “ideal” fix

* Removes the entire class of bugs caused by juggling **multiple connections to an in-memory DB** under a pool.
* Keeps pooling where it’s actually useful and stable: **file-based** DB.
* Converts runtime DB failures into a single deterministic error (`VAULT_CORRUPTED`) rather than endless noisy logs.
* Hardens clipboard clearing without hacks.

