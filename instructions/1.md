## Technical Specification (EN): “Edit fields” mode for custom fields in **Edit data card** dialog

### Goal

In **Edit data card** dialog:

1. Action Bar menu contains:

   * `customFields.add` → “Add field” (already exists)
   * **NEW** `customFields.editFields` → “Edit fields”
2. When user clicks **Edit fields**:

   * toggles **Edit Fields Mode** ON/OFF
3. In **Edit Fields Mode**, each custom field row shows:

   * **Rename** icon button: `<SquarePen />`
   * **Delete** icon button: Trash
4. Rename behavior:

   * opens a modal “Rename field”
   * user enters a new name
   * on OK, custom field **label/key changes**
   * custom field **value must NOT change/reset**
5. Delete behavior:

   * removes the custom field from the card (and it will be persisted on Save)
6. Persist:

   * on Save, updated `custom_fields` is sent (already wired via mapper in this version; do not regress)

### Non-goals

* No reorder, no “type” editing, no confirmation dialog on delete (unless later requested).
* No create-dialog “Edit fields” mode (only Edit dialog).

---

## Why “value must not disappear” (implementation invariant)

React preserves or resets input/component state based on element identity in the tree; **changing list keys** or using unstable keys (index/key-name) can remount nodes and cause “lost input” symptoms. Therefore, each custom field row must have a **stable `id`** and the render list must use `key={row.id}`. ([React][1])

---

## Files to change

### 1) Add icon mapping for SquarePen (Rename)

**File:** `src/components/lucide/icons.ts`

Add semantic exports (keep the file’s pattern: “meaningful name → lucide icon”):

```ts
import {
  // existing imports...
  SquarePen,
  Trash2,
} from "lucide-react";

export {
  // existing exports...
  SquarePen as IconRename,
  Trash2 as IconTrash,
};
```

> If `Trash2` is already exported under a different semantic name, reuse that mapping and only add `IconRename`.

---

### 2) Extend view model: rename + delete for Edit form custom fields

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

#### 2.1) Update view model type

Find the type (already includes `addEditCustomFieldByName`, `updateEditCustomFieldValue`) and add:

```ts
renameEditCustomFieldById: (
  rowId: string,
  nextName: string
) => { ok: true } | { ok: false; reason: "EMPTY" | "DUPLICATE" };

removeEditCustomFieldById: (rowId: string) => void;
```

#### 2.2) Implement `renameEditCustomFieldById`

Add near other custom field functions:

```ts
const renameEditCustomFieldById = useCallback(
  (rowId: string, nextName: string) => {
    const trimmed = nextName.trim();
    if (!trimmed) return { ok: false as const, reason: "EMPTY" as const };

    const exists = (editForm?.customFields ?? []).some((row) => {
      if (row.id === rowId) return false;
      return row.key.trim().toLowerCase() === trimmed.toLowerCase();
    });

    if (exists) return { ok: false as const, reason: "DUPLICATE" as const };

    setEditForm((prev) => {
      if (!prev) return prev;
      return {
        ...prev,
        customFields: prev.customFields.map((row) =>
          row.id === rowId ? { ...row, key: trimmed } : row
        ),
      };
    });

    return { ok: true as const };
  },
  [editForm]
);
```

**Important:** rename updates only `key`; must not touch `id`, `value`, `type`.

#### 2.3) Implement `removeEditCustomFieldById`

```ts
const removeEditCustomFieldById = useCallback((rowId: string) => {
  setEditForm((prev) => {
    if (!prev) return prev;
    return {
      ...prev,
      customFields: prev.customFields.filter((row) => row.id !== rowId),
    };
  });
}, []);
```

#### 2.4) Return these methods from hook

Add to the returned object (the `viewModel` return at bottom):

```ts
renameEditCustomFieldById,
removeEditCustomFieldById,
```

---

### 3) UI: add “Edit fields” menu item and edit-mode rendering

**File:** `src/features/Vault/components/DataCards/DataCards.tsx`

#### 3.1) Add UI state for edit-fields mode + rename modal

Near existing state:

```ts
const [isEditFieldsMode, setIsEditFieldsMode] = useState(false);

const [isRenameModalOpen, setIsRenameModalOpen] = useState(false);
const [renameTargetRowId, setRenameTargetRowId] = useState<string | null>(null);
const [renameName, setRenameName] = useState("");
const [renameError, setRenameError] = useState<string | null>(null);
```

Reset rules:

* When closing Edit dialog (`closeEditModal()`), do:

  * `setIsEditFieldsMode(false)`
  * `setIsRenameModalOpen(false)`
  * `setRenameTargetRowId(null)`
  * `setRenameName("")`
  * `setRenameError(null)`

Also in Escape handler (existing `handleKeyDown`), add:

```ts
if (isRenameModalOpen) {
  setIsRenameModalOpen(false);
  setRenameError(null);
  return;
}
```

#### 3.2) Add menu item “Edit fields” in Action Bar menu

In `renderDialog(...)`, inside the action menu `<div className="dialog-actionmenu">` where currently only:

```tsx
<button ...>{t('customFields.add')}</button>
```

Add **below it**, but only for edit dialog:

```tsx
{dialogId === "datacard-edit-dialog" && (
  <button
    type="button"
    className="dialog-actionmenu-item"
    onClick={() => {
      setIsActionMenuOpen(false);
      setIsEditFieldsMode((prev) => !prev);
    }}
  >
    {t("customFields.editFields")}
  </button>
)}
```

#### 3.3) Render custom fields with action icons (only in Edit Fields Mode)

Replace the current custom field rendering block:

```tsx
{form.customFields.map((row) => (
  <div className="form-field" key={row.id}>
    <label ...>{row.key}</label>
    <input ... />
  </div>
))}
```

with:

```tsx
{form.customFields.map((row) => (
  <div className="form-field" key={row.id}>
    <label className="form-label" htmlFor={`${dialogId}-cf-${row.id}`}>
      {row.key}
    </label>

    <div className="input-with-actions">
      <input
        id={`${dialogId}-cf-${row.id}`}
        className="input"
        value={row.value}
        onChange={(e) => {
          if (dialogId === "datacard-create-dialog") {
            viewModel.updateCreateCustomFieldValue(row.id, e.target.value);
          } else {
            viewModel.updateEditCustomFieldValue(row.id, e.target.value);
          }
        }}
      />

      {dialogId === "datacard-edit-dialog" && isEditFieldsMode && (
        <div className="input-actions">
          <button
            type="button"
            className="icon-button"
            aria-label={t("customFields.rename")}
            title={t("customFields.rename")}
            onClick={() => {
              setRenameTargetRowId(row.id);
              setRenameName(row.key);
              setRenameError(null);
              setIsRenameModalOpen(true);
            }}
          >
            <IconRename />
          </button>

          <button
            type="button"
            className="icon-button icon-button-danger"
            aria-label={t("customFields.delete")}
            title={t("customFields.delete")}
            onClick={() => viewModel.removeEditCustomFieldById(row.id)}
          >
            <IconTrash />
          </button>
        </div>
      )}
    </div>
  </div>
))}
```

**Must keep:** `key={row.id}`. (This is the core guarantee that rename won’t cause value reset.) ([React][1])

---

### 4) Add Rename modal component

**New file:** `src/features/Vault/components/modals/CustomFieldRenameModal.tsx`

Create a modal similar to existing `CustomFieldModal`, but for rename. Required API:

```ts
type CustomFieldRenameModalProps = {
  isOpen: boolean;
  name: string;
  error: string | null;
  onChangeName: (value: string) => void;
  onCancel: () => void;
  onOk: () => void;
};
```

UI structure must match existing dialogs:

* backdrop: `.dialog-backdrop dialog-backdrop--inner`
* container: `.dialog customfield-dialog`
* header title: `t("customFields.renameTitle")`
* input label: `t("customFields.nameLabel")`
* footer buttons: Cancel/OK

#### 4.1) Use the rename modal in `DataCards.tsx`

Import:

```ts
import { CustomFieldRenameModal } from "../modals/CustomFieldRenameModal";
```

Render alongside existing `<CustomFieldModal ... />`:

```tsx
<CustomFieldRenameModal
  isOpen={isRenameModalOpen}
  name={renameName}
  error={renameError}
  onChangeName={(v) => {
    setRenameName(v);
    setRenameError(null);
  }}
  onCancel={() => {
    setIsRenameModalOpen(false);
    setRenameError(null);
  }}
  onOk={() => {
    if (!renameTargetRowId) return;

    const result = viewModel.renameEditCustomFieldById(renameTargetRowId, renameName);
    if (!result.ok) {
      setRenameError(
        result.reason === "EMPTY"
          ? t("customFields.errorEmpty")
          : t("customFields.errorDuplicate")
      );
      return;
    }

    setIsRenameModalOpen(false);
    setRenameError(null);
  }}
/>
```

---

### 5) i18n keys

**File:** `src/i18n/English/DataCards.json`

Add:

```json
"customFields.editFields": "Edit fields",
"customFields.rename": "Rename field",
"customFields.delete": "Delete field",
"customFields.renameTitle": "Rename field"
```

Reuse existing:

* `customFields.nameLabel`
* `customFields.errorEmpty`
* `customFields.errorDuplicate`

---

## Acceptance Criteria

1. In **Edit data card** dialog, Action menu shows **Add field** and **Edit fields** (as in screenshot).
2. Clicking **Edit fields** toggles edit mode:

   * when ON, each custom field shows **Rename (SquarePen)** and **Delete (Trash)** icons.
   * when OFF, icons are hidden.
3. Rename opens modal and changes field name:

   * value stays the same (no clearing)
4. Delete removes the field row; after Save + reopen card, the field is gone.
5. No regressions to existing Add field flow.

---

## QA scenarios (must pass)

* Rename while field has a non-empty value → value preserved after rename.
* Rename to duplicate name (case-insensitive) → shows duplicate error, no changes applied.
* Rename to whitespace → shows empty error.
* Delete a field with value → removed and not persisted after Save.
* Toggle Edit fields ON/OFF does not affect field values.


