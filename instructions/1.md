*** Technical Specifications (patch-style, English) ***

File: src-tauri/src/data/profiles/registry.rs
Purpose: Add ability to create/upsert a profile record with a specific profile_id (needed for restore-from-backup when profile does not exist).

--- before
+++ after
@@
 use serde::{Deserialize, Serialize};
 use std::fs;
 use std::path::PathBuf;
 use uuid::Uuid;
@@
 pub fn create_profile(
     sp: &StoragePaths,
     name: &str,
     password: Option<String>,
 ) -> Result<ProfileMeta> {
@@
 }
+
+/// Create (or update) a profile record using a caller-provided profile_id.
+/// This is used by restore-from-backup: encrypted data is bound to profile_id via AEAD AAD,
+/// so we must recreate the same id to be able to decrypt restored vault/attachments.
+pub fn upsert_profile_with_id(
+    sp: &StoragePaths,
+    id: &str,
+    name: &str,
+    has_password: bool,
+) -> Result<ProfileMeta> {
+    ensure_profiles_dir(sp)?;
+
+    // Ensure profile dirs exist (id is used as folder name).
+    let profile_dir = crate::data::profiles::paths::profile_dir(sp, id)?;
+    crate::data::profiles::paths::ensure_profile_dirs(sp, id)
+        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+
+    // Write config.json with the name (keeps UI consistent).
+    let config_path: PathBuf = profile_config_path(sp, id)?;
+    let config = serde_json::json!({ "name": name });
+    let serialized_config = serde_json::to_string_pretty(&config)
+        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+    if let Err(err) = write_atomic(&config_path, &serialized_config) {
+        let _ = fs::remove_dir_all(&profile_dir);
+        return Err(err);
+    }
+
+    let mut registry = load_registry(sp)?;
+    if let Some(existing) = registry.profiles.iter_mut().find(|p| p.id == id) {
+        existing.name = name.to_string();
+        existing.has_password = has_password;
+        save_registry(sp, &registry)?;
+        return Ok(ProfileMeta {
+            id: id.to_string(),
+            name: name.to_string(),
+            has_password,
+        });
+    }
+
+    registry.profiles.push(ProfileRecord {
+        id: id.to_string(),
+        name: name.to_string(),
+        has_password,
+    });
+    save_registry(sp, &registry)?;
+
+    Ok(ProfileMeta {
+        id: id.to_string(),
+        name: name.to_string(),
+        has_password,
+    })
+}

File: src-tauri/src/services/backup_service.rs
Purpose:
- Include kdf_salt.bin and key_check.bin in backup archives (required for protected profiles).
- Add profile_name to manifest.json for better UX.
- Add inspect + workflow restore functions that do not require an active unlocked profile.
- Refactor restore logic to restore into a target profile_id (active restore still supported).

--- before
+++ after
@@
 use serde::{Deserialize, Serialize};
@@
 use crate::data::profiles::paths::{
-    backups_dir, backup_registry_path, profile_config_path, profile_dir, user_settings_path,
-    vault_db_path,
+    backups_dir, backup_registry_path, kdf_salt_path, key_check_path, profile_config_path,
+    profile_dir, user_settings_path, vault_db_path,
 };
 use crate::data::profiles::registry;
@@
 #[derive(Debug, Serialize, Deserialize)]
 struct BackupManifest {
     format_version: u32,
     created_at_utc: String,
     app_version: String,
     profile_id: String,
+    #[serde(default)]
+    profile_name: Option<String>,
     vault_mode: String,
     files: Vec<ManifestFileEntry>,
 }
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct BackupInspectResult {
+    pub profile_id: String,
+    pub profile_name: String,
+    pub created_at_utc: String,
+    pub vault_mode: String,
+    pub will_overwrite: bool,
+}
@@
 struct BackupSource {
     vault_path: PathBuf,
     attachments_path: PathBuf,
     config_path: Option<PathBuf>,
     settings_path: Option<PathBuf>,
+    kdf_salt_path: Option<PathBuf>,
+    key_check_path: Option<PathBuf>,
     _temp_dir: Option<tempfile::TempDir>,
 }
@@
-fn build_backup_source(
+fn build_backup_source(
     state: &Arc<AppState>,
     sp: &StoragePaths,
     profile_id: &str,
-) -> Result<(BackupSource, String)> {
+) -> Result<(BackupSource, String, String)> {
     let profile = registry::get_profile(sp, profile_id)?
         .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
+    let profile_name = profile.name.clone();
     let vault_mode = if profile.has_password {
         security_service::persist_active_vault(state)?;
         "protected".to_string()
     } else {
         "passwordless".to_string()
     };
@@
     let profile_root = profile_dir(sp, profile_id)?;
     let attachments_path = profile_root.join("attachments");
     let config_path = profile_config_path(sp, profile_id).ok();
     let settings_path = user_settings_path(sp, profile_id).ok();
+    let salt_path = kdf_salt_path(sp, profile_id).ok();
+    let key_check = key_check_path(sp, profile_id).ok();
@@
         Ok((
             BackupSource {
                 vault_path,
                 attachments_path,
                 config_path,
                 settings_path,
+                kdf_salt_path: salt_path,
+                key_check_path: key_check,
                 _temp_dir: Some(temp_dir),
             },
             vault_mode,
+            profile_name,
         ))
     } else {
         let vault_path = vault_db_path(sp, profile_id)?;
         Ok((
             BackupSource {
                 vault_path,
                 attachments_path,
                 config_path,
                 settings_path,
+                kdf_salt_path: salt_path,
+                key_check_path: key_check,
                 _temp_dir: None,
             },
             vault_mode,
+            profile_name,
         ))
     }
 }
@@
 fn create_archive(
     destination: &Path,
     source: BackupSource,
     profile_id: &str,
+    profile_name: &str,
     vault_mode: &str,
     created_at_utc: &str,
 ) -> Result<i64> {
@@
     add_file_to_zip(&mut writer, &source.vault_path, "vault.db", &mut manifest_entries)?;
@@
     add_optional_file(&mut writer, source.config_path, "config.json", &mut manifest_entries)?;
     add_optional_file(
         &mut writer,
         source.settings_path,
         "user_settings.json",
         &mut manifest_entries,
     )?;
+
+    // Critical for protected profiles (needed to re-derive/verify master key).
+    add_optional_file(&mut writer, source.kdf_salt_path, "kdf_salt.bin", &mut manifest_entries)?;
+    add_optional_file(&mut writer, source.key_check_path, "key_check.bin", &mut manifest_entries)?;
@@
     let manifest = BackupManifest {
         format_version: 1,
         created_at_utc: created_at_utc.to_string(),
         app_version: env!("CARGO_PKG_VERSION").to_string(),
         profile_id: profile_id.to_string(),
+        profile_name: Some(profile_name.to_string()),
         vault_mode: vault_mode.to_string(),
         files: manifest_entries,
     };
@@
 fn create_backup_internal(
     state: &Arc<AppState>,
     destination_path: Option<String>,
     use_default_path: bool,
 ) -> Result<BackupResult> {
@@
     let created_at_utc = now_utc_string();
-    let (source, vault_mode) = build_backup_source(state, &sp, &profile_id)?;
-    let bytes = create_archive(&destination_path, source, &profile_id, &vault_mode, &created_at_utc)?;
+    let (source, vault_mode, profile_name) = build_backup_source(state, &sp, &profile_id)?;
+    let bytes = create_archive(
+        &destination_path,
+        source,
+        &profile_id,
+        &profile_name,
+        &vault_mode,
+        &created_at_utc
+    )?;
@@
 }
+
+fn read_backup_manifest_and_name(
+    backup_path: &Path,
+) -> Result<(BackupManifest, String)> {
+    if !backup_path.exists() {
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+    }
+
+    let archive_file = fs::File::open(backup_path)
+        .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+    let mut archive = ZipArchive::new(archive_file)
+        .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+
+    let mut manifest_contents = String::new();
+    {
+        let mut manifest_file = archive
+            .by_name("manifest.json")
+            .map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_MISSING"))?;
+        manifest_file
+            .read_to_string(&mut manifest_contents)
+            .map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_INVALID"))?;
+    }
+
+    let manifest: BackupManifest =
+        serde_json::from_str(&manifest_contents).map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_INVALID"))?;
+
+    if manifest.format_version != 1 {
+        return Err(ErrorCodeString::new("BACKUP_UNSUPPORTED_FORMAT"));
+    }
+
+    // Best-effort profile name: manifest.profile_name -> config.json -> fallback.
+    if let Some(name) = manifest.profile_name.clone() {
+        return Ok((manifest, name));
+    }
+
+    // Try read config.json {"name": "..."} if present.
+    if let Ok(mut cfg_file) = archive.by_name("config.json") {
+        let mut cfg_contents = String::new();
+        if cfg_file.read_to_string(&mut cfg_contents).is_ok() {
+            if let Ok(v) = serde_json::from_str::<serde_json::Value>(&cfg_contents) {
+                if let Some(name) = v.get("name").and_then(|n| n.as_str()) {
+                    return Ok((manifest, name.to_string()));
+                }
+            }
+        }
+    }
+
+    Ok((manifest, "Restored profile".to_string()))
+}
+
+pub fn backup_inspect(state: &Arc<AppState>, backup_path: String) -> Result<BackupInspectResult> {
+    let sp = state.get_storage_paths()?;
+    let backup_path = PathBuf::from(&backup_path);
+    let (manifest, profile_name) = read_backup_manifest_and_name(&backup_path)?;
+    let will_overwrite = registry::get_profile(&sp, &manifest.profile_id)?.is_some();
+
+    Ok(BackupInspectResult {
+        profile_id: manifest.profile_id,
+        profile_name,
+        created_at_utc: manifest.created_at_utc,
+        vault_mode: manifest.vault_mode,
+        will_overwrite,
+    })
+}
+
+fn restore_archive_to_profile(
+    state: &Arc<AppState>,
+    sp: &StoragePaths,
+    target_profile_id: &str,
+    backup_path: &Path,
+) -> Result<bool> {
+    let backup_path = PathBuf::from(backup_path);
+    if !backup_path.exists() {
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+    }
+
+    let profile_root = profile_dir(sp, target_profile_id)?;
+    fs::create_dir_all(profile_root.join("tmp"))
+        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+    let temp_dir = tempfile::Builder::new()
+        .prefix("backup_restore")
+        .tempdir_in(profile_root.join("tmp"))
+        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+
+    let archive_file = fs::File::open(&backup_path)
+        .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+    let mut archive = ZipArchive::new(archive_file)
+        .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+
+    let mut manifest_contents = String::new();
+    {
+        let mut manifest_file = archive
+            .by_name("manifest.json")
+            .map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_MISSING"))?;
+        manifest_file
+            .read_to_string(&mut manifest_contents)
+            .map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_INVALID"))?;
+    }
+
+    let manifest: BackupManifest =
+        serde_json::from_str(&manifest_contents).map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_INVALID"))?;
+
+    if manifest.format_version != 1 {
+        return Err(ErrorCodeString::new("BACKUP_UNSUPPORTED_FORMAT"));
+    }
+
+    // Restore must always target the same profile_id (crypto AAD binding).
+    if manifest.profile_id != target_profile_id {
+        return Err(ErrorCodeString::new("BACKUP_PROFILE_MISMATCH"));
+    }
+
+    use std::collections::HashSet;
+    let mut seen = HashSet::new();
+    let mut has_vault = false;
+    for f in &manifest.files {
+        if !seen.insert(&f.path) {
+            return Err(ErrorCodeString::new("BACKUP_MANIFEST_INVALID"));
+        }
+        if f.path == "vault.db" {
+            has_vault = true;
+        }
+    }
+    if !has_vault {
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+    }
+
+    for entry in &manifest.files {
+        let rel_path = Path::new(&entry.path);
+        if !validate_zip_entry_rel_path_windows(rel_path) {
+            return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+        }
+        let mut zipped_file = archive
+            .by_name(&entry.path)
+            .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+        let target_path = temp_dir.path().join(rel_path);
+        if let Some(parent) = target_path.parent() {
+            fs::create_dir_all(parent)
+                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+        }
+        let file = fs::File::create(&target_path)
+            .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+        let mut writer = BufWriter::new(file);
+        let mut buffer = [0u8; 64 * 1024];
+        let mut hasher = Sha256::new();
+        let mut bytes_written = 0i64;
+        loop {
+            let read = zipped_file
+                .read(&mut buffer)
+                .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+            if read == 0 {
+                break;
+            }
+            writer
+                .write_all(&buffer[..read])
+                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+            hasher.update(&buffer[..read]);
+            bytes_written += read as i64;
+        }
+        writer.flush().map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+        let sha256 = hex::encode(hasher.finalize());
+        if sha256 != entry.sha256 || bytes_written != entry.bytes {
+            return Err(ErrorCodeString::new("BACKUP_INTEGRITY_FAILED"));
+        }
+    }
+
+    let vault_path = vault_db_path(sp, target_profile_id)?;
+    let extracted_vault = temp_dir.path().join("vault.db");
+    if !extracted_vault.exists() {
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+    }
+
+    let attachments_path = profile_root.join("attachments");
+    let extracted_attachments = temp_dir.path().join("attachments");
+
+    let vault_backup_path = vault_path.with_extension(format!("old.{}", Uuid::new_v4()));
+    let attachments_backup_path = profile_root.join(format!("attachments.old.{}", Uuid::new_v4()));
+    let mut moved_vault = false;
+    let mut moved_attachments = false;
+    let restore_result: Result<()> = (|| {
+        if vault_path.exists() {
+            rename_with_retry(&vault_path, &vault_backup_path)
+                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+            moved_vault = true;
+        }
+
+        let vault_tmp_path = profile_root.join(format!("vault.db.restore.{}", Uuid::new_v4()));
+        fs::copy(&extracted_vault, &vault_tmp_path)
+            .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+        rename_with_retry(&vault_tmp_path, &vault_path)
+            .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+
+        if attachments_path.exists() {
+            rename_with_retry(&attachments_path, &attachments_backup_path)
+                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+            moved_attachments = true;
+        }
+
+        if extracted_attachments.exists() {
+            rename_with_retry(&extracted_attachments, &attachments_path)
+                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+        } else {
+            fs::create_dir_all(&attachments_path)
+                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+        }
+
+        for file_name in ["config.json", "user_settings.json", "kdf_salt.bin", "key_check.bin"] {
+            let extracted_file = temp_dir.path().join(file_name);
+            if extracted_file.exists() {
+                let target = profile_root.join(file_name);
+                if target.exists() {
+                    let _ = fs::remove_file(&target);
+                }
+                rename_with_retry(&extracted_file, &target)
+                    .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+            }
+        }
+
+        Ok(())
+    })();
+
+    if restore_result.is_err() {
+        if vault_path.exists() {
+            let _ = fs::remove_file(&vault_path);
+        }
+        if moved_vault && vault_backup_path.exists() {
+            let _ = fs::rename(&vault_backup_path, &vault_path);
+        }
+        if attachments_path.exists() && !moved_attachments {
+            let _ = fs::remove_dir_all(&attachments_path);
+        }
+        if moved_attachments && attachments_backup_path.exists() {
+            let _ = fs::rename(&attachments_backup_path, &attachments_path);
+        }
+        return Err(ErrorCodeString::new("BACKUP_RESTORE_FAILED"));
+    }
+
+    if vault_backup_path.exists() {
+        let _ = fs::remove_file(&vault_backup_path);
+    }
+    if attachments_backup_path.exists() {
+        let _ = fs::remove_dir_all(&attachments_backup_path);
+    }
+
+    let wal_path = vault_path.with_extension("db-wal");
+    let shm_path = vault_path.with_extension("db-shm");
+    let _ = fs::remove_file(&wal_path);
+    let _ = fs::remove_file(&shm_path);
+
+    Ok(true)
+}
@@
 pub fn backup_restore(state: &Arc<AppState>, backup_path: String) -> Result<bool> {
     let _guard = ensure_backup_guard(state)?;
 
     let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
     security_service::drop_active_session_without_persist(state)?;
     let sp = state.get_storage_paths()?;
 
-    let backup_path = PathBuf::from(&backup_path);
-    if !backup_path.exists() {
-        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
-    }
-
-    let profile_root = profile_dir(&sp, &profile_id)?;
-    fs::create_dir_all(profile_root.join("tmp"))
-        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-    let temp_dir = tempfile::Builder::new()
-        .prefix("backup_restore")
-        .tempdir_in(profile_root.join("tmp"))
-        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-
-    let archive_file = fs::File::open(&backup_path)
-        .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
-    let mut archive = ZipArchive::new(archive_file)
-        .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
-
-    let mut manifest_contents = String::new();
-    {
-        let mut manifest_file = archive
-            .by_name("manifest.json")
-            .map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_MISSING"))?;
-        manifest_file
-            .read_to_string(&mut manifest_contents)
-            .map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_INVALID"))?;
-    }
-
-    let manifest: BackupManifest =
-        serde_json::from_str(&manifest_contents).map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_INVALID"))?;
-
-    if manifest.format_version != 1 {
-        return Err(ErrorCodeString::new("BACKUP_UNSUPPORTED_FORMAT"));
-    }
-
-    if manifest.profile_id != profile_id {
-        return Err(ErrorCodeString::new("BACKUP_PROFILE_MISMATCH"));
-    }
-
-    ... (full restore implementation) ...
-
-    Ok(true)
+    let backup_path = PathBuf::from(&backup_path);
+    restore_archive_to_profile(state, &sp, &profile_id, &backup_path)
 }
+
+pub fn backup_restore_workflow(state: &Arc<AppState>, backup_path: String) -> Result<bool> {
+    let _guard = ensure_backup_guard(state)?;
+    security_service::drop_active_session_without_persist(state)?;
+    let sp = state.get_storage_paths()?;
+
+    let backup_path = PathBuf::from(&backup_path);
+    let (manifest, profile_name) = read_backup_manifest_and_name(&backup_path)?;
+
+    // Ensure profile exists; if not, create it with the SAME id from backup.
+    let exists = registry::get_profile(&sp, &manifest.profile_id)?.is_some();
+    if !exists {
+        let has_password = manifest.vault_mode == "protected";
+        registry::upsert_profile_with_id(&sp, &manifest.profile_id, &profile_name, has_password)?;
+    }
+
+    restore_archive_to_profile(state, &sp, &manifest.profile_id, &backup_path)
+}

File: src-tauri/src/commands/backup.rs
Purpose: Expose backup_inspect + backup_restore_workflow to the frontend.

--- before
+++ after
@@
 use crate::services::backup_service::{
     backup_create as backup_create_service, backup_create_if_due_auto as backup_create_if_due_auto_service,
-    backup_list as backup_list_service, backup_restore as backup_restore_service, BackupListItem,
+    backup_inspect as backup_inspect_service,
+    backup_list as backup_list_service,
+    backup_restore as backup_restore_service,
+    backup_restore_workflow as backup_restore_workflow_service,
+    BackupInspectResult,
+    BackupListItem,
 };
@@
 #[tauri::command]
 pub async fn backup_restore(backup_path: String, state: State<'_, Arc<AppState>>) -> Result<bool> {
@@
 }
+
+#[tauri::command]
+pub async fn backup_inspect(backup_path: String, state: State<'_, Arc<AppState>>) -> Result<BackupInspectResult> {
+    let app = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || backup_inspect_service(&app, backup_path))
+        .await
+        .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
+#[tauri::command]
+pub async fn backup_restore_workflow(backup_path: String, state: State<'_, Arc<AppState>>) -> Result<bool> {
+    let app = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || backup_restore_workflow_service(&app, backup_path))
+        .await
+        .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}

File: src-tauri/src/main.rs
Purpose: Register new Tauri commands.

--- before
+++ after
@@
             backup_create,
             backup_restore,
+            backup_inspect,
+            backup_restore_workflow,
             backup_list,
             backup_create_if_due_auto,
@@

File: src/shared/lib/tauri.ts
Purpose: Add typed wrappers for new backend commands used by Workspace flow.

--- before
+++ after
@@
 export function workspaceOpenInExplorer(): Promise<boolean> {
   return invoke('workspace_open_in_explorer');
 }
+
+export type BackupInspectResult = {
+  profile_id: string;
+  profile_name: string;
+  created_at_utc: string;
+  vault_mode: string;
+  will_overwrite: boolean;
+};
+
+export function backupInspect(backupPath: string): Promise<BackupInspectResult> {
+  return invoke('backup_inspect', { backupPath });
+}
+
+export function backupRestoreWorkflow(backupPath: string): Promise<boolean> {
+  return invoke('backup_restore_workflow', { backupPath });
+}

File: src/i18n/locales/en/Workspace.json
Purpose: Add UI strings for restore-from-backup workflow.

--- before
+++ after
@@
 {
   "title": "Workspace",
   "subtitle": "Choose or create a data folder before continuing.",
   "workspaces": "Available workspaces",
   "loading": "Loading workspaces...",
   "error": "Unable to load workspaces.",
   "empty": "No workspaces yet. Use Create, Create in the default path, or Open data folder to select a folder and initialize it.",
   "chooseFolder": "Choose data folder",
+  "chooseBackupFile": "Choose backup file",
   "create": "Create",
   "createDefaultPath": "Create in the default path",
+  "restoreFromBackup": "Restore from backup",
+  "restoreConfirmTitle": "Restore backup",
+  "restoreConfirmOverwrite": "Backup matches existing profile: {{name}} → restore into it (overwrite).",
+  "restoreInfoCreate": "No matching profile found → creating new profile: {{name}} (restored).",
+  "restoreSuccess": "Backup restored",
   "openDataFolder": "Open data folder",
   "missing": "Missing",
   "invalid": "Invalid",
   "removeFromList": "Remove from list",
   "open": "Open",
   "actions": "Actions"
 }

File: src/features/Workspace/Workspace.tsx
Purpose:
- Add "Restore from backup" CTA in Workflow/Workspace screen.
- Implement restore flow: pick backup file -> pick workspace folder -> create/select workspace -> inspect -> confirm overwrite (if needed) -> restore -> proceed.

--- before
+++ after
@@
 import React, { useCallback, useMemo, useState } from 'react';
 import { open } from '@tauri-apps/plugin-dialog';
 import { useTranslation } from '../../shared/lib/i18n';
 import {
+  backupInspect,
+  backupRestoreWorkflow,
   workspaceCreate,
   workspaceCreateDefault,
   workspaceOpenInExplorer,
   workspaceSelect,
 } from '../../shared/lib/tauri';
+import ConfirmDialog from '../../shared/components/ConfirmDialog';
+import { useToaster } from '../../shared/components/Toaster';
 import { useWorkspace } from './hooks/useWorkspace';
@@
 const Workspace: React.FC<WorkspaceProps> = ({ onWorkspaceReady }) => {
   const { t } = useTranslation('Workspace');
+  const { show: showToast } = useToaster();
   const { workspaces, loading, error, selectedId, setSelectedId, refresh, remove } = useWorkspace();
   const [busy, setBusy] = useState(false);
+  const [confirmOpen, setConfirmOpen] = useState(false);
+  const [pendingBackupPath, setPendingBackupPath] = useState<string | null>(null);
+  const [pendingProfileName, setPendingProfileName] = useState<string>('');
@@
   const handleCreateDefault = useCallback(async () => {
@@
   }, [onWorkspaceReady, refresh]);
+
+  const handleRestoreFromBackup = useCallback(async () => {
+    setBusy(true);
+    try {
+      const backup = await open({
+        directory: false,
+        multiple: false,
+        title: t('chooseBackupFile'),
+        filters: [{ name: 'Backup', extensions: ['zip'] }],
+      });
+      if (typeof backup !== 'string') return;
+
+      const targetFolder = await open({
+        directory: true,
+        multiple: false,
+        title: t('chooseFolder'),
+      });
+      if (typeof targetFolder !== 'string') return;
+
+      // Initialize/select workspace first (so backend has StoragePaths).
+      await workspaceCreate(targetFolder);
+      await refresh();
+
+      const info = await backupInspect(backup);
+      setPendingBackupPath(backup);
+      setPendingProfileName(info.profile_name);
+
+      if (info.will_overwrite) {
+        setConfirmOpen(true);
+        return;
+      }
+
+      // No overwrite: restore immediately, but still show explicit info via toast.
+      showToast(t('restoreInfoCreate', { name: info.profile_name }), 'success');
+      await backupRestoreWorkflow(backup);
+      showToast(t('restoreSuccess'), 'success');
+      onWorkspaceReady();
+    } finally {
+      setBusy(false);
+    }
+  }, [onWorkspaceReady, refresh, showToast, t]);
@@
   return (
     <div className="screen-shell">
       <div className="screen-card screen-card--xl workspace-card-mock">
@@
           <section className="workspace-right">
             <button
               type="button"
               className="btn btn-primary workspace-cta"
               onClick={handleCreate}
               disabled={busy}
             >
               {t('create')}
             </button>
@@
             <button
               type="button"
               className="btn btn-primary workspace-cta"
               onClick={handleCreateDefault}
               disabled={busy}
             >
               {t('createDefaultPath')}
             </button>
+
+            <button
+              type="button"
+              className="btn btn-primary workspace-cta"
+              onClick={handleRestoreFromBackup}
+              disabled={busy}
+            >
+              {t('restoreFromBackup')}
+            </button>
@@
             <button
               type="button"
               className="btn btn-secondary workspace-cta-secondary"
               onClick={handleOpenDataFolder}
               disabled={busy}
             >
               {t('openDataFolder')}
             </button>
@@
           </section>
         </div>
       </div>
+
+      <ConfirmDialog
+        open={confirmOpen}
+        title={t('restoreConfirmTitle')}
+        description={t('restoreConfirmOverwrite', { name: pendingProfileName })}
+        confirmLabel={t('restoreFromBackup')}
+        cancelLabel="Cancel"
+        onCancel={() => {
+          setConfirmOpen(false);
+          setPendingBackupPath(null);
+        }}
+        onConfirm={async () => {
+          const path = pendingBackupPath;
+          setConfirmOpen(false);
+          setPendingBackupPath(null);
+          if (!path) return;
+          setBusy(true);
+          try {
+            await backupRestoreWorkflow(path);
+            showToast(t('restoreSuccess'), 'success');
+            onWorkspaceReady();
+          } finally {
+            setBusy(false);
+          }
+        }}
+      />
     </div>
   );
 };
