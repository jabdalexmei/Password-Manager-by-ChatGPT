
# Technical Specification (EN): Auto-backup noise suppression + invoke argument naming convention (Tauri)

## 0) Scope

Implement two focused improvements:

1. **Auto-backup should NOT show an error toast** when the backend returns `BACKUP_ALREADY_RUNNING` (expected conflict with manual export/restore).

2. **Enforce a single invoke argument naming convention** to prevent “missing field / wrong values” issues caused by mixing `snake_case` and `camelCase`.

No other backup UX changes are included.

---

## 1) Auto-backup: ignore `BACKUP_ALREADY_RUNNING` (no toast)

### Problem

Auto-backup runs periodically (e.g., once per minute). If the user triggers manual export/restore at the same time, backend may return `BACKUP_ALREADY_RUNNING`. The UI currently shows an “error” toast, creating a false impression that backups are broken.

### Required behavior

* If the **auto-backup** call fails with code `BACKUP_ALREADY_RUNNING`, **do nothing** (no toast, no modal, no error UI).
* For any other auto-backup error, keep existing error handling (toast / error UI).

### Files

* `src/features/Vault/Vault.tsx` (or the file where the auto-backup `setInterval` is implemented and `createBackupIfDueAuto()` is called)

### Implementation details

1. Locate the timer block (typical pattern):

```ts
setInterval(() => {
  createBackupIfDueAuto()
    .then(...)
    .catch(handleBackupError);
}, 60_000);
```

2. Replace the `.catch(...)` for the auto-backup call with a wrapper that suppresses `BACKUP_ALREADY_RUNNING`:

**Exact required change (example):**

```ts
createBackupIfDueAuto()
  .then((path) => {
    if (path) {
      // keep existing success behavior (optional toast)
    }
  })
  .catch((err) => {
    const code =
      err?.code ??
      err?.error ??
      err?.message ??
      'UNKNOWN';

    if (code === 'BACKUP_ALREADY_RUNNING') {
      return; // ignore expected contention
    }

    handleBackupError(err); // existing behavior for real errors
  });
```

### Acceptance criteria

* While a manual backup/restore is running, auto-backup does not produce any error toast if the backend returns `BACKUP_ALREADY_RUNNING`.
* Real errors (e.g., archive invalid, disk access denied) still show the current error UI.

---

## 2) Tauri invoke arguments: standardize `camelCase` keys in frontend (and document exception)

### Problem

Developers may pass `snake_case` keys from the frontend when calling `invoke(...)`, which can lead to “missing field” errors or wrong values.

Tauri converts Rust `snake_case` command argument names to `camelCase` for JavaScript by default. ([Tauri][1])
If you want to pass `snake_case` keys from JavaScript, Tauri supports `#[tauri::command(rename_all = "snake_case")]`. ([Tauri][1])

### Required behavior / convention

* **Frontend must always pass command argument object keys in `camelCase`.**
* **Rust command parameters remain `snake_case`.**
* Do **not** add `rename_all = "snake_case"` to commands unless you explicitly decide to pass `snake_case` from the frontend.

### Files

* Frontend: all places that call `invoke(...)` for backup/settings commands, at minimum:

  * `src/features/Vault/api/vaultApi.ts` (or wherever `backup_create_if_due_auto`, `backup_create`, `backup_restore`, `update_settings` are invoked)

### Implementation details

1. Audit each `invoke(...)` call and ensure keys are `camelCase`. Examples:

**Rust command signature example**

```rust
#[tauri::command]
fn backup_create(destination_path: Option<String>, use_default_path: bool) -> Result<String>
```

**Frontend must call**

```ts
invoke('backup_create', {
  destinationPath: ...,
  useDefaultPath: ...,
});
```

2. Add a short code comment at the top of the API file where these invocations live:

**Required comment (exact content)**

```ts
// Tauri convention: Rust snake_case command args are passed as camelCase from the frontend by default.
// Do not send snake_case keys unless the Rust command uses #[tauri::command(rename_all = "snake_case")].
```

3. Optional (recommended): add an ESLint rule or a simple unit test that checks the argument object keys for `invoke(...)` calls in this file are camelCase (no `_*` underscores). (If you already have lint infra, do it; otherwise skip.)

### Acceptance criteria

* No backup/settings command invocations pass `snake_case` keys from the frontend.
* A developer reading the API file immediately sees the convention and how to intentionally switch to snake_case if ever needed. ([Tauri][1])


