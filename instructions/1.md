
## TECHNICAL SPEC (EN) — First-class TOTP (2FA) field for Data Cards

### 0) Goal

Add built-in TOTP (2FA) support to **Data Cards** so the user can:

1. Open **Edit Data Card → action bar (three dots) → “Add 2FA”**
2. In a modal, either:

   * paste an `otpauth://...` URI OR a Base32 secret, OR
   * upload a QR image, app decodes it and extracts `otpauth://...`
3. Save → card now stores 2FA configuration
4. Details screen shows a dedicated **2FA** section with:

   * current 6-digit code (auto-refresh)
   * countdown (time remaining)
   * Copy code button
5. No custom fields are used for TOTP.

### 1) Data Model (SQLite)

#### 1.1 Add `totp_uri` column to `datacards`

File:
`src-tauri/src/data/sqlite/schema.sql`

Modify `datacards` table definition by adding a nullable column:

**BEFORE**

```sql
CREATE TABLE IF NOT EXISTS datacards (
  id TEXT PRIMARY KEY,
  folder_id TEXT,
  title TEXT NOT NULL,
  url TEXT,
  email TEXT,
  username TEXT,
  mobile_phone TEXT,
  note TEXT,
  is_favorite INTEGER NOT NULL DEFAULT 0,
  tags_json TEXT NOT NULL DEFAULT '[]',
  password_value TEXT,
  custom_fields_json TEXT NOT NULL DEFAULT '[]',
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,
  FOREIGN KEY (folder_id) REFERENCES folders(id)
);
```

**AFTER**

```sql
CREATE TABLE IF NOT EXISTS datacards (
  id TEXT PRIMARY KEY,
  folder_id TEXT,
  title TEXT NOT NULL,
  url TEXT,
  email TEXT,
  username TEXT,
  mobile_phone TEXT,
  note TEXT,
  is_favorite INTEGER NOT NULL DEFAULT 0,
  tags_json TEXT NOT NULL DEFAULT '[]',
  password_value TEXT,
  totp_uri TEXT,
  custom_fields_json TEXT NOT NULL DEFAULT '[]',
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,
  FOREIGN KEY (folder_id) REFERENCES folders(id)
);
```

#### 1.2 Bump schema version (dev build: drop & recreate DB is OK)

File:
`src-tauri/src/data/sqlite/migrations.rs`

Change:

```rust
pub const CURRENT_SCHEMA_VERSION: i64 = 5;
```

to:

```rust
pub const CURRENT_SCHEMA_VERSION: i64 = 6;
```

### 2) Backend Types (Rust)

File:
`src-tauri/src/types.rs`

#### 2.1 DataCard: add `totp_uri`

In `pub struct DataCard`, add:

```rust
pub totp_uri: Option<String>,
```

Place it near `password` (recommended right after `password`).

#### 2.2 Inputs: add `totp_uri`

In both structs add:

```rust
pub totp_uri: Option<String>,
```

* `pub struct CreateDataCardInput`
* `pub struct UpdateDataCardInput`

#### 2.3 DataCardSummary: add `has_totp` (boolean only, no secret)

In `pub struct DataCardSummary`, add:

```rust
pub has_totp: bool,
```

### 3) Backend Repo (SQLite queries)

File:
`src-tauri/src/data/sqlite/repo_impl.rs`

#### 3.1 Map full DataCard (`map_datacard`)

Find:

```rust
password: row.get("password_value")?,
custom_fields: deserialize_json(row.get::<_, String>("custom_fields_json")?)?,
```

Change to:

```rust
password: row.get("password_value")?,
totp_uri: row.get("totp_uri")?,
custom_fields: deserialize_json(row.get::<_, String>("custom_fields_json")?)?,
```

#### 3.2 Create DataCard: insert `totp_uri`

Find the INSERT SQL in `create_datacard()`:

```rust
"INSERT INTO datacards (id, folder_id, title, url, email, username, mobile_phone, note, is_favorite, tags_json, password_value, custom_fields_json, created_at, updated_at, deleted_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, 0, ?9, ?10, ?11, ?12, ?13, NULL)",
```

Replace with:

```rust
"INSERT INTO datacards (id, folder_id, title, url, email, username, mobile_phone, note, is_favorite, tags_json, password_value, totp_uri, custom_fields_json, created_at, updated_at, deleted_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, 0, ?9, ?10, ?11, ?12, ?13, ?14, NULL)",
```

Then update params list by inserting `input.totp_uri` between `input.password` and `custom_fields_json`:

**BEFORE params**

```rust
params![
  id,
  input.folder_id,
  input.title,
  input.url,
  input.email,
  input.username,
  input.mobile_phone,
  input.note,
  tags_json,
  input.password,
  custom_fields_json,
  now,
  now
],
```

**AFTER params**

```rust
params![
  id,
  input.folder_id,
  input.title,
  input.url,
  input.email,
  input.username,
  input.mobile_phone,
  input.note,
  tags_json,
  input.password,
  input.totp_uri,
  custom_fields_json,
  now,
  now
],
```

#### 3.3 Update DataCard: persist `totp_uri`

Find update SQL in `update_datacard()`:

```rust
"UPDATE datacards SET title = ?1, url = ?2, email = ?3, username = ?4, mobile_phone = ?5, note = ?6, tags_json = ?7, password_value = ?8, custom_fields_json = ?9, folder_id = ?10, updated_at = ?11 WHERE id = ?12",
```

Replace with:

```rust
"UPDATE datacards SET title = ?1, url = ?2, email = ?3, username = ?4, mobile_phone = ?5, note = ?6, tags_json = ?7, password_value = ?8, totp_uri = ?9, custom_fields_json = ?10, folder_id = ?11, updated_at = ?12 WHERE id = ?13",
```

Update params accordingly by inserting `input.totp_uri` after `input.password`:

**BEFORE params (fragment)**

```rust
params![
  input.title,
  input.url,
  input.email,
  input.username,
  input.mobile_phone,
  input.note,
  tags_json,
  input.password,
  custom_fields_json,
  input.folder_id,
  now,
  input.id
]
```

**AFTER params**

```rust
params![
  input.title,
  input.url,
  input.email,
  input.username,
  input.mobile_phone,
  input.note,
  tags_json,
  input.password,
  input.totp_uri,
  custom_fields_json,
  input.folder_id,
  now,
  input.id
]
```

#### 3.4 Summaries: expose only `has_totp`

Update `list_datacards_summary()` SELECT to include `totp_uri` (so we can compute bool).
Find:

```rust
"SELECT id, folder_id, title, url, email, username, tags_json, is_favorite, created_at, updated_at, deleted_at FROM datacards WHERE deleted_at IS NULL {clause}"
```

Replace with:

```rust
"SELECT id, folder_id, title, url, email, username, totp_uri, tags_json, is_favorite, created_at, updated_at, deleted_at FROM datacards WHERE deleted_at IS NULL {clause}"
```

Do the same for deleted summary query:

```rust
"SELECT id, folder_id, title, url, email, username, totp_uri, tags_json, is_favorite, created_at, updated_at, deleted_at FROM datacards WHERE deleted_at IS NOT NULL ORDER BY deleted_at DESC"
```

Now update `map_datacard_summary()`:
Add:

```rust
let has_totp = row.get::<_, Option<String>>("totp_uri")?.is_some();
```

And in returned struct add:

```rust
has_totp,
```

### 4) Backend Service Sanitization

File:
`src-tauri/src/services/datacards_service.rs`

In both `create_datacard()` and `update_datacard()` after tags normalization, add trimming for totp:

```rust
sanitized.totp_uri = sanitized
    .totp_uri
    .and_then(|v| {
        let t = v.trim().to_string();
        if t.is_empty() { None } else { Some(t) }
    });
```

### 5) Frontend Dependencies

File: `package.json`

Add dependencies:

```json
{
  "dependencies": {
    "otpauth": "^9.4.1",
    "@zxing/browser": "^0.1.5"
  }
}
```

(Use the newest compatible versions available in your environment; `otpauth` supports browsers and has `URI.parse()` and `totp.generate()` in README.)

Run:

```bash
npm i
```

### 6) Frontend Types + Mappers

#### 6.1 Backend types

File:
`src/features/Vault/types/backend.ts`

* In `export type BackendDataCard = { ... }` add:

```ts
totp_uri: string | null;
```

* In `export type BackendCreateDataCardInput = { ... }` add:

```ts
totp_uri: string | null;
```

* In `export type BackendUpdateDataCardInput = { ... }` add:

```ts
totp_uri: string | null;
```

* In `export type BackendDataCardSummary = { ... }` add:

```ts
has_totp: boolean;
```

#### 6.2 UI types

File:
`src/features/Vault/types/ui.ts`

* In `export type DataCard = { ... }` add:

```ts
totpUri: string | null;
```

* In `export type CreateDataCardInput = { ... }` add:

```ts
totpUri: string | null;
```

* In `export type UpdateDataCardInput = { ... }` add:

```ts
totpUri: string | null;
```

* In `export type DataCardSummary = { ... }` add:

```ts
hasTotp: boolean;
```

#### 6.3 Mappers

File:
`src/features/Vault/types/mappers.ts`

* In `mapCardFromBackend()` add:

```ts
totpUri: card.totp_uri,
```

* In `mapCreateCardToBackend()` add:

```ts
totp_uri: input.totpUri ?? null,
```

* In `mapCardSummaryFromBackend()` add:

```ts
hasTotp: card.has_totp,
```

* In `mapCardToSummary()` add:

```ts
hasTotp: (card.totpUri ?? null) !== null,
```

### 7) Frontend API payloads

File:
`src/features/Vault/api/vaultApi.ts`

No new commands needed: we reuse `update_datacard` with `totp_uri`.

Ensure create/update payload includes `totp_uri` via mapper changes above.

### 8) UI: Add 2FA Modal + QR/Text Import

#### 8.1 New util for TOTP

Create file:
`src/features/Vault/utils/totp.ts`

Content:

```ts
import * as OTPAuth from 'otpauth';

export type NormalizeTotpResult =
  | { ok: true; uri: string }
  | { ok: false; error: string };

const isLikelyOtpAuthUri = (value: string) => value.trim().toLowerCase().startsWith('otpauth://');

const normalizeBase32 = (value: string) => value.replace(/\s+/g, '').toUpperCase();

export function normalizeTotpInput(
  raw: string,
  defaults: { issuer: string; label: string }
): NormalizeTotpResult {
  const value = raw.trim();
  if (!value) return { ok: false, error: 'EMPTY' };

  if (isLikelyOtpAuthUri(value)) {
    try {
      const parsed = OTPAuth.URI.parse(value);
      if (!(parsed instanceof OTPAuth.TOTP)) return { ok: false, error: 'NOT_TOTP' };
      return { ok: true, uri: parsed.toString() };
    } catch {
      return { ok: false, error: 'INVALID_URI' };
    }
  }

  // Treat as Base32 secret
  try {
    const secret = OTPAuth.Secret.fromBase32(normalizeBase32(value));
    const totp = new OTPAuth.TOTP({
      issuer: defaults.issuer,
      label: defaults.label,
      algorithm: 'SHA1',
      digits: 6,
      period: 30,
      secret,
    });
    return { ok: true, uri: totp.toString() };
  } catch {
    return { ok: false, error: 'INVALID_SECRET' };
  }
}

export function generateTotpCode(uri: string, nowMs: number) {
  const parsed = OTPAuth.URI.parse(uri);
  if (!(parsed instanceof OTPAuth.TOTP)) {
    throw new Error('NOT_TOTP');
  }

  const token = parsed.generate({ timestamp: nowMs });
  const period = parsed.period ?? 30;
  const epoch = parsed.epoch ?? 0;

  const nowSec = Math.floor(nowMs / 1000);
  const remaining = period - ((nowSec - epoch) % period);

  return { token, period, remaining };
}
```

(Uses `URI.parse()`, `TOTP.generate()` from library README.)

#### 8.2 New modal component

Create file:
`src/features/Vault/components/modals/Add2FAModal.tsx`

Content:

```tsx
import React, { useMemo, useState } from 'react';
import { useTranslation } from '../../../../lib/i18n';
import { BrowserQRCodeReader } from '@zxing/browser';
import { normalizeTotpInput } from '../../utils/totp';

type Props = {
  isOpen: boolean;
  existingUri: string | null;
  defaults: { issuer: string; label: string };
  onCancel: () => void;
  onSave: (uri: string) => void;
  onRemove: () => void;
};

export const Add2FAModal: React.FC<Props> = ({ isOpen, existingUri, defaults, onCancel, onSave, onRemove }) => {
  const { t } = useTranslation('DataCards');
  const [tab, setTab] = useState<'text' | 'qr'>('text');
  const [textValue, setTextValue] = useState(existingUri ?? '');
  const [error, setError] = useState<string | null>(null);
  const [busy, setBusy] = useState(false);

  const canRemove = useMemo(() => (existingUri ?? '').trim().length > 0, [existingUri]);

  if (!isOpen) return null;

  const handleSaveText = () => {
    setError(null);
    const result = normalizeTotpInput(textValue, defaults);
    if (!result.ok) {
      setError(t(`twoFactor.error.${result.error}`));
      return;
    }
    onSave(result.uri);
  };

  const handleQrFile = async (file: File) => {
    setError(null);
    setBusy(true);
    try {
      const url = URL.createObjectURL(file);
      try {
        const reader = new BrowserQRCodeReader();
        const decoded = await reader.decodeFromImageUrl(url);
        const text = decoded.getText();
        const norm = normalizeTotpInput(text, defaults);
        if (!norm.ok) {
          setError(t(`twoFactor.error.${norm.error}`));
          return;
        }
        setTextValue(norm.uri);
        setTab('text');
      } finally {
        URL.revokeObjectURL(url);
      }
    } catch {
      setError(t('twoFactor.error.QR_DECODE_FAILED'));
    } finally {
      setBusy(false);
    }
  };

  return (
    <div className="dialog-backdrop dialog-backdrop--inner">
      <div className="dialog" role="dialog" aria-modal="true" aria-labelledby="add2fa-title">
        <div className="dialog-header">
          <h2 id="add2fa-title" className="dialog-title">{t('twoFactor.title')}</h2>
        </div>

        <div className="dialog-body">
          <div className="button-row" style={{ marginBottom: 12 }}>
            <button className={`btn ${tab === 'text' ? 'btn-primary' : 'btn-secondary'}`} type="button" onClick={() => setTab('text')}>
              {t('twoFactor.tab.text')}
            </button>
            <button className={`btn ${tab === 'qr' ? 'btn-primary' : 'btn-secondary'}`} type="button" onClick={() => setTab('qr')}>
              {t('twoFactor.tab.qr')}
            </button>
          </div>

          {tab === 'text' ? (
            <div className="form-field">
              <label className="form-label" htmlFor="totp-text">{t('twoFactor.text.label')}</label>
              <textarea
                id="totp-text"
                className="textarea"
                value={textValue}
                placeholder={t('twoFactor.text.placeholder')}
                onChange={(e) => { setTextValue(e.target.value); setError(null); }}
              />
              {error && <div className="form-error">{error}</div>}
              <div className="muted" style={{ fontSize: 12, marginTop: 6 }}>{t('twoFactor.text.hint')}</div>
            </div>
          ) : (
            <div className="form-field">
              <label className="form-label" htmlFor="totp-qr">{t('twoFactor.qr.label')}</label>
              <input
                id="totp-qr"
                className="input"
                type="file"
                accept="image/*"
                disabled={busy}
                onChange={(e) => {
                  const f = e.target.files?.[0];
                  if (f) void handleQrFile(f);
                }}
              />
              {error && <div className="form-error">{error}</div>}
              {busy && <div className="muted" style={{ fontSize: 12, marginTop: 6 }}>{t('twoFactor.qr.loading')}</div>}
            </div>
          )}
        </div>

        <div className="dialog-footer dialog-footer--split">
          <div className="dialog-footer-left">
            <button className="btn btn-secondary" type="button" onClick={onCancel}>{t('action.cancel')}</button>
            {canRemove && (
              <button className="btn btn-danger" type="button" onClick={onRemove}>{t('twoFactor.remove')}</button>
            )}
          </div>
          <div className="dialog-footer-right">
            <button className="btn btn-primary" type="button" onClick={handleSaveText}>
              {t('action.save')}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};
```

(Uses `@zxing/browser` decode from image URL.)

#### 8.3 Wire modal into Edit Data Card action menu

File:
`src/features/Vault/components/DataCards/DataCards.tsx`

1. Add import:

```ts
import { Add2FAModal } from '../modals/Add2FAModal';
```

2. Add state near other modal state:

```ts
const [is2faModalOpen, setIs2faModalOpen] = useState(false);
```

3. In action menu (the “...” block in `renderDialog`), add new buttons **before** custom fields actions:

Locate:

```tsx
<button className="dropdown-item" type="button" onClick={() => { ... openCustomFieldModal('datacard-edit-dialog'); }}>
```

Insert above it:

```tsx
<button
  className="dropdown-item"
  type="button"
  onClick={() => {
    setIsActionsOpen(false);
    setIs2faModalOpen(true);
  }}
>
  {editForm?.totpUri ? t('twoFactor.editAction') : t('twoFactor.addAction')}
</button>
```

4. Render the modal near other modal renders (bottom of component), add:

```tsx
<Add2FAModal
  isOpen={is2faModalOpen}
  existingUri={viewModel.editForm?.totpUri ?? null}
  defaults={{
    issuer: (viewModel.editForm?.title ?? 'Vault').trim() || 'Vault',
    label: (viewModel.editForm?.title ?? 'Account').trim() || 'Account',
  }}
  onCancel={() => setIs2faModalOpen(false)}
  onSave={(uri) => {
    viewModel.updateEditField('totpUri', uri);
    setIs2faModalOpen(false);
  }}
  onRemove={() => {
    viewModel.updateEditField('totpUri', '');
    setIs2faModalOpen(false);
  }}
/>
```

### 9) Extend DataCard form state to carry `totpUri`

File:
`src/features/Vault/components/DataCards/useDataCards.ts`

#### 9.1 Add field to `DataCardFormState`

```ts
totpUri: string;
```

#### 9.2 Include in initial form

In `buildInitialForm()` return object add:

```ts
totpUri: '',
```

#### 9.3 Populate edit form from card

In `openEditModal()` add:

```ts
totpUri: card.totpUri || '',
```

#### 9.4 Include in Create/Update payload builders

In `buildCreateInput()` add:

```ts
totpUri: normalizeOptional(form.totpUri),
```

Now `updateEditField('totpUri', ...)` will compile and `mapCreateCardToBackend()` will send `totp_uri`.

### 10) Details UI: show live TOTP code in dedicated field

#### 10.1 Create new component

Create file:
`src/features/Vault/components/Details/TotpField.tsx`

```tsx
import React, { useEffect, useMemo, useState } from 'react';
import { useTranslation } from '../../../../lib/i18n';
import { generateTotpCode } from '../../utils/totp';
import { copyTextToClipboard } from '../../../../lib/clipboard';

export const TotpField: React.FC<{ uri: string }> = ({ uri }) => {
  const { t } = useTranslation('Details');
  const [now, setNow] = useState(() => Date.now());
  const [copyOk, setCopyOk] = useState<null | boolean>(null);

  useEffect(() => {
    const id = window.setInterval(() => setNow(Date.now()), 1000);
    return () => window.clearInterval(id);
  }, []);

  const data = useMemo(() => {
    try {
      return generateTotpCode(uri, now);
    } catch {
      return null;
    }
  }, [uri, now]);

  if (!data) {
    return (
      <div className="detail-row">
        <div className="detail-label">{t('label.totp')}</div>
        <div className="detail-value">{t('totp.invalid')}</div>
      </div>
    );
  }

  return (
    <div className="detail-row">
      <div className="detail-label">{t('label.totp')}</div>
      <div className="detail-value">
        <div className="detail-value-box">
          <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
            <div style={{ fontSize: 20, fontWeight: 700, letterSpacing: 2 }}>{data.token}</div>
            <div className="muted" style={{ fontSize: 12 }}>
              {t('totp.expiresIn', { seconds: data.remaining })}
            </div>
            <button
              className="btn btn-secondary btn-icon"
              type="button"
              title={t('action.copy')}
              onClick={async () => {
                const ok = await copyTextToClipboard(data.token);
                setCopyOk(ok);
                window.setTimeout(() => setCopyOk(null), 1200);
              }}
            >
              {t('action.copy')}
            </button>
            {copyOk === true && <span className="muted">{t('toast.copySuccess')}</span>}
            {copyOk === false && <span className="muted">{t('toast.copyError')}</span>}
          </div>
        </div>
      </div>
    </div>
  );
};
```

#### 10.2 Render it in Details screen

File:
`src/features/Vault/components/Details/Details.tsx`

1. Add import:

```ts
import { TotpField } from './TotpField';
```

2. In the main details rendering (near password section), add:

```tsx
{card.totpUri && <TotpField uri={card.totpUri} />}
```

Recommended placement: directly **before** the password row, or directly **after** it (your choice; but keep it near password).

### 11) Card list indicator (optional but recommended)

Show a small pill “2FA” in card list if `card.hasTotp` is true.

File:
`src/features/Vault/components/DataCards/DataCards.tsx`

In list item header:

```tsx
<div className="datacard-top">
  <div className="datacard-title">{card.title}</div>
  {card.hasTotp && <span className="pill">{t('twoFactor.pill')}</span>}
  {isFavorite && <span className="pill datacard-favorite">{t('label.favorite')}</span>}
</div>
```

### 12) i18n strings

#### 12.1 DataCards

File: `src/i18n/English/DataCards.json`

Add:

```json
"twoFactor": {
  "pill": "2FA",
  "addAction": "Add 2FA",
  "editAction": "Edit 2FA",
  "remove": "Remove 2FA",
  "title": "Two-factor authentication (TOTP)",
  "tab": { "text": "Text", "qr": "QR" },
  "text": {
    "label": "Setup code / secret",
    "placeholder": "Paste otpauth://... OR paste Base32 secret",
    "hint": "You can paste a full otpauth:// URI or a Base32 secret. The app will store it securely and generate codes."
  },
  "qr": {
    "label": "Upload QR image",
    "loading": "Decoding QR..."
  },
  "error": {
    "EMPTY": "Enter a setup code or secret",
    "INVALID_URI": "Invalid otpauth URI",
    "NOT_TOTP": "Only TOTP is supported",
    "INVALID_SECRET": "Invalid Base32 secret",
    "QR_DECODE_FAILED": "Unable to decode QR from image"
  }
}
```

#### 12.2 Details

File: `src/i18n/English/Details.json`

Add:

```json
"label.totp": "2FA (TOTP)",
"totp.invalid": "Invalid 2FA configuration",
"totp.expiresIn": "expires in {{seconds}}s"
```

(Other languages can be added later if present.)

### 13) Acceptance Criteria

1. In Edit Data Card dialog, action menu contains “Add 2FA” when no TOTP exists and “Edit 2FA” when it exists.
2. Modal supports:

   * paste `otpauth://...` and Save
   * paste Base32 secret and Save (auto-converts to otpauth URI)
   * upload QR image → decoded → stored
3. After saving card, Details shows:

   * a dedicated “2FA (TOTP)” field
   * a 6-digit token changing automatically
   * countdown display
   * copy button copies token only
4. No custom fields are created for TOTP.
5. Summary list shows “2FA” pill if enabled (optional if implemented).

### 14) Manual Test Checklist

* Create new card → edit → Add 2FA via Base32 secret → save → verify Details token changes
* Add 2FA via QR image with `otpauth://` content → save → verify same
* Edit 2FA (replace secret) → verify token changes accordingly
* Remove 2FA → save → Details no longer shows 2FA block
* Lock/unlock vault → ensure 2FA persists (stored in encrypted DB)

