

## Technical Specification (EN): Add “Custom Fields” via Action Bar in “Create data card”

### Goal

In “Create data card” dialog, add an **Action Bar (⋯)** (same size/visual style as Workspace Action Bar). Action Bar menu contains a single action: **Add field** (`customFields.add`). Clicking it opens a **Custom Field Setup modal** (name input + Cancel/OK). On OK, a new custom field appears **after Mobile phone** in the Create form, with an input for its value. Custom fields must be persisted to backend as `custom_fields`.

### Non-goals

* No DB migrations.
* No “types” selection UI for custom fields (type stays `"text"` for now).
* No advanced actions in Action Bar (menu is placeholder except “Add field”).

---

## Current state (must be fixed)

1. Backend mapping currently sends `custom_fields: []` always:
   **File:** `src/features/Vault/types/mappers.ts`
   **Function:** `mapCreateCardToBackend(...)` currently contains `custom_fields: [],` and must be replaced with real mapping.

2. Create form state (`DataCardFormState`) does not include custom fields:
   **File:** `src/features/Vault/components/DataCards/useDataCards.ts`

3. Create dialog header in DataCards has only title; needs action bar:
   **File:** `src/features/Vault/components/DataCards/DataCards.tsx`
   Current header block:

```tsx
<div className="dialog-header">
  <h2 id={titleElementId} className="dialog-title">{title}</h2>
</div>
```

---

## UX / Flow

### Create data card dialog

* Top-right: **Action Bar button (⋯)**.
* Clicking it opens a small menu (popover) with **one item**:

  * `customFields.add` → “Add field”
* Clicking “Add field”:

  * closes action menu
  * opens **Custom Field Setup modal**

### Custom Field Setup modal

* Title: `customFields.modalTitle` → “Add custom field”
* One input: `customFields.nameLabel` → “Field name”
* Buttons: `action.cancel` (“Cancel”), `action.ok` (“OK”)
* Validation:

  * name is required (trimmed, must not be empty)
  * name must be unique among existing custom fields (case-insensitive after trim)

### Where fields appear

* After OK, the new field renders **after “Mobile phone”** and **before “Note”** inside the Create form.
* Each custom field renders:

  * label = user-defined field name
  * input for value (text)

---

## Data model changes (Frontend types)

### 1) Extend `CreateDataCardInput` to include custom fields

**File:** `src/features/Vault/types/ui.ts`

Add to `CreateDataCardInput`:

```ts
  customFields?: CustomField[];
```

Result:

```ts
export type CreateDataCardInput = {
  folderId: string | null;
  title: string;
  url?: string | null;
  email?: string | null;
  username?: string | null;
  mobilePhone?: string | null;
  note?: string | null;
  tags?: string[];
  password?: string | null;

  // NEW
  customFields?: CustomField[];
};
```

---

## Backend mapping changes (Frontend → Backend)

### 2) Map `customFields` → `custom_fields`

**File:** `src/features/Vault/types/mappers.ts`

In `mapCreateCardToBackend(input: CreateDataCardInput)` replace:

```ts
custom_fields: [],
```

with:

```ts
custom_fields: (input.customFields ?? []).map((f) => ({
  key: f.key,
  value: f.value,
  type: f.type,
})),
```

(Backend expects this structure; don’t invent a new one.)

---

## Form state & ViewModel changes

### 3) Add custom fields to `DataCardFormState`

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

Add a UI-only row type with stable ID:

```ts
import { CustomFieldType, CustomField } from '../../types/ui';

type CustomFieldFormRow = {
  id: string;         // UI-only stable id
  key: string;        // field name
  value: string;      // field value
  type: CustomFieldType; // always "text" for now
};
```

Extend `DataCardFormState`:

```ts
export type DataCardFormState = {
  title: string;
  folderId: string | null;
  folderName: string;
  url: string;
  email: string;
  username: string;
  password: string;
  mobilePhone: string;
  note: string;
  tagsText: string;

  // NEW
  customFields: CustomFieldFormRow[];
};
```

Update `buildInitialForm(...)` to initialize:

```ts
customFields: [],
```

### 4) Ensure Edit modal preserves existing custom fields

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

Add ID helper:

```ts
const makeRowId = () =>
  globalThis.crypto?.randomUUID?.() ?? `cf_${Date.now()}_${Math.random().toString(16).slice(2)}`;
```

When building Edit form from a card (where you already map backend → UI `card.customFields`), set:

```ts
customFields: (card.customFields ?? []).map((f) => ({
  id: makeRowId(),
  key: f.key,
  value: f.value,
  type: f.type,
})),
```

### 5) Add ViewModel methods to add and edit custom field values

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

Add methods to ViewModel interface (whatever object you return as `viewModel`):

```ts
addCreateCustomFieldByName: (name: string) => { ok: true } | { ok: false; reason: 'EMPTY' | 'DUPLICATE' };
updateCreateCustomFieldValue: (rowId: string, value: string) => void;

addEditCustomFieldByName: (name: string) => { ok: true } | { ok: false; reason: 'EMPTY' | 'DUPLICATE' };
updateEditCustomFieldValue: (rowId: string, value: string) => void;
```

Implementation details:

* `name` must be `trim()`ed
* uniqueness check: compare `(existing.key.trim().toLowerCase())`

Create add example:

```ts
const addCreateCustomFieldByName = useCallback((name: string) => {
  const trimmed = name.trim();
  if (!trimmed) return { ok: false as const, reason: 'EMPTY' as const };

  const exists = createForm.customFields.some(
    (r) => r.key.trim().toLowerCase() === trimmed.toLowerCase()
  );
  if (exists) return { ok: false as const, reason: 'DUPLICATE' as const };

  setCreateForm((prev) => ({
    ...prev,
    customFields: [...prev.customFields, { id: makeRowId(), key: trimmed, value: '', type: 'text' }],
  }));

  return { ok: true as const };
}, [createForm.customFields]);
```

Update value example:

```ts
const updateCreateCustomFieldValue = useCallback((rowId: string, value: string) => {
  setCreateForm((prev) => ({
    ...prev,
    customFields: prev.customFields.map((r) => (r.id === rowId ? { ...r, value } : r)),
  }));
}, []);
```

Mirror the same logic for Edit (`setEditForm(...)` with null guard).

### 6) Include custom fields in submit payloads

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

Update `buildCreateInput(form)` to include:

```ts
customFields: form.customFields.map((r) => ({
  key: r.key,
  value: r.value,
  type: r.type,
})),
```

Update `buildUpdateInput(...)` inherits it via `buildCreateInput(...)`.

---

## UI changes (Create data card dialog)

### 7) Add Action Bar (⋯) to the dialog header

**File:** `src/features/Vault/components/DataCards/DataCards.tsx`

In `renderDialog(...)`, replace current header:

```tsx
<div className="dialog-header">
  <h2 id={titleElementId} className="dialog-title">{title}</h2>
</div>
```

with a header that includes action bar + menu.

Required new local state in `DataCards.tsx` (top-level component):

```ts
const [isActionMenuOpen, setIsActionMenuOpen] = useState(false);
const [isCustomFieldModalOpen, setIsCustomFieldModalOpen] = useState(false);
const [customFieldName, setCustomFieldName] = useState('');
const [customFieldModalError, setCustomFieldModalError] = useState<string | null>(null);
const [customFieldTargetDialogId, setCustomFieldTargetDialogId] = useState<string | null>(null);
```

In `renderDialog(...)`, add:

```tsx
<div className="dialog-header dialog-header--with-actions">
  <h2 id={titleElementId} className="dialog-title">{title}</h2>

  <div className="dialog-header-actions">
    <button
      type="button"
      className="btn btn-icon dialog-actionbar"
      aria-label={t('action.more')}
      title={t('action.more')}
      onClick={() => setIsActionMenuOpen((v) => !v)}
    >
      <span className="dialog-actionbar-dots">⋯</span>
    </button>

    {isActionMenuOpen && (
      <div className="dialog-actionmenu" role="menu">
        <button
          type="button"
          className="dialog-actionmenu-item"
          onClick={() => {
            setIsActionMenuOpen(false);
            setCustomFieldTargetDialogId(dialogId); // remember which dialog opened it
            setCustomFieldName('');
            setCustomFieldModalError(null);
            setIsCustomFieldModalOpen(true);
          }}
        >
          {t('customFields.add')}
        </button>
      </div>
    )}
  </div>
</div>
```

Notes:

* Action menu must close on outside click + Escape (implement with `useEffect` document listeners).
* This is a “Workspace-like” action bar: minimal dots button, no box.

### 8) Render custom fields after Mobile phone

**File:** `src/features/Vault/components/DataCards/DataCards.tsx`

Insert **immediately after** the Mobile phone block and **before** Note block.

You currently have:

```tsx
<div className="form-field"> ... mobilePhone ... </div>

<div className="form-field"> ... note ... </div>
```

Between them insert:

```tsx
{form.customFields.map((row) => (
  <div className="form-field" key={row.id}>
    <label className="form-label" htmlFor={`${dialogId}-cf-${row.id}`}>
      {row.key}
    </label>
    <input
      id={`${dialogId}-cf-${row.id}`}
      className="input"
      value={row.value}
      onChange={(e) => {
        if (dialogId === 'datacard-create-dialog') {
          viewModel.updateCreateCustomFieldValue(row.id, e.target.value);
        } else {
          viewModel.updateEditCustomFieldValue(row.id, e.target.value);
        }
      }}
    />
  </div>
))}
```

---

## New modal component: Custom Field Setup

### 9) Add `CustomFieldModal` component

**File:** `src/features/Vault/components/modals/CustomFieldModal.tsx`

Responsibilities:

* render standard `.dialog-backdrop` + `.dialog`
* input for field name
* Cancel/OK buttons
* show validation error text

Props:

```ts
type CustomFieldModalProps = {
  isOpen: boolean;
  name: string;
  error: string | null;
  onChangeName: (value: string) => void;
  onCancel: () => void;
  onOk: () => void;
};
```

Add it to `DataCards.tsx` (below main dialogs render), with `dialog-backdrop--inner` class to sit above existing dialog.

On OK handler in `DataCards.tsx`:

* call `viewModel.addCreateCustomFieldByName(customFieldName)` if `customFieldTargetDialogId === 'datacard-create-dialog'`
* else call `viewModel.addEditCustomFieldByName(...)`
* if result is error:

  * EMPTY → show `t('customFields.errorEmpty')`
  * DUPLICATE → show `t('customFields.errorDuplicate')`
* if ok:

  * close modal

---

## CSS changes

### 10) Dialog header action bar + menu styles

**File:** `src/styles/ui.css`

Add:

```css
.dialog-header--with-actions {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.dialog-header-actions {
  position: relative;
  display: flex;
  align-items: center;
}

.dialog-actionbar {
  background: transparent !important;
  border: 0 !important;
  padding: 0 6px !important;
  height: 24px;
  border-radius: 10px;
}

.dialog-actionbar:hover {
  background: rgba(255, 255, 255, 0.06) !important;
}

.dialog-actionbar-dots {
  font-size: 20px;
  line-height: 1;
  color: rgba(255, 255, 255, 0.88);
  transform: translateY(-1px);
}

.dialog-actionmenu {
  position: absolute;
  top: 28px;
  right: 0;
  min-width: 160px;
  padding: 6px;
  border-radius: 12px;
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  box-shadow: var(--shadow-popover);
  z-index: 2;
}

.dialog-actionmenu-item {
  width: 100%;
  text-align: left;
  border: 0;
  border-radius: 10px;
  padding: 10px 10px;
  background: transparent;
  color: var(--color-text);
  cursor: pointer;
}

.dialog-actionmenu-item:hover {
  background: var(--color-surface-2);
}
```

### 11) Inner modal z-index

**File:** `src/styles/ui.css`

Add:

```css
.dialog-backdrop--inner {
  z-index: 40;
}
```

Optional: set `.customfield-dialog` width:

```css
.customfield-dialog {
  width: min(420px, calc(100vw - 40px));
}
```

---

## i18n changes

### 12) Add translation keys

**File:** `src/i18n/English/DataCards.json`

Add:

```json
"customFields.add": "Add field",
"customFields.modalTitle": "Add custom field",
"customFields.nameLabel": "Field name",
"customFields.namePlaceholder": "e.g. API key",
"customFields.errorEmpty": "Field name is required",
"customFields.errorDuplicate": "Field with this name already exists",
"action.more": "More",
"action.ok": "OK"
```

---

## Acceptance criteria

1. Create data card dialog shows ⋯ action bar in header (same sizing/feel as Workspace).
2. Clicking ⋯ opens menu with exactly one item: “Add field”.
3. Clicking “Add field” opens modal (Name + Cancel/OK).
4. OK validates name (required + unique), then inserts a new field.
5. Custom fields render after Mobile phone and before Note.
6. Submitting Create sends `custom_fields` to backend (not empty when fields exist).
7. Edit dialog preserves existing custom fields (must not wipe on Save).

---

## Notes (implementation references)

* Your folder picker uses `open({ directory: true, multiple: false })` pattern from Tauri dialog plugin docs. ([Tauri][1])
* CSS variables / fallbacks work via `var(--x, fallback)` and follow cascade rules (useful when you later theme custom field modal). ([MDN Web Docs][2])


