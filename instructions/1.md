

# PERF-STABILITY-01 — Fix lag, freezes, and slow UI response (Vault) end-to-end

## Goal

Eliminate lag/freezes and make Vault interactions feel immediate and stable by fixing:

1. Dev-only double effects (StrictMode)
2. Backend DB overhead (SQLite connection open-per-call, heavy list query)
3. Frontend over-refresh (full reload after every mutation)
4. Frontend expensive renders (date formatting in render loop)
5. Search without debounce (filtering runs on every keystroke)
6. Over-fetching (list command returns full card payload including heavy JSON fields)

## Scope

* Frontend: Vault screen and related hooks/components
* Backend: Rust SQLite repository + Tauri commands used by Vault

## Non-goals

* New UI features (sorting UI, new screens, migration features)
* Bank card editor / custom fields editor UI (not part of this perf task)

---

## Part A — DEV: prevent double requests caused by React StrictMode

### A1) Fix dev double-mount in StrictMode

**Problem:** In React dev, `<React.StrictMode>` intentionally double-invokes effects, causing double DB calls and apparent lag.

#### Option 1 (preferred for correctness): Guard initialization in Vault

**File:** `src/features/Vault/useVault.ts`

Add:

```ts
const initOnceRef = useRef(false);
```

Wrap the initial load effect:

```ts
useEffect(() => {
  if (initOnceRef.current) return;
  initOnceRef.current = true;

  // existing init logic:
  // - get settings
  // - refresh active data
}, [/* keep existing deps as appropriate */]);
```

#### Option 2 (allowed fallback): Disable StrictMode in dev

**File:** `src/main.tsx`
Remove:

```tsx
<React.StrictMode>...</React.StrictMode>
```

**Acceptance criteria (A):**

* In dev, app startup triggers `refreshActive()` only once.
* Tauri DB commands are not called twice on first mount (verified via logs).

---

## Part B — Backend: SQLite connection reuse + WAL pragmas + non-blocking commands

### B1) Add a SQLite connection pool

**Problem:** backend opens a new SQLite connection for each command call, causing I/O stalls.

#### Add dependencies

**File:** `src-tauri/Cargo.toml`
Add:

* `r2d2 = "0.8"`
* `r2d2_sqlite = "0.25"` (or compatible with your rusqlite version)

#### Add pool module

**New file:** `src-tauri/src/data/sqlite/pool.rs`

Implement:

* A global registry keyed by `profile_id` that stores a pool per profile DB path.
* Pool size: 4–8 connections.

Each new connection must run pragmas:

* `PRAGMA foreign_keys = ON;`
* `PRAGMA journal_mode = WAL;`
* `PRAGMA synchronous = NORMAL;`

Provide functions:

```rs
pub fn get_conn(profile_id: &str) -> Result<r2d2::PooledConnection<r2d2_sqlite::SqliteConnectionManager>>;
pub fn clear_pool(profile_id: &str); // optional, for logout/lock/cleanup
```

### B2) Replace open_connection() in repo_impl

**File:** `src-tauri/src/data/sqlite/repo_impl.rs`

Replace the current open-per-call:

* `fn open_connection(profile_id: &str) -> Result<Connection>`

With a pooled connection:

* `fn open_connection(profile_id: &str) -> Result<PooledConnection>`

Then update all repo functions to use the pooled connection (the rest of logic stays the same).

### B3) Run DB work off the command thread

**Problem:** long DB work blocks Tauri command thread → UI “hangs”.

Convert heavy commands to `async` and wrap DB work in `spawn_blocking`.

**Target files (minimum):**

* `src-tauri/src/commands/datacards.rs`
* `src-tauri/src/commands/folders.rs`
* `src-tauri/src/commands/settings.rs` (if it hits DB)

Pattern:

```rs
#[tauri::command]
pub async fn list_datacards_summary_command(...) -> Result<...> {
  tauri::async_runtime::spawn_blocking(move || {
     // call service/repo
  }).await.map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
}
```

**Acceptance criteria (B):**

* Backend no longer opens a fresh SQLite connection per call.
* DB operations do not block the UI thread (no visible freeze during list load/mutations).

---

## Part C — Backend/API: Split DataCards listing into Summary vs Details

### C1) Add DataCardSummary type

**File:** `src-tauri/src/types.rs`

Add:

```rs
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DataCardSummary {
  pub id: String,
  pub folder_id: Option<String>,
  pub title: String,
  pub url: Option<String>,
  pub email: Option<String>,
  pub username: Option<String>,
  pub tags: Vec<String>,
  pub created_at: String,
  pub updated_at: String,
  pub deleted_at: Option<String>,
  pub is_favorite: bool
}
```

(If favorite is stored in DB; if not, omit and keep current model behavior.)

### C2) Add repo method for summary listing

**File:** `src-tauri/src/data/sqlite/repo_impl.rs`

Add:

```rs
pub fn list_datacards_summary(profile_id: &str, sort_field: &str, sort_dir: &str) -> Result<Vec<DataCardSummary>>;
pub fn list_deleted_datacards_summary(profile_id: &str) -> Result<Vec<DataCardSummary>>;
```

SQL must avoid `SELECT *` and must NOT fetch heavy columns:

* Do NOT fetch `password_value`
* Do NOT fetch `note` (optional; allowed to exclude for list)
* Do NOT fetch `custom_fields_json`
* Do NOT fetch `bank_card_json`

Example (adjust to schema):

```sql
SELECT id, folder_id, title, url, email, username, tags_json, created_at, updated_at, deleted_at, is_favorite
FROM datacards
WHERE deleted_at IS NULL
ORDER BY ...
```

### C3) Service + Commands

**Files:**

* `src-tauri/src/services/datacards_service.rs`
* `src-tauri/src/commands/datacards.rs`

Add command:

* `list_datacards_summary_command`
* `list_deleted_datacards_summary_command`

Keep existing `get_datacard` as the full-detail fetch.

**Acceptance criteria (C):**

* List endpoints return small payloads (summary only).
* Details endpoint is used for full card data.

---

## Part D — Frontend: stop full refresh after every mutation (use local state updates)

### D1) Replace “refreshActive() after everything” with local mutations

**File:** `src/features/Vault/useVault.ts`

For these actions, DO NOT call `refreshActive()` after successful mutation:

#### Create folder

* Call backend create_folder.
* Append returned folder to `folders` state.
* Set selected nav to the new folder.

#### Create data card

* Call backend create_datacard.
* Insert returned card into `cards` state.
* Select it immediately.
* If current nav is `deleted`, auto-switch nav to `all` (or to the card’s folder if chosen).

#### Update card

* Call backend update_datacard.
* Update only that card in `cards` state (match by id).
* Keep selection stable.

#### Delete card

* If soft delete:

  * remove from `cards`
  * add to `deletedCardsSummary` (if deleted list is loaded)
* If purge:

  * remove from `cards` and do not re-fetch all lists.

#### Restore/Purge in Deleted mode

* Restore:

  * remove from `deletedCards`
  * add to `cards`
* Purge:

  * remove from `deletedCards`

**Allowed fallback refresh:** A “manual refresh” button or refresh after major state transitions (login/unlock/profile change). Otherwise no full reload.

### D2) Deleted mode load only once

**File:** `src/features/Vault/useVault.ts`

Add:

```ts
const [trashLoaded, setTrashLoaded] = useState(false);
```

When switching to Deleted:

* If `trashLoaded` false → load deleted summaries once → set true.
* Only reload trash after restore/purge operations (or manual refresh).

**Acceptance criteria (D):**

* Clicking Create/Edit/Delete no longer causes a full list reload.
* UI responds immediately; backend operations update only affected items.

---

## Part E — Frontend: debounce search + reduce render cost

### E1) Debounced search input

**Files:**

* `src/features/Vault/components/Search/Search.tsx`
* (New) `src/features/Vault/components/Search/useDebouncedValue.ts` (or similar)

Implement:

* Draft value updates instantly.
* Actual query updates after 150–250ms delay.

Use the debounced value for filtering.

### E2) Avoid date formatting inside render loops

**File:** `src/features/Vault/components/DataCards/DataCards.tsx`

Remove any `new Date(...).toLocaleString()` inside `.map(...)`.

Instead:

* Precompute `updatedAtLabel` and `createdAtLabel` in mapping layer:

  * either in `mapCardSummaryFromBackend()`
  * or in `useVault` when receiving backend data.

Use one `Intl.DateTimeFormat` instance:

```ts
const dtf = useMemo(() => new Intl.DateTimeFormat(undefined, { dateStyle: 'short', timeStyle: 'short' }), []);
```

And compute labels once per item, not per render.

### E3) Optional: Memoize list item component

If card list is large, add:

* `const DataCardRow = React.memo(...)`
* key props: `id`, `title`, `isSelected`, `updatedAtLabel`, `metaLine`

**Acceptance criteria (E):**

* Typing in search does not freeze.
* Selecting cards remains smooth with 500+ cards.
* Re-render cost does not scale linearly with formatting work each render.

---

## Part F — Frontend: use Summary list + lazy-load Details

### F1) Switch Vault list to summary commands

**Files:**

* `src/features/Vault/useVault.ts`
* `src/lib/tauri.ts` (or wherever invoke wrappers live)

Replace list calls:

* `list_datacards` → `list_datacards_summary`
* `list_deleted_datacards` → `list_deleted_datacards_summary`

Keep details fetch:

* On selecting a card: call `get_datacard(id)` and hydrate Details panel.

### F2) Cache details to avoid re-fetch on reselect

In `useVault.ts` maintain:

```ts
const [cardDetailsById, setCardDetailsById] = useState<Record<string, DataCard>>({});
```

When selecting a card:

* if details in cache → use immediately
* else fetch and store

**Acceptance criteria (F):**

* List loads quickly even with many cards.
* Details loads on demand and is cached.

---

## Verification checklist (must do)

1. **Dev mode**: no double initial load (StrictMode guard or removed).
2. Backend uses a pool; no repeated DB opens.
3. No “refreshActive after every mutation”.
4. Search is debounced.
5. No date formatting inside list render loops.
6. Listing uses summary payload; details are loaded lazily.

---

## Definition of Done (performance)

* With 1000 cards in DB:

  * Switching folders and selecting cards is instant (no freeze).
  * Creating/editing/deleting feels immediate.
  * Search typing is responsive (no input lag).
* No more UI “hangs” while DB work runs.

---

