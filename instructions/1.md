
File: src-tauri/src/services/backup_service.rs

Purpose:

Fix restore rollback so it never deletes original attachments and can restore attachments backup even if a restored attachments dir already exists.

Enforce kdf_salt.bin + key_check.bin presence for protected backups (create + restore).

Avoid creating a profile in workflow restore if backup is invalid for protected mode.


--- src-tauri/src/services/backup_service.rs
+++ src-tauri/src/services/backup_service.rs
@@
 fn build_backup_source(
     state: &Arc<AppState>,
     sp: &StoragePaths,
     profile_id: &str,
 ) -> Result<(BackupSource, String, String)> {
     let profile = registry::get_profile(sp, profile_id)?
         .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
     let profile_name = profile.name.clone();
     let vault_mode = if profile.has_password {
         security_service::persist_active_vault(state)?;
         "protected".to_string()
     } else {
         "passwordless".to_string()
     };
 
     let profile_root = profile_dir(sp, profile_id)?;
     let attachments_path = profile_root.join("attachments");
     let config_path = profile_config_path(sp, profile_id).ok();
     let settings_path = user_settings_path(sp, profile_id).ok();
-    let salt_path = kdf_salt_path(sp, profile_id).ok();
-    let key_check = key_check_path(sp, profile_id).ok();
+    let (salt_path, key_check) = if profile.has_password {
+        // Protected profiles MUST have salt + key_check to be restorable.
+        let salt = kdf_salt_path(sp, profile_id)?;
+        if !salt.exists() {
+            return Err(ErrorCodeString::new("KDF_SALT_MISSING"));
+        }
+        let kc = key_check_path(sp, profile_id)?;
+        if !kc.exists() {
+            return Err(ErrorCodeString::new("KEY_CHECK_MISSING"));
+        }
+        (Some(salt), Some(kc))
+    } else {
+        // Passwordless: include these only if they exist (best effort).
+        (
+            kdf_salt_path(sp, profile_id).ok().filter(|p| p.exists()),
+            key_check_path(sp, profile_id).ok().filter(|p| p.exists()),
+        )
+    };
@@
-fn create_archive(
+fn create_archive(
     destination: &Path,
-    source: BackupSource,
+    mut source: BackupSource,
     profile_id: &str,
     profile_name: &str,
     vault_mode: &str,
     created_at_utc: &str,
 ) -> Result<i64> {
@@
     add_optional_file(&mut writer, source.config_path, "config.json", &mut manifest_entries)?;
     add_optional_file(
         &mut writer,
         source.settings_path,
         "user_settings.json",
         &mut manifest_entries,
     )?;
-    add_optional_file(&mut writer, source.kdf_salt_path, "kdf_salt.bin", &mut manifest_entries)?;
-    add_optional_file(&mut writer, source.key_check_path, "key_check.bin", &mut manifest_entries)?;
+    if vault_mode == "protected" {
+        let salt_path = source
+            .kdf_salt_path
+            .as_ref()
+            .ok_or_else(|| ErrorCodeString::new("KDF_SALT_MISSING"))?;
+        if !salt_path.exists() {
+            return Err(ErrorCodeString::new("KDF_SALT_MISSING"));
+        }
+        add_file_to_zip(&mut writer, salt_path, "kdf_salt.bin", &mut manifest_entries)?;
+
+        let key_check_path = source
+            .key_check_path
+            .as_ref()
+            .ok_or_else(|| ErrorCodeString::new("KEY_CHECK_MISSING"))?;
+        if !key_check_path.exists() {
+            return Err(ErrorCodeString::new("KEY_CHECK_MISSING"));
+        }
+        add_file_to_zip(&mut writer, key_check_path, "key_check.bin", &mut manifest_entries)?;
+    } else {
+        add_optional_file(
+            &mut writer,
+            source.kdf_salt_path.take(),
+            "kdf_salt.bin",
+            &mut manifest_entries,
+        )?;
+        add_optional_file(
+            &mut writer,
+            source.key_check_path.take(),
+            "key_check.bin",
+            &mut manifest_entries,
+        )?;
+    }
@@
 fn restore_archive_to_profile(
     _state: &Arc<AppState>,
     sp: &StoragePaths,
     target_profile_id: &str,
     backup_path: &Path,
 ) -> Result<bool> {
@@
     let manifest: BackupManifest =
         serde_json::from_str(&manifest_contents).map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_INVALID"))?;
 
     if manifest.format_version != 1 {
         return Err(ErrorCodeString::new("BACKUP_UNSUPPORTED_FORMAT"));
     }
 
     if manifest.profile_id != target_profile_id {
         return Err(ErrorCodeString::new("BACKUP_PROFILE_MISMATCH"));
     }
 
     use std::collections::HashSet;
     let mut seen = HashSet::new();
     let mut has_vault = false;
+    let mut has_kdf_salt = false;
+    let mut has_key_check = false;
 
     for f in &manifest.files {
         if !seen.insert(&f.path) {
             return Err(ErrorCodeString::new("BACKUP_MANIFEST_INVALID"));
         }
         if f.path == "vault.db" {
             has_vault = true;
         }
+        if f.path == "kdf_salt.bin" {
+            has_kdf_salt = true;
+        }
+        if f.path == "key_check.bin" {
+            has_key_check = true;
+        }
     }
     if !has_vault {
         return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
     }
+    if manifest.vault_mode == "protected" {
+        // Protected backups MUST include salt + key_check.
+        if !has_kdf_salt || !has_key_check {
+            return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+        }
+    } else if manifest.vault_mode != "passwordless" {
+        return Err(ErrorCodeString::new("BACKUP_MANIFEST_INVALID"));
+    }
@@
     let attachments_path = profile_root.join("attachments");
     let extracted_attachments = temp_dir.path().join("attachments");
+    let attachments_existed_before = attachments_path.exists();
 
     let vault_backup_path = vault_path.with_extension(format!("old.{}", Uuid::new_v4()));
     let attachments_backup_path = profile_root.join(format!("attachments.old.{}", Uuid::new_v4()));
     let mut moved_vault = false;
     let mut moved_attachments = false;
+    let mut restored_attachments_created = false;
     let restore_result: Result<()> = (|| {
@@
         if attachments_path.exists() {
             rename_with_retry(&attachments_path, &attachments_backup_path)
                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
             moved_attachments = true;
         }
 
         if extracted_attachments.exists() {
             rename_with_retry(&extracted_attachments, &attachments_path)
                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+            restored_attachments_created = true;
         } else {
-            fs::create_dir_all(&attachments_path)
-                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+            // Create attachments dir only if missing (do not touch pre-existing data).
+            if !attachments_path.exists() {
+                fs::create_dir_all(&attachments_path)
+                    .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+                restored_attachments_created = true;
+            }
         }
@@
     if restore_result.is_err() {
         if vault_path.exists() {
             let _ = fs::remove_file(&vault_path);
         }
         if moved_vault && vault_backup_path.exists() {
             let _ = fs::rename(&vault_backup_path, &vault_path);
         }
-        if attachments_path.exists() && !moved_attachments {
-            let _ = fs::remove_dir_all(&attachments_path);
-        }
         if moved_attachments && attachments_backup_path.exists() {
+            // If restore created a new attachments dir, remove it before putting the backup back.
+            if attachments_path.exists() {
+                let _ = fs::remove_dir_all(&attachments_path);
+            }
             let _ = fs::rename(&attachments_backup_path, &attachments_path);
+        } else {
+            // Only remove attachments if they did NOT exist before and we created them during restore.
+            if !attachments_existed_before && restored_attachments_created && attachments_path.exists() {
+                let _ = fs::remove_dir_all(&attachments_path);
+            }
         }
         return Err(ErrorCodeString::new("BACKUP_RESTORE_FAILED"));
     }
@@
 pub fn backup_restore_workflow(state: &Arc<AppState>, backup_path: String) -> Result<bool> {
     let _guard = ensure_backup_guard(state)?;
     security_service::drop_active_session_without_persist(state)?;
     let sp = state.get_storage_paths()?;
 
     let backup_path = PathBuf::from(&backup_path);
     let (manifest, profile_name) = read_backup_manifest_and_name(&backup_path)?;
+
+    // Avoid creating a profile if a protected backup is missing required metadata.
+    if manifest.vault_mode == "protected" {
+        let mut has_kdf_salt = false;
+        let mut has_key_check = false;
+        for f in &manifest.files {
+            if f.path == "kdf_salt.bin" {
+                has_kdf_salt = true;
+            }
+            if f.path == "key_check.bin" {
+                has_key_check = true;
+            }
+        }
+        if !has_kdf_salt || !has_key_check {
+            return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+        }
+    }
 
     // Ensure profile exists; if not, create it with the SAME id from backup.
     let exists = registry::get_profile(&sp, &manifest.profile_id)?.is_some();
     if !exists {
         let has_password = manifest.vault_mode == "protected";
         registry::upsert_profile_with_id(&sp, &manifest.profile_id, &profile_name, has_password)?;
     }
 
     restore_archive_to_profile(state, &sp, &manifest.profile_id, &backup_path)
 }
