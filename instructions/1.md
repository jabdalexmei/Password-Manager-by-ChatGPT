
# TS (EN): Diff-like plan — consolidate vault state into `vault_session` and remove `logged_in_profile/vault_keeper_conn/vault_key`

## ✅ Target outcome

* `AppState` has **one** mutex field: `vault_session: Mutex<Option<VaultSession>>`.
* No `logged_in_profile`, no `vault_keeper_conn`, no `vault_key`.
* All “is unlocked?” checks:

  * **passwordless profile** → unlocked when `active_profile` is set
  * **protected profile** → unlocked only when `vault_session.is_some()` and matches `active_profile`

---

## 1) `src-tauri/src/app_state.rs`

### 1.1 Replace fields

**Find:**

```rust
pub struct AppState {
    pub active_profile: Mutex<Option<String>>,
    pub logged_in_profile: Mutex<Option<String>>,
    pub storage_paths: Mutex<StoragePaths>,

    pub vault_keeper_conn: Mutex<Option<rusqlite::Connection>>,
    pub vault_key: Mutex<Option<Zeroizing<[u8; 32]>>>,
    pub vault_persist_guard: Mutex<()>,
    pub backup_guard: Mutex<()>,
}
```

**Replace with:**

```rust
pub struct VaultSession {
    pub profile_id: String,
    pub conn: rusqlite::Connection,
    pub key: Zeroizing<[u8; 32]>,
}

pub struct AppState {
    pub active_profile: Mutex<Option<String>>,
    pub storage_paths: Mutex<StoragePaths>,

    pub vault_session: Mutex<Option<VaultSession>>,
    pub vault_persist_guard: Mutex<()>,
    pub backup_guard: Mutex<()>,
}
```

### 1.2 Update constructor

**Find in `new(...)`:**

```rust
active_profile: Mutex::new(None),
logged_in_profile: Mutex::new(None),
storage_paths: Mutex::new(storage_paths),

vault_keeper_conn: Mutex::new(None),
vault_key: Mutex::new(None),
vault_persist_guard: Mutex::new(()),
backup_guard: Mutex::new(()),
```

**Replace with:**

```rust
active_profile: Mutex::new(None),
storage_paths: Mutex::new(storage_paths),

vault_session: Mutex::new(None),
vault_persist_guard: Mutex::new(()),
backup_guard: Mutex::new(()),
```

### 1.3 Update logout_and_cleanup()

**Find:**

```rust
let is_logged_in = self
    .logged_in_profile
    .lock()
    .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
    .is_some();

if is_logged_in {
    crate::services::security_service::lock_vault(self)?;
}
```

**Replace with (lock_vault becomes safe no-op for passwordless):**

```rust
crate::services::security_service::lock_vault(self)?;
```

### 1.4 Update clear_security_state()

**Delete the whole blocks that set:**

* `logged_in_profile = None`
* `vault_keeper_conn = None`
* `vault_key = None`

**Replace them with one block:**

```rust
{
    let mut session = self
        .vault_session
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
    *session = None;
}
```

✅ After this, `app_state.rs` must not contain: `logged_in_profile`, `vault_keeper_conn`, `vault_key`.

---

## 2) `src-tauri/src/services/security_service.rs`

### 2.1 Update `open_protected_vault_session(...)`

**Find the three blocks at the end:**

```rust
{
    let mut keeper = state.vault_keeper_conn.lock()?;
    *keeper = Some(conn);
}
{
    let mut active = state.logged_in_profile.lock()?;
    *active = Some(profile_id.to_string());
}
{
    let mut vault_key = state.vault_key.lock()?;
    *vault_key = Some(key);
}
```

**Replace with:**

```rust
{
    let mut session = state
        .vault_session
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_LOCK_POISONED"))?;

    *session = Some(crate::app_state::VaultSession {
        profile_id: profile_id.to_string(),
        conn,
        key,
    });
}
```

### 2.2 Update `login_vault(...)`

**Find at end:**

```rust
if let Ok(mut logged_in) = state.logged_in_profile.lock() {
    *logged_in = Some(id.to_string());
}
```

**Delete that block entirely.**
`active_profile` stays as is.

### 2.3 Replace `persist_active_vault(...)`

**Replace the entire function body with:**

```rust
pub fn persist_active_vault(state: &Arc<AppState>) -> Result<Option<String>> {
    let _flight_guard = state
        .vault_persist_guard
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;

    let maybe_bytes_and_meta = {
        let session_guard = state
            .vault_session
            .lock()
            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;

        if let Some(session) = session_guard.as_ref() {
            let bytes = session
                .conn
                .serialize(DatabaseName::Main)
                .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

            let profile_id = session.profile_id.clone();
            let key_material: [u8; 32] = *session.key;

            Some((profile_id, key_material, bytes))
        } else {
            None
        }
    };

    if let Some((profile_id, key_material, bytes)) = maybe_bytes_and_meta {
        let storage_paths = state.get_storage_paths()?;
        let encrypted = cipher::encrypt_vault_blob(&profile_id, &key_material, &bytes)?;
        cipher::write_encrypted_file(&vault_db_path(&storage_paths, &profile_id)?, &encrypted)?;
        return Ok(Some(profile_id));
    }

    Ok(None)
}
```

### 2.4 Update `lock_vault(...)`

**Find the whole block that locks `vault_keeper_conn`, `vault_key`, and clears `logged_in_profile`** and replace with:

```rust
pub fn lock_vault(state: &Arc<AppState>) -> Result<bool> {
    if let Some(id) = persist_active_vault(state)? {
        attachments_service::clear_previews_for_profile(state, &id)?;

        {
            let mut session = state
                .vault_session
                .lock()
                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;

            *session = None;
        }

        clear_pool(&id);
    }

    Ok(true)
}
```

### 2.5 Replace `is_logged_in(...)`

**Replace entire function with:**

```rust
pub fn is_logged_in(state: &Arc<AppState>) -> Result<bool> {
    let storage_paths = state.get_storage_paths()?;

    let active_id = state
        .active_profile
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
        .clone();

    let Some(id) = active_id else { return Ok(false); };

    let profile = crate::data::profiles::registry::get_profile(&storage_paths, &id)?
        .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;

    if !profile.has_password {
        return Ok(true);
    }

    let session = state
        .vault_session
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;

    Ok(session.as_ref().map(|s| s.profile_id == id).unwrap_or(false))
}
```

> Примечание: “single invoke_handler” в `main.rs` держим железно — иначе команды не зарегистрируются. ([Tauri][3])

---

## 3) Add one shared helper for “require unlocked” and delete duplicates in services

### 3.1 Add helper in `security_service.rs`

**Add near top-level (below `is_logged_in` or above services):**

```rust
pub struct ActiveSessionInfo {
    pub profile_id: String,
    pub vault_key: Option<[u8; 32]>,
}

pub fn require_unlocked_active_profile(state: &Arc<AppState>) -> Result<ActiveSessionInfo> {
    let storage_paths = state.get_storage_paths()?;

    let active_id = state
        .active_profile
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
        .clone()
        .ok_or_else(|| ErrorCodeString::new("VAULT_LOCKED"))?;

    let profile = crate::data::profiles::registry::get_profile(&storage_paths, &active_id)?
        .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;

    if !profile.has_password {
        return Ok(ActiveSessionInfo {
            profile_id: active_id,
            vault_key: None,
        });
    }

    let session = state
        .vault_session
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;

    if let Some(s) = session.as_ref() {
        if s.profile_id == active_id {
            return Ok(ActiveSessionInfo {
                profile_id: active_id,
                vault_key: Some(*s.key),
            });
        }
    }

    Err(ErrorCodeString::new("VAULT_LOCKED"))
}
```

---

## 4) Update all services to use the helper and remove old require_logged_in()

### 4.1 `src-tauri/src/services/folders_service.rs`

**Delete local `fn require_logged_in(...)` entirely.**

**Replace calls like:**

```rust
let profile_id = require_logged_in(state)?;
```

**With:**

```rust
let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
```

### 4.2 Do the same replacement in these files:

* `src-tauri/src/services/datacards_service.rs`
* `src-tauri/src/services/bank_cards_service.rs`
* `src-tauri/src/services/password_history_service.rs`
* `src-tauri/src/services/settings_service.rs`
* `src-tauri/src/services/backup_service.rs`

All of them currently compare `(active_profile, logged_in_profile)` — это всё удалить и заменить на `require_unlocked_active_profile`.

### 4.3 `src-tauri/src/services/attachments_service.rs`

**In `require_logged_in(app: &AppHandle)` replace the matching logic**:

**Find block:**

```rust
let active_profile = app_state.active_profile.lock()?.clone();
let logged_in_profile = app_state.logged_in_profile.lock()?.clone();

match (active_profile, logged_in_profile) {
    (Some(active), Some(logged)) if active == logged => {
        let vault_key = app_state.vault_key.lock()?.as_ref().map(|k| **k);
        Ok(ActiveSession { ... })
    }
    _ => Err(ErrorCodeString::new("VAULT_LOCKED")),
}
```

**Replace with:**

```rust
let info = security_service::require_unlocked_active_profile(&app_state)?;

Ok(ActiveSession {
    state: app_state,
    storage_paths,
    profile_id: info.profile_id,
    vault_key: info.vault_key,
})
```

---

## 5) `src-tauri/src/data/sqlite/repo_impl.rs`

### 5.1 Update `with_connection(...)` to use `vault_session`

**Find the keeper-based part:**

```rust
let active_guard = state.logged_in_profile.lock()?;
...
let keeper_guard = state.vault_keeper_conn.lock()?;
...
```

**Replace the whole “if unlocked use keeper” part with:**

```rust
{
    let session = state
        .vault_session
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_LOCK_POISONED"))?;

    if let Some(s) = session.as_ref() {
        if s.profile_id == profile_id {
            return f(&s.conn);
        }
    }
}
```

Everything else (pool + file DB) stays.

---

## 6) `src-tauri/src/commands/profiles.rs`

### 6.1 Fix `profile_delete` should_lock check

**Find:**

```rust
let should_lock = app_state
    .logged_in_profile
    .lock()?
    .as_deref()
    == Some(&id);
```

**Replace with:**

```rust
let should_lock = app_state
    .vault_session
    .lock()
    .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
    .as_ref()
    .map(|s| s.profile_id == id)
    .unwrap_or(false);
```

---

## 7) Cleanup: remove dead imports & fields

After steps выше:

* Remove all `logged_in_profile` / `vault_keeper_conn` / `vault_key` references.
* Remove unused `Zeroize/Zeroizing` imports where no longer needed.

---

## Acceptance checks (fast)

1. Protected profile:

   * unlock → CRUD works; `persist_active_vault` writes encrypted DB
   * lock → `vault_session` cleared; operations return `VAULT_LOCKED`
2. Passwordless profile:

   * select active profile → CRUD works without `vault_session`
3. No occurrence of:

   * `logged_in_profile`
   * `vault_keeper_conn`
   * `vault_key`
4. No “no such table” spam after unlock.


[3]: https://v2.tauri.app/develop/calling-rust/?utm_source=chatgpt.com "Calling Rust from the Frontend"
