

# Technical Specification (EN): Add “Max copies” backup retention (keep last N backups)

## Summary

Add a new backups setting **Max copies** that limits the number of managed backups stored in the default backups folder.
Rule: if `Max copies = 10`, after a successful creation of a new backup in the default folder, if total managed backups becomes 11, delete the **oldest** managed backup so the total becomes 10.

UI order in Settings → Backups:

1. Interval (minutes)
2. Max copies
3. Retention days

## Scope

* Windows-only app (no cross-platform requirements)
* Frontend (Settings UI + typed settings model)
* Backend (UserSettings schema + retention/prune logic in backup registry)

## Definitions

* **Managed backup**: a backup file located inside the default profile backups directory:
  `backups_dir(storage_paths, profile_id)` (already used when `use_default_path == true`).
* **Unmanaged backup**: backup created to a custom user-chosen destination path (must NOT be auto-deleted by retention/max copies).

## Files to change

### Frontend

* `src/features/Vault/types/backend.ts`
* `src/features/Vault/components/modals/SettingsModal.tsx`

### Backend (Rust, Tauri)

* `src-tauri/src/types.rs`
* `src-tauri/src/services/backup_service.rs`

---

## 1) Frontend: extend settings type

**File:** `src/features/Vault/types/backend.ts`

### Change

Add a new numeric field to `BackendUserSettings`:

**Before**

```ts
export type BackendUserSettings = {
  ...
  backups_enabled: boolean;
  auto_backup_interval_minutes: number;
  backup_frequency: "daily" | "weekly" | "monthly";
  backup_retention_days: number;
  ...
};
```

**After**

```ts
export type BackendUserSettings = {
  ...
  backups_enabled: boolean;
  auto_backup_interval_minutes: number;
  backup_max_copies: number;
  backup_frequency: "daily" | "weekly" | "monthly";
  backup_retention_days: number;
  ...
};
```

---

## 2) Frontend: Settings modal UI (add “Max copies” between Interval and Retention)

**File:** `src/features/Vault/components/modals/SettingsModal.tsx`

### State / hydration

Add local state:

```ts
const [maxCopies, setMaxCopies] = useState('10');
```

In the `useEffect` that hydrates from `settings`, add:

```ts
setMaxCopies(String(settings.backup_max_copies));
```

### Validation rules (canSave)

Add numeric validation for `maxCopies`:

* `maxCopies` must be an integer in range **1..500** (choose 500 as a safe upper bound for now)
* If invalid → `canSave = false`

Example (integrate into existing `canSave`):

```ts
const max = Number(maxCopies);
if (!Number.isFinite(max) || max < 1 || max > 500) return false;
```

### Save payload (handleSave)

When building `nextSettings`, include:

```ts
backup_max_copies: Number(maxCopies),
```

### UI placement (order requirement)

In the Backups group, render fields exactly in this order:

1. Auto backup enabled (toggle)
2. Interval (minutes)
3. **Max copies**
4. Retention days

Add a new input block between Interval and Retention:

```tsx
<div className="form-field">
  <label className="form-label" htmlFor="backup-max-copies">
    Max copies
  </label>
  <input
    id="backup-max-copies"
    type="number"
    min={1}
    max={500}
    value={maxCopies}
    disabled={busy}
    inputMode="numeric"
    onChange={(event) => setMaxCopies(event.target.value)}
    style={fullWidthInputStyle}
  />
</div>
```

**Acceptance criteria (UI)**

* The Backups settings are displayed in the required order.
* Saving updates `backup_max_copies` in backend settings (persisted and reloaded).

---

## 3) Backend: extend `UserSettings` schema with defaults (backward compatible)

**File:** `src-tauri/src/types.rs`

### Change: add field to struct

Add a new field to `pub struct UserSettings`:

```rust
#[serde(default = "default_backup_max_copies")]
pub backup_max_copies: i64,
```

Add default function near other defaults:

```rust
fn default_backup_max_copies() -> i64 {
    10
}
```

Update `impl Default for UserSettings` to set:

```rust
backup_max_copies: default_backup_max_copies(),
```

**Acceptance criteria (settings file compatibility)**

* Existing `user_settings.json` files that don’t have `backup_max_copies` still load successfully (serde default).
* New settings writes include `backup_max_copies`.

---

## 4) Backend: enforce “Max copies” retention after successful backup creation (default folder only)

**File:** `src-tauri/src/services/backup_service.rs`

### Key requirement

Retention logic must apply ONLY to **managed** backups (inside default `backups_dir`).
Unmanaged backups (custom destination path) must never be deleted automatically.

### A) Update retention-by-days to only affect managed backups

Update `apply_retention(...)` signature to accept `managed_root: &Path`:

**Before**

```rust
fn apply_retention(settings: &UserSettings, registry: &mut BackupRegistry) { ... }
```

**After**

```rust
fn apply_retention(settings: &UserSettings, managed_root: &Path, registry: &mut BackupRegistry) { ... }
```

Modify logic so it keeps all entries outside `managed_root`:

```rust
let cutoff = Utc::now() - chrono::Duration::days(settings.backup_retention_days);

registry.backups.retain(|entry| {
    let path = PathBuf::from(&entry.path);
    if !path.starts_with(managed_root) {
        return true;
    }

    let keep = chrono::DateTime::parse_from_rfc3339(&entry.created_at_utc)
        .map(|dt| dt.with_timezone(&Utc) >= cutoff)
        .unwrap_or(true);

    if !keep {
        let _ = fs::remove_file(&entry.path);
    }
    keep
});
```

### B) Add a new function `apply_max_copies(...)`

Add a function:

```rust
fn apply_max_copies(settings: &UserSettings, managed_root: &Path, registry: &mut BackupRegistry) {
    let mut max_copies = settings.backup_max_copies;
    if max_copies < 1 {
        max_copies = 1;
    }
    let max_copies = max_copies as usize;

    // Collect managed backups with parsed timestamps (oldest first)
    let mut managed: Vec<(usize, chrono::DateTime<Utc>)> = registry
        .backups
        .iter()
        .enumerate()
        .filter_map(|(idx, item)| {
            let path = PathBuf::from(&item.path);
            if !path.starts_with(managed_root) {
                return None;
            }
            let dt = chrono::DateTime::parse_from_rfc3339(&item.created_at_utc)
                .ok()
                .map(|dt| dt.with_timezone(&Utc))
                .unwrap_or_else(Utc::now);
            Some((idx, dt))
        })
        .collect();

    managed.sort_by_key(|(_, dt)| *dt); // oldest -> newest

    if managed.len() <= max_copies {
        return;
    }

    let to_remove = managed.len() - max_copies;
    let mut remove_indices: Vec<usize> = managed
        .into_iter()
        .take(to_remove)
        .map(|(idx, _)| idx)
        .collect();

    // Remove from the end so indices stay valid
    remove_indices.sort_unstable_by(|a, b| b.cmp(a));

    for idx in remove_indices {
        if let Some(entry) = registry.backups.get(idx) {
            let _ = fs::remove_file(&entry.path);
        }
        registry.backups.remove(idx);
    }
}
```

### C) Call both retention steps after successful create (manual + auto)

#### 1) `backup_create(...)`

**Before** (inside `update_registry` closure):

```rust
prune_registry(registry);
apply_retention(&settings, registry);
```

**After**:

* Compute managed root once:

```rust
let managed_root = backups_dir(&sp, &profile_id)?;
```

* Inside the closure:

```rust
prune_registry(registry);
apply_retention(&settings, &managed_root, registry);
apply_max_copies(&settings, &managed_root, registry);
```

#### 2) `backup_create_if_due_auto(...)`

**Before**:

```rust
prune_registry(&mut registry);
apply_retention(&settings, &mut registry);
save_registry(...)?;
```

**After**:

```rust
let managed_root = backups_dir(&sp, &profile_id)?;

prune_registry(&mut registry);
apply_retention(&settings, &managed_root, &mut registry);
apply_max_copies(&settings, &managed_root, &mut registry);
save_registry(&sp, &profile_id, &registry)?;
```

### Acceptance criteria (backend)

1. With `backup_max_copies = 10`, after creating 11th managed backup, the oldest managed backup file is deleted and registry contains 10 managed backups.
2. Deletions happen **only after** a successful new backup creation.
3. Backups created to user-selected custom paths are NOT deleted by retention days or max copies.

---

## Manual test plan (Windows)

1. Settings → Backups:

   * Interval = 60
   * Max copies = 3
   * Retention days = 30
2. Create 4 backups using **default path**:

   * After 4th success: only **3 latest** remain in default backups folder; the oldest is deleted.
3. Create 1 backup using **custom destination path**:

   * Confirm this custom file is never deleted by subsequent auto/manual backups in default path.


[1]: https://restic.readthedocs.io/en/stable/060_forget.html?utm_source=chatgpt.com "Removing backup snapshots — restic 0.18.1 documentation"
