

# Technical Specification (EN): Reliable Clipboard Wipe on Windows (WinAPI EmptyClipboard) + Frontend integration

## Goal

Implement a Windows-only clipboard wipe function that **guarantees clearing the entire clipboard** (all formats) and use it for:

1. clipboard auto-clear timer
2. (optional but recommended) on vault lock

Replace unreliable timer-based `navigator.clipboard.writeText('')` calls with a Tauri command invoking WinAPI `EmptyClipboard`.

## Rationale

* Web Clipboard API writes may require `clipboard-write` permission or transient user activation. Timers are not user activation → clears may fail. ([MDN Web Docs][1])
* Windows WinAPI `EmptyClipboard` explicitly empties the clipboard and frees its handles; it requires `OpenClipboard` and should be followed by `CloseClipboard`. ([Microsoft Learn][2])
* Tauri commands are exposed using `#[tauri::command]` and registered via `tauri::generate_handler!`, then called from frontend using `invoke`. ([Tauri][3])

---

## Files to change

### Backend (Rust, Windows-only)

1. `src-tauri/Cargo.toml`
2. `src-tauri/src/services/clipboard_service.rs` (new)
3. `src-tauri/src/commands/clipboard.rs` (new)
4. `src-tauri/src/main.rs` (or `src-tauri/src/lib.rs` depending on your Tauri entry)

### Frontend (TS/React)

5. `src/lib/tauri.ts` (or your existing tauri wrapper)
6. Copy flows where auto-clear currently calls `navigator.clipboard.writeText('')` inside a timeout:

   * `src/features/Vault/components/Details/useDetails.tsx`
   * `src/features/Vault/components/BankCards/useBankCardDetails.tsx`
   * `src/features/Vault/components/modals/PasswordHistoryDialog.tsx`
   * `src/features/Vault/components/DataCards/DataCards.tsx`
7. (Optional) `src/features/Vault/useVault.ts` (wipe clipboard when locking)

---

## 1) Backend: add Windows clipboard wipe command

### 1.1 Add dependency on windows-sys with required Win32 feature flags

**File:** `src-tauri/Cargo.toml`

Add (or extend) dependencies:

```toml
[dependencies]
windows-sys = { version = "0.61", features = [
  "Win32_Foundation",
  "Win32_System_DataExchange",
  "Win32_UI_WindowsAndMessaging"
] }
```

> `windows-sys` is the low-level WinAPI bindings crate. ([Crates.io][4])

---

### 1.2 Implement the service: wipe clipboard via WinAPI with retries

**File:** `src-tauri/src/services/clipboard_service.rs` (NEW)

```rust
#[cfg(target_os = "windows")]
use std::time::Duration;

#[cfg(target_os = "windows")]
use windows_sys::Win32::Foundation::{GetLastError, BOOL};
#[cfg(target_os = "windows")]
use windows_sys::Win32::System::DataExchange::{CloseClipboard, EmptyClipboard, OpenClipboard};
#[cfg(target_os = "windows")]
use windows_sys::Win32::UI::WindowsAndMessaging::GetForegroundWindow;

/// Clears the entire Windows clipboard (all formats).
/// Uses OpenClipboard -> EmptyClipboard -> CloseClipboard.
/// Retries because clipboard may be temporarily locked by other processes.
#[cfg(target_os = "windows")]
pub fn clear_clipboard_all() -> Result<(), String> {
    // Retry settings: tuned for "clipboard busy" edge cases
    const ATTEMPTS: usize = 10;
    const SLEEP_MS: u64 = 25;

    for attempt in 0..ATTEMPTS {
        unsafe {
            // Use a window handle for ownership. Foreground window is acceptable in most desktop apps.
            let hwnd = GetForegroundWindow();
            let opened: BOOL = OpenClipboard(hwnd);

            if opened == 0 {
                // Clipboard is busy or access denied
                if attempt + 1 < ATTEMPTS {
                    std::thread::sleep(Duration::from_millis(SLEEP_MS));
                    continue;
                }
                let err = GetLastError();
                return Err(format!("OPENCLIPBOARD_FAILED ({})", err));
            }

            let emptied: BOOL = EmptyClipboard();
            // Always close clipboard after successful open
            CloseClipboard();

            if emptied == 0 {
                let err = GetLastError();
                return Err(format!("EMPTYCLIPBOARD_FAILED ({})", err));
            }

            return Ok(());
        }
    }

    Err("CLIPBOARD_BUSY".to_string())
}
```

This follows Microsoft’s documented clipboard procedure (open → empty → close). ([Microsoft Learn][2])

> Note: If you have a reliable app window handle in Tauri state, you can use it instead of `GetForegroundWindow()`. The essential part is the Open/Empty/Close sequence.

---

### 1.3 Create a Tauri command wrapper

**File:** `src-tauri/src/commands/clipboard.rs` (NEW)

```rust
#[cfg(target_os = "windows")]
use crate::services::clipboard_service;

#[tauri::command]
pub fn clipboard_clear_all() -> Result<(), String> {
    #[cfg(target_os = "windows")]
    {
        clipboard_service::clear_clipboard_all()
    }

    #[cfg(not(target_os = "windows"))]
    {
        Err("NOT_SUPPORTED".to_string())
    }
}
```

---

### 1.4 Register the command in Tauri invoke handler

Depending on your project:

#### If you have `src-tauri/src/main.rs`

Add module declarations:

```rust
mod services {
    pub mod clipboard_service;
    // ... other services
}

mod commands {
    pub mod clipboard;
    // ... other commands
}
```

Then in your builder:

```rust
.invoke_handler(tauri::generate_handler![
    // ... existing commands
    commands::clipboard::clipboard_clear_all
])
```

Important: all commands must be in a single `generate_handler!` list (not multiple invoke_handler calls). ([Tauri][3])

---

## 2) Frontend: expose a single “wipe clipboard” function via invoke

### 2.1 Add tauri wrapper

**File:** `src/lib/tauri.ts` (or wherever you wrap tauri invoke)

```ts
import { invoke } from '@tauri-apps/api/core';

export async function clipboardClearAll(): Promise<void> {
  await invoke('clipboard_clear_all');
}
```

---

## 3) Frontend: replace timer-based web clear with backend wipe

### Rule (apply in all copy flows)

Where you currently do:

```ts
setTimeout(async () => {
  const current = await navigator.clipboard.readText();
  if (current === lastCopiedValueRef.current) {
    await navigator.clipboard.writeText('');
  }
}, timeoutMs);
```

Replace the clear step with the backend wipe:

```ts
import { clipboardClearAll } from '../../../lib/tauri'; // adjust relative path

setTimeout(async () => {
  try {
    const current = await navigator.clipboard.readText();
    if (current === lastCopiedValueRef.current) {
      await clipboardClearAll();
    }
  } catch (err) {
    console.error(err);
  } finally {
    // reset refs/timers
  }
}, timeoutMs);
```

Keep the “only clear if unchanged” safeguard to avoid nuking user’s new clipboard content.

### Files to update (exact)

* `src/features/Vault/components/Details/useDetails.tsx`
* `src/features/Vault/components/BankCards/useBankCardDetails.tsx`
* `src/features/Vault/components/modals/PasswordHistoryDialog.tsx`
* `src/features/Vault/components/DataCards/DataCards.tsx`

---

## 4) Optional: wipe clipboard on vault lock

**File:** `src/features/Vault/useVault.ts`

In your existing `lock()` callback (where you call `await lockVault()`), add:

```ts
import { clipboardClearAll } from '../../lib/tauri'; // adjust path

const lock = useCallback(async () => {
  try {
    await lockVault(profileId);
  } finally {
    try {
      await clipboardClearAll();
    } catch (err) {
      console.error(err);
    }
    onLocked();
  }
}, [profileId, onLocked]);
```

---

## Acceptance Criteria

1. After the configured timeout, clipboard is cleared even when the app is idle (no user gesture), because wipe happens in native backend.
2. Clipboard is cleared **entirely** (not just replaced with empty text) because `EmptyClipboard()` is used. ([Microsoft Learn][5])
3. If the user copies something else after copying a secret, auto-clear must NOT erase the new clipboard content (unchanged-check remains).
4. If clipboard is busy (locked by other app), backend retries several times before returning an error; no crash.


