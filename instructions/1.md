## Technical Specification (TS): Set WAL once (DB file-level), remove WAL PRAGMAs from r2d2 pool to fix `database is locked`

### Context / Problem

During startup the app creates an r2d2 pool with `min_idle(Some(4))`, which immediately acquires multiple SQLite connections. Each connection currently executes:

* `PRAGMA journal_mode = WAL;`
* `PRAGMA synchronous = NORMAL;`
* `PRAGMA foreign_keys = ON;`

inside `CustomizeConnection::on_acquire` (pool customizer). Setting `journal_mode=WAL` is **a database-file setting** and is **persistent**; doing it concurrently across multiple connections can trigger `SQLITE_BUSY` / `database is locked`. SQLite explicitly states WAL mode is persistent and affects all connections to the same DB file once set. ([SQLite][1])

### Goal

1. Configure the vault **database file** to WAL **once** during initialization/migration (single connection, no pool yet).
2. Ensure pooled connections only apply **connection-scoped** pragmas (`busy_timeout`, `foreign_keys`, `synchronous`) and do **not** attempt to change `journal_mode`.
3. Eliminate startup `database is locked` (r2d2 error) for passwordless/file DB mode.

---

## Implementation Plan

### 1) Move WAL configuration to DB initialization (single connection)

#### File

`src-tauri/src/data/sqlite/init.rs`

#### Change

Update `init_database_passwordless(...)` so it:

1. opens the DB connection
2. runs migrations
3. ensures WAL mode is set on the **database file** (idempotent)
4. returns `Ok(())`

**Replace current function:**

```rust
pub fn init_database_passwordless(sp: &StoragePaths, profile_id: &str) -> Result<()> {
    ensure_profile_dirs(sp, profile_id)
        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;

    let conn = Connection::open(vault_db_path(sp, profile_id)?)
        .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;

    migrations::migrate_to_latest(&conn)
}
```

**With this exact implementation:**

```rust
pub fn init_database_passwordless(sp: &StoragePaths, profile_id: &str) -> Result<()> {
    ensure_profile_dirs(sp, profile_id)
        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;

    let conn = Connection::open(vault_db_path(sp, profile_id)?)
        .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;

    migrations::migrate_to_latest(&conn)?;

    // Set WAL ONCE (DB-file persistent) and avoid doing it in pool connections.
    // WAL persistence is documented by SQLite. :contentReference[oaicite:1]{index=1}
    let current: String = conn
        .query_row("PRAGMA journal_mode;", [], |row| row.get(0))
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    if current.to_uppercase() != "WAL" {
        // This PRAGMA changes the DB file state; run it only from init, not from r2d2 on_acquire.
        let _: String = conn
            .query_row("PRAGMA journal_mode=WAL;", [], |row| row.get(0))
            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
    }

    Ok(())
}
```

**Notes**

* `PRAGMA journal_mode=WAL` is persistent across reopen and applies to all connections once set. ([SQLite][1])
* We deliberately do **not** set `foreign_keys` here (it’s connection-scoped and will be set per pooled connection; also SQLite warns pragma defaults can change, so apps should set what they need explicitly). ([SQLite][2])

---

### 2) Remove `journal_mode=WAL` from r2d2 pool connections (FilePragmas)

#### File

`src-tauri/src/data/sqlite/pool.rs`

#### Change A — FilePragmas: remove WAL PRAGMA, keep connection-scoped settings

**Current:**

```rust
conn.execute_batch(
    r#"
    PRAGMA foreign_keys = ON;
    PRAGMA journal_mode = WAL;
    PRAGMA synchronous = NORMAL;
    "#,
)
```

**Replace with:**

```rust
conn.execute_batch(
    r#"
    PRAGMA foreign_keys = ON;
    PRAGMA synchronous = NORMAL;
    "#,
)
```

Also keep:

```rust
conn.busy_timeout(Duration::from_secs(5))?;
```

**Why**

* `busy_timeout` is per-connection and is the canonical way to make SQLite wait before failing with `SQLITE_BUSY`. ([SQLite][2])
* `foreign_keys` enforcement is per-connection and should be set explicitly by applications. ([SQLite][2])
* `synchronous=NORMAL` is a good performance/safety balance for WAL mode; this setting is applied per connection. ([SQLite][2])

#### Change B — MemoryPragmas: keep as-is (or optional tweak)

You can keep `MemoryPragmas` unchanged, since it uses `journal_mode=MEMORY` for in-memory protected vaults and does not touch the file DB. If you want consistency, you may also keep `foreign_keys` + `synchronous` there as currently.

---

### 3) Ensure call order: init BEFORE pool usage

#### Files to verify (no code change unless currently violated)

* Any code path that calls `get_conn(profile_id, DbTarget::File(...))` must ensure `init_database_passwordless(...)` has been executed for that profile ID first.

This is already the intent of your architecture (create/login calls init), but confirm that no code path creates a pool connection to file DB without init.

---

## Acceptance Criteria

1. **Startup success**: On a fresh workspace/profile, no `[r2d2][ERROR] database is locked` appears.
2. **DB is in WAL mode**: After init, `PRAGMA journal_mode;` returns `wal`/`WAL` when opening the same `vault.db`.
3. **No WAL PRAGMA in pool acquire**: `src-tauri/src/data/sqlite/pool.rs` no longer sets `journal_mode=WAL` in `FilePragmas::on_acquire`.
4. **Busy handling remains**: pooled connections still set a busy handler/timeout and do not fail immediately under short transient locks. ([SQLite][2])

---

## Optional (recommended) runtime safety notes for portable drives

WAL mode uses `-wal` and `-shm` sidecar files next to `vault.db`. SQLite documents that read-only media and directory permissions can affect WAL operation. ([SQLite][1])
If your portable workspace can land on restrictive media, ensure the workspace folder is writable.


