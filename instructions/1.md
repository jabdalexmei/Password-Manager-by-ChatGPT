

## Technical Specification (TS): Reduce SQLite lock contention by slimming r2d2 pool for file-backed DB

### Context / Problem

Current implementation (`src-tauri/src/data/sqlite/pool.rs`) configures an r2d2 pool for **file-backed SQLite** with:

* `max_size(8)`
* `min_idle(Some(4))`
* `connection_timeout(5s)`
* `busy_timeout(5s)` per connection

This aggressively maintains multiple open connections to the same file DB. With SQLite (single-writer; WAL helps concurrency but does not eliminate write-locks), this increases the probability of `SQLITE_BUSY` (“database is locked”), especially on slow/removable/network filesystems. SQLite documentation states that after the busy timeout expires, the operation returns `SQLITE_BUSY`. ([SQLite][1])

### Goal

For **file-backed vault DB**:

* Reduce concurrent open connections
* Avoid pre-warming idle connections
* Increase wait windows slightly (busy + pool get timeout)
* Keep PRAGMAs in pool limited to non-file-mode-changing settings (WAL is file-level and should be set once elsewhere) ([SQLite][2])

### Non-goals

* No DB schema changes
* No migrations
* No changes to repository/query logic
* No UI changes

---

## Required Changes

### 1) Update pool configuration for file-backed DB

**File:** `src-tauri/src/data/sqlite/pool.rs`

#### 1.1 Introduce explicit constants (to avoid magic numbers)

Add near the top (after imports):

```rust
const DB_POOL_MAX_SIZE_FILE: u32 = 2;
const DB_POOL_MIN_IDLE_FILE: u32 = 0;
const DB_POOL_CONNECTION_TIMEOUT_SECS_FILE: u64 = 10;
const DB_BUSY_TIMEOUT_SECS_FILE: u64 = 15;
```

*(Optional but recommended: keep memory target separate constants; memory DB does not lock the filesystem, but using the same busy timeout is harmless.)*

#### 1.2 Increase busy_timeout for file-backed connections

Locate `FilePragmas::on_acquire`:

**Current:**

```rust
conn.busy_timeout(Duration::from_secs(5))?;
```

**Change to:**

```rust
conn.busy_timeout(Duration::from_secs(DB_BUSY_TIMEOUT_SECS_FILE))?;
```

Rationale: busy_timeout is still “just waiting”, but with a smaller pool it becomes a “reasonable buffer” instead of a band-aid. SQLite busy timeout semantics: after time elapses → `SQLITE_BUSY`. ([SQLite][1])

#### 1.3 Slim the file pool: max_size, min_idle, connection_timeout

Locate builder in `DbTarget::File(path)`:

**Current:**

```rust
r2d2::Pool::builder()
    .max_size(8)
    .min_idle(Some(4))
    .connection_timeout(Duration::from_secs(5))
    .connection_customizer(Box::new(FilePragmas))
    .build(manager)
```

**Change to:**

```rust
r2d2::Pool::builder()
    .max_size(DB_POOL_MAX_SIZE_FILE)
    .min_idle(Some(DB_POOL_MIN_IDLE_FILE))
    .connection_timeout(Duration::from_secs(DB_POOL_CONNECTION_TIMEOUT_SECS_FILE))
    .connection_customizer(Box::new(FilePragmas))
    .build(manager)
```

Notes:

* `min_idle(Some(0))` prevents the pool from keeping idle connections alive “just because”. Meaning of min_idle: pool tries to maintain at least that many idle connections. ([Diesel Documentation][3])
* `max_size=2` is a pragmatic cap: allows one connection to be busy while another is obtained, without creating an “SQLite thunderdome”.

#### 1.4 Apply same pooling limits to DbTarget::Uri (optional but consistent)

Locate `DbTarget::Uri(uri)` builder:

**Current:**

```rust
r2d2::Pool::builder()
    .max_size(8)
    .min_idle(Some(4))
    .connection_timeout(Duration::from_secs(5))
    .connection_customizer(Box::new(MemoryPragmas))
    .build(manager)
```

**Change to (recommended for consistency):**

```rust
r2d2::Pool::builder()
    .max_size(DB_POOL_MAX_SIZE_FILE)
    .min_idle(Some(DB_POOL_MIN_IDLE_FILE))
    .connection_timeout(Duration::from_secs(DB_POOL_CONNECTION_TIMEOUT_SECS_FILE))
    .connection_customizer(Box::new(MemoryPragmas))
    .build(manager)
```

*(If you want to keep a larger pool for URI/memory, define separate constants; but simplest is to align.)*

---

## Acceptance Criteria

1. For file-backed vault DB, pool does **not** pre-create 4 idle connections on startup (min_idle=0).
2. Total active connections per profile DB is capped to 2 (max_size=2).
3. Under rapid actions (create/edit datacard, edit custom fields, etc.), the frequency of `database is locked` is significantly reduced.
4. No `PRAGMA journal_mode=WAL` is executed in `pool.rs` (WAL should be set once at init, as already discussed). WAL is file-level persistent. ([SQLite][2])

---

## Test Plan (Manual)

1. Workspace on removable drive / slow disk (your typical portable scenario).
2. Create 30–50 datacards quickly; edit fields rapidly; open/close dialogs.
3. Observe logs:

   * No repeated “pool build” storms
   * No `r2d2` errors “database is locked”
4. Stress: open multiple dialogs rapidly (if app allows) and attempt repeated updates.


