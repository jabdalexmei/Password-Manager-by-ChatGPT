# Technical Specification (EN): Remove pooled “shared in-memory URI” vault mode; use keeper connection only for unlocked protected vault

## Background / Motivation

Your runtime errors (`no such table: folders/datacards/bank_cards`) come from using **multiple SQLite connections** against an “in-memory + shared cache” database while also using a **connection pool**. Even though SQLite supports shared-cache in-memory DBs via URI, this setup is fragile in pooled/multi-connection scenarios and often results in “some connections see an empty DB”. SQLite docs explain how in-memory DBs behave and how shared-cache works, and real-world reports (e.g., pool + shared in-memory) show migrations applied on one connection while others see empty schema. ([SQLite][1])

This TS simplifies architecture:

* **Protected vault unlocked in RAM:** single authoritative **keeper `rusqlite::Connection`** only (NO pool, NO `mode=memory&cache=shared`).
* **Passwordless / on-disk vault:** keep r2d2 pool with normal file DB path.

Result: removes the entire class of “wrong connection / empty schema” bugs.

---

## Goals

1. Delete the “URI in-memory vault target” path (`DbTarget::Uri(...)`, `vault_db_uri(...)`, and all pool usage for unlocked protected vault).
2. Route all DB operations for unlocked protected vault through `state.vault_keeper_conn` only.
3. Keep pool only for file vaults.
4. Keep current behavior: vault exists in memory while session is unlocked; on lock, serialize and drop keeper.

---

## Scope

Backend only (`src-tauri`). Frontend unchanged.

---

## Files to change

1. `src-tauri/src/data/sqlite/pool.rs`
2. `src-tauri/src/data/sqlite/repo_impl.rs`
3. `src-tauri/src/services/security_service.rs`
4. `src-tauri/src/types.rs` (only if it contains DbTarget/uri helpers)
5. `src-tauri/src/data/sqlite/mod.rs` (or wherever `DbTarget` is defined/re-exported)

---

## 1) Remove “Uri” DB target mode from the pool

### 1.1 Update `DbTarget` enum to remove Uri variant

**File:** where `DbTarget` is defined (commonly `src-tauri/src/data/sqlite/pool.rs` or `src-tauri/src/data/sqlite/mod.rs`)

#### Before (example)

```rust
pub enum DbTarget {
    File(PathBuf),
    Uri(rusqlite::OpenFlags, String), // or Uri(String)
}
```

#### After

```rust
pub enum DbTarget {
    File(PathBuf),
}
```

### 1.2 Remove `vault_db_uri(...)` helper entirely

**File:** wherever it is defined (commonly `repo_impl.rs` or `pool.rs`)

Delete the function (and all references):

* `vault_db_uri(profile_id) -> String`
* Any logging that prints `target=Uri("file:pm_vault_...mode=memory&cache=shared")`

Reason: We will no longer use URI in-memory DBs with a pool, because it’s fragile by design in this architecture. ([SQLite][1])

### 1.3 Remove Uri-handling from pool connection builder

**File:** `src-tauri/src/data/sqlite/pool.rs`

Find code that opens SQLite using URI (examples):

* `Connection::open_with_flags(&uri, flags)`
* `SqliteConnectionManager::file(uri)` with `.with_flags(OpenFlags::SQLITE_OPEN_URI)`
* Any branch `DbTarget::Uri(...) => { ... }`

Delete that branch completely. After this, `get_conn(...)` supports only `DbTarget::File`.

---

## 2) Repo must select connection source using keeper presence only (no URI)

This is the “second TS” simplification you asked for: do not compute any db target for unlocked vault at all—just use keeper if present.

### 2.1 Add a single helper `with_connection` and delete all URI logic

**File:** `src-tauri/src/data/sqlite/repo_impl.rs`

Add (or replace your previous version) with this exact helper:

```rust
use rusqlite::Connection;
use std::sync::Arc;

use crate::state::AppState;
use crate::data::sqlite::pool::{self, DbTarget};
use crate::data::paths::vault_db_path;
use crate::errors::{Result, ErrorCodeString};

fn with_connection<T>(
    state: &Arc<AppState>,
    profile_id: &str,
    f: impl FnOnce(&Connection) -> Result<T>,
) -> Result<T> {
    // 1) If keeper connection exists AND it belongs to the currently logged-in profile,
    // always use it. This is the only supported mode for unlocked protected vaults.
    {
        let active = state.logged_in_profile.lock().map_err(|_| ErrorCodeString::new("STATE_LOCK_POISONED"))?;
        if active.as_deref() == Some(profile_id) {
            let keeper = state.vault_keeper_conn.lock().map_err(|_| ErrorCodeString::new("STATE_LOCK_POISONED"))?;
            if let Some(conn) = keeper.as_ref() {
                return f(conn);
            }
        }
    }

    // 2) Otherwise use file DB pool (passwordless vault).
    let storage_paths = state.get_storage_paths()?;
    let db_path = vault_db_path(&storage_paths, profile_id)?;
    let pooled = pool::get_conn(profile_id, DbTarget::File(db_path))?;
    f(&pooled)
}
```

### 2.2 Update *every* repo function to use `with_connection`

For each function in `repo_impl.rs`, transform:

#### Before

```rust
let conn = open_connection(state, profile_id)?;
... conn.prepare(...) ...
```

#### After

```rust
with_connection(state, profile_id, |conn| {
    ... conn.prepare(...) ...
})
```

This must be applied to:

* folders
* datacards
* bank_cards
* attachments / password history
* any other query path

### 2.3 Delete these obsolete pieces from `repo_impl.rs`

Remove (if present):

* `db_target(...)`
* `open_connection(...)` (old helper)
* any references to `vault_db_uri(...)`
* any code that selects `DbTarget::Uri(...)`

---

## 3) Security service must NOT create any pooled “in-memory target”

### Problem

Right now your open/unlock flow likely:

* deserializes decrypted bytes into keeper conn
* but also configures the pool to connect to `file:pm_vault_...?mode=memory&cache=shared` (or expects it)

We’re removing that completely.

### 3.1 Ensure vault open only sets keeper + logged_in_profile

**File:** `src-tauri/src/services/security_service.rs`

Inside the function that opens the protected vault session (your `open_protected_vault_session(...)` / `unlock_profile(...)` equivalent), enforce this order:

1. Create a `rusqlite::Connection` (plain in-memory)
2. `deserialize_bytes` into it (rusqlite `serialize` feature) ([Docs.rs][2])
3. Run migrations on **this same connection**
4. Store it in `state.vault_keeper_conn = Some(conn)`
5. Set `state.logged_in_profile = Some(profile_id.to_string())`

#### Required code shape (exact intent; adjust names to your project)

```rust
let mut conn = rusqlite::Connection::open_in_memory()?;

// deserialize decrypted bytes into this in-memory conn
conn.deserialize_bytes("main", decrypted_bytes_leaked_static)?;

// migrate using the SAME conn
migrations::migrate_to_latest(&conn)?;

// store keeper
{
    let mut keeper = state.vault_keeper_conn.lock().map_err(|_| ErrorCodeString::new("STATE_LOCK_POISONED"))?;
    *keeper = Some(conn);
}
{
    let mut active = state.logged_in_profile.lock().map_err(|_| ErrorCodeString::new("STATE_LOCK_POISONED"))?;
    *active = Some(profile_id.to_string());
}
```

**Important:** do not create any `DbTarget::Uri` or any pool entry for protected vault.

---

## 4) Lock/close must drop keeper (and optionally clear pool idle conns)

### File

`src-tauri/src/services/security_service.rs`

When you lock the vault:

1. Serialize the keeper connection to bytes
2. Write encrypted blob to disk
3. Set `state.vault_keeper_conn = None`
4. Set `state.logged_in_profile = None`

Optionally, to keep things clean:

* call a pool cleanup for that profile id if your pool caches per-profile connections.

(You already have an `auto_lock_cleanup` Rust-side hook that runs on window close; this stays.)

---

## 5) Why this is “ideal” for your current architecture

* SQLite in-memory + shared cache works under specific conditions, but it is explicitly a special mode and can behave unexpectedly with multiple connections and pooling. ([SQLite][3])
* Real-world pool implementations repeatedly hit “migrations on one conn, others see empty DB” with in-memory shared-cache. ([GitHub][4])
* Keeping a single keeper connection eliminates the entire race class.

---

## Acceptance Criteria

1. After unlocking a protected vault, all list queries succeed:

   * `list_folders`, `list_datacards_summary`, `list_bank_cards_summary` return results without `no such table` errors.
2. Logs never show targets like `mode=memory&cache=shared` because URI mode is removed.
3. Passwordless profile still works using file DB pool.
4. Locking persists vault and clears keeper connection; next unlock works again.

---

## Regression Checklist

* Ensure there is only one `.invoke_handler(...)` in Tauri builder (unrelated but critical rule). ([Tauri][5])
* Ensure repo_impl no longer imports URI/open flags for pooled memory DB.
* Ensure pool.rs has no URI open flags.

