

## Technical Specification (EN): Fix build errors after `vault_session` consolidation

### Goal

Fix Rust compilation errors:

1. `cannot find function require_logged_in` in `datacards_service.rs`
2. Lifetime error `E0597` in `security_service.rs` caused by `Connection::serialize()` returning `Data<'_>` tied to the connection lifetime ([Docs.rs][1])
3. Remove unused import `ErrorCodeString` in `password_history_service.rs`

### Non-goals

* Do not reintroduce legacy “logged_in” helpers.
* Do not implement backwards compatibility for old settings/profiles (project is in dev).

---

## 1) Fix `require_logged_in` usage in DataCards service

### Problem

`src-tauri/src/services/datacards_service.rs` calls `require_logged_in(state)?`, but no such function exists in this module.
There is a function with that name inside `attachments_service.rs`, but it is private (`fn`), therefore not accessible.

### Correct approach

Use the already adopted unified guard:
`security_service::require_unlocked_active_profile(state)?.profile_id`

### File

`src-tauri/src/services/datacards_service.rs`

### Change A — in `purge_datacard(...)`

**Before**

```rust
pub fn purge_datacard(id: String, state: &Arc<AppState>) -> Result<bool> {
    let profile_id = require_logged_in(state)?;
    purge_datacard_with_attachments(state, &profile_id, &id)
}
```

**After**

```rust
pub fn purge_datacard(id: String, state: &Arc<AppState>) -> Result<bool> {
    let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
    purge_datacard_with_attachments(state, &profile_id, &id)
}
```

### Change B — in `set_datacard_favorite(...)`

**Before**

```rust
pub fn set_datacard_favorite(
    input: SetDataCardFavoriteInput,
    state: &Arc<AppState>,
) -> Result<bool> {
    let profile_id = require_logged_in(state)?;
    let updated = repo_impl::set_datacard_favorite(state, &profile_id, &input)?;
    security_service::persist_active_vault(state)?;
    Ok(updated)
}
```

**After**

```rust
pub fn set_datacard_favorite(
    input: SetDataCardFavoriteInput,
    state: &Arc<AppState>,
) -> Result<bool> {
    let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
    let updated = repo_impl::set_datacard_favorite(state, &profile_id, &input)?;
    security_service::persist_active_vault(state)?;
    Ok(updated)
}
```

---

## 2) Fix lifetime error in `persist_active_vault` (E0597)

### Problem

`Connection::serialize(...)` returns `rusqlite::serialize::Data<'_>` which **borrows the Connection** (`'conn`) ([Docs.rs][1]).
You currently store `bytes: Data<'_>` into `maybe_bytes_and_meta`, then exit the `vault_session` lock scope → borrow outlives guard → `E0597`.

### Correct approach

Convert the serialized `Data<'_>` to an owned buffer **inside** the guard scope (e.g. `to_vec()`), then store a `Vec<u8>` in the tuple. `Data` implements `Deref<Target=[u8]>` and has `to_vec()` ([Docs.rs][2]).

### File

`src-tauri/src/services/security_service.rs`

### Patch — inside `persist_active_vault(...)`

Find this block:

**Before**

```rust
if let Some(session) = session_guard.as_ref() {
    let bytes = session
        .conn
        .serialize(DatabaseName::Main)
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    let profile_id = session.profile_id.clone();
    let key_material: [u8; 32] = *session.key;

    Some((profile_id, key_material, bytes))
} else {
    None
}
```

**After**

```rust
if let Some(session) = session_guard.as_ref() {
    let serialized = session
        .conn
        .serialize(DatabaseName::Main)
        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

    // IMPORTANT: make it owned while the session_guard is still alive.
    let bytes: Vec<u8> = serialized.to_vec();

    let profile_id = session.profile_id.clone();
    let key_material: [u8; 32] = *session.key;

    Some((profile_id, key_material, bytes))
} else {
    None
}
```

And ensure the encrypt call stays valid:

**Before**

```rust
let encrypted = cipher::encrypt_vault_blob(&profile_id, &key_material, &bytes)?;
```

**After** (either is fine; pick one style and keep consistent)

```rust
let encrypted = cipher::encrypt_vault_blob(&profile_id, &key_material, bytes.as_slice())?;
```

**Reason**
`encrypt_vault_blob` wants `plaintext: &[u8]`; `Vec<u8>` must be passed as `bytes.as_slice()`.

---

## 3) Remove unused import warning in password history service

### File

`src-tauri/src/services/password_history_service.rs`

### Change

**Before**

```rust
use crate::error::{ErrorCodeString, Result};
```

**After**

```rust
use crate::error::Result;
```

---

## Acceptance Criteria

1. `cargo check` / `cargo build` succeeds with **no errors**.
2. `datacards_service` uses **only** `security_service::require_unlocked_active_profile(...)` for session validation (no legacy `require_logged_in` usage).
3. `persist_active_vault` does not store `Data<'_>` across the `vault_session` lock scope; it stores owned `Vec<u8>` instead. ([Docs.rs][1])
4. No new public APIs are introduced in `attachments_service.rs` just to expose `require_logged_in`.

