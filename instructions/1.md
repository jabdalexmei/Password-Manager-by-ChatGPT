## Technical Specification (EN): Save Password History (backend + UI like legacy version, no limits)

### Goal

Implement **Password History** for Data Cards:

* Automatically save **previous password values** whenever the password changes (including when user clears the password).
* Provide a UI dialog similar to the legacy app:

  * List entries with timestamp
  * Actions: **Copy**, **Show/Hide** (global toggle)
  * Action: **Clear history** (with confirmation)
* **No “Restore”** feature.
* **No history limits** (store all entries).

### Scope

Frontend + Backend.

### Base version

Apply on the provided updated base archive (current working project).

---

# A) Backend (Rust / Tauri)

## A1) Database schema

### File

`src-tauri/src/data/sqlite/schema.sql`

### Change

Add a new table for password history:

```sql
CREATE TABLE IF NOT EXISTS datacard_password_history (
  id TEXT PRIMARY KEY NOT NULL,
  datacard_id TEXT NOT NULL,
  password_value TEXT NOT NULL,
  created_at TEXT NOT NULL,
  FOREIGN KEY(datacard_id) REFERENCES datacards(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_datacard_password_history_datacard_id
  ON datacard_password_history(datacard_id);
```

### Notes

* `password_value` stores the **previous** password value.
* Keep type `TEXT` to match the existing `datacards.password_value` storage format.
* Deletion of a datacard must cascade-delete its history.

### Acceptance

* New DB can be created with the new table.
* Existing profiles migrate cleanly (see A2).

---

## A2) DB migration / schema versioning

### Files (choose the project’s existing migration mechanism)

Search and update whichever file currently controls schema init/migrations:

* `src-tauri/src/data/sqlite/init.rs` (likely)
* `src-tauri/src/data/sqlite/schema.rs` or similar (if present)
* any `schema_version` logic (if present)

### Requirement

If the project uses a schema version:

* Increment schema version
* Add migration step to create the new table + index on existing DBs.

If the project relies on “create-if-not-exists” on startup:

* Ensure the `CREATE TABLE IF NOT EXISTS datacard_password_history` statements are executed during init.

### Acceptance

* Existing vaults open without errors.
* New table exists after first run.

---

## A3) Repository functions (SQLite)

### File

`src-tauri/src/data/sqlite/repo_impl.rs`

### Add new functions

1. Insert history record:

```rust
pub fn insert_password_history(
  state: &AppState,
  profile_id: &str,
  datacard_id: &str,
  password_value: &str,
  created_at: &str
) -> Result<()>;
```

2. List history for datacard (descending by time):

```rust
pub fn list_password_history(
  state: &AppState,
  profile_id: &str,
  datacard_id: &str
) -> Result<Vec<PasswordHistoryRow>>;
```

Where `PasswordHistoryRow` is a new struct in the same module (or a shared types module):

```rust
pub struct PasswordHistoryRow {
  pub id: String,
  pub datacard_id: String,
  pub password_value: String,
  pub created_at: String,
}
```

3. Clear history for datacard:

```rust
pub fn clear_password_history(
  state: &AppState,
  profile_id: &str,
  datacard_id: &str
) -> Result<usize>;
```

Return deleted rows count (`usize`).

### SQL behavior

* `list_password_history`: `ORDER BY created_at DESC`
* `clear_password_history`: `DELETE FROM datacard_password_history WHERE datacard_id = ?`

### Acceptance

* Insert/list/clear work on a test DB.
* Cascade delete works when datacard is deleted/purged.

---

## A4) Hook history saving into datacard update

### File

Where datacard update is performed (likely in):

* `src-tauri/src/services/datacards_service.rs` **or**
* `src-tauri/src/services/vault_service.rs` **or**
* the Tauri command handler that updates a datacard (search for “update_datacard”)

### Requirement

Before updating the datacard:

1. Load current datacard from DB (existing repo call).
2. Compare old vs new password:

   * Let `old_pw = current.password_value` (string or option)
   * Let `new_pw = payload.password_value` (string or option)

Define:

* `old_trim = old_pw.trim()`
* `new_trim = new_pw.trim()`

Save history entry **if and only if**:

* `old_trim.len() > 0` AND `old_trim != new_trim`

This includes the “user cleared password” case (new is empty → history still records old).

3. If condition matches:

* Generate UUID for history row
* `created_at` = current timestamp in RFC3339 (use existing time utility in the project; do not introduce a new crate unless necessary)
* Call `repo_impl::insert_password_history(...)` with `password_value = old_pw` (the previous password).

4. Proceed with the normal update operation.

### Acceptance

* Editing a card with password change writes one history row containing the previous password.
* Clearing password writes one history row containing the previous password.
* Editing other fields without changing password does not write history.

---

## A5) Tauri commands for frontend

### File

Add to an existing commands module or create a dedicated one:

* `src-tauri/src/commands/password_history.rs` (recommended)
  OR extend existing vault/datacard command module.

### Add commands

1. Get history:

```rust
#[tauri::command]
pub fn get_datacard_password_history(app: tauri::AppHandle, datacard_id: String) -> Result<Vec<PasswordHistoryRowDto>>;
```

2. Clear history:

```rust
#[tauri::command]
pub fn clear_datacard_password_history(app: tauri::AppHandle, datacard_id: String) -> Result<()>;
```

DTO:

```rust
pub struct PasswordHistoryRowDto {
  pub id: String,
  pub password_value: String,
  pub created_at: String,
}
```

### Notes

* Use the same session/auth guard as other vault operations (require logged-in profile).
* Return values must be plain strings to match existing frontend pattern.

### Acceptance

* Frontend can invoke both commands successfully.
* Clear returns success and list becomes empty.

---

# B) Frontend (React)

## B1) API wrapper

### File

Where existing Tauri invoke wrappers live (search for `invoke(` usage), likely:

* `src/lib/tauri.ts` OR `src/features/Vault/api.ts` OR similar

### Add functions

```ts
export async function getPasswordHistory(datacardId: string): Promise<Array<{ id: string; passwordValue: string; createdAt: string }>>;

export async function clearPasswordHistory(datacardId: string): Promise<void>;
```

Map Tauri fields:

* backend `password_value` → frontend `passwordValue`
* backend `created_at` → frontend `createdAt`

---

## B2) Add Password History button in Information password actions

### File

`src/features/Vault/components/Details/Details.tsx`

### Requirement

In the password field action buttons row (where Copy / Eye actions are), add a new icon-button that opens the history dialog:

* Icon should match legacy style (rotate/history). Use your centralized lucide semantic icons module (if already implemented) or directly from current icons system.

Button requirements:

* `className="icon-button"`
* `aria-label` = translation key (add new key `action.passwordHistory` or similar)
* Clicking opens the dialog for the currently selected datacard.

---

## B3) Implement PasswordHistoryDialog (UI like legacy)

### New file

`src/features/Vault/components/modals/PasswordHistoryDialog.tsx`

### UI rules (match existing dialogs)

Use existing dialog rendering pattern in the project (same structure as other modals):

* `.dialog`
* `.dialog-header`
* `.dialog-body`
* `.dialog-footer`

### Behavior

* Props:

```ts
type PasswordHistoryDialogProps = {
  isOpen: boolean;
  datacardId: string;
  onClose: () => void;
};
```

* On open:

  * call `getPasswordHistory(datacardId)`
  * store list in state

* Provide a global toggle:

  * `showPasswords: boolean`
  * Default `false`
  * If `false`, render passwords masked (e.g., `"••••••••"`)
  * If `true`, render plain `passwordValue`

* Each row shows:

  * formatted timestamp (use existing formatting used for `updatedAtLabel` or a shared date formatter)
  * password display (masked or plain)
  * Copy icon button (copies **plain passwordValue** regardless of show/hide state)

* Clear history:

  * “Clear history” button triggers existing `ConfirmDialog` pattern
  * On confirm: call `clearPasswordHistory(datacardId)` then reload list (or set empty)

### Empty state

If history list is empty:

* Show a friendly empty label: “No password history yet” (new i18n key).

---

## B4) Wire dialog into Details

### File

`src/features/Vault/components/Details/Details.tsx`

### Requirement

* Maintain local state for opening/closing dialog.
* Render `<PasswordHistoryDialog ... />` when `isOpen === true`.

---

# C) i18n additions

### Files

Where translation keys exist (search `label.*` / `action.*` usage), likely:

* `src/lib/i18n/*` or JSON translation files.

### Add keys

* `action.passwordHistory` = “Password history”
* `dialog.passwordHistoryTitle` = “Password history”
* `label.passwordHistoryEmpty` = “No password history yet”
* `action.clearHistory` = “Clear history”
* `dialog.clearHistoryConfirm` = “Clear password history?”

(Adjust exact key naming to match existing conventions.)

---

# D) Acceptance Criteria / QA

1. Change password in Edit card:

   * old password is saved into history.
2. Clear password (set empty) and save:

   * previous password is saved into history.
3. Open Password History dialog:

   * shows entries sorted newest first.
   * default masked view; toggle reveals all.
   * copy copies the correct password.
4. Clear history:

   * confirmation required.
   * after clearing, dialog shows empty state.
5. Deleting/purging a datacard removes its history (cascade).
