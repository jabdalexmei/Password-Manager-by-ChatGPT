
# Technical Specification (EN): Backup/Restore hardening (Windows-only) — TempDir lifetime, ZipSlip protection, attachment enumeration, streaming IO, concurrency guard

## 0) Scope

Harden the existing backup/restore implementation to prevent:

1. **Passwordless backup producing missing/empty vault snapshot** due to temporary directory cleanup.
2. **ZipSlip / path traversal** during restore that can write files outside the intended extraction directory on Windows.
3. **Silent partial backups** when attachments enumeration fails.
4. **High memory usage** due to reading entire files into RAM during zip create/restore.
5. **Race conditions** between backup and restore operations.

This TS applies to **Windows only**. No cross-platform behavior is required.

## 1) Affected files

* `src-tauri/src/services/backup_service.rs`
* (If present) `src-tauri/src/state.rs` or wherever the backup mutex/guard is stored.

---

## 2) P0 — Fix passwordless vault snapshot lifetime (TempDir drop deletes snapshot)

### Problem

The snapshot vault file is created inside a `tempfile::TempDir` and only a `PathBuf` is returned. When the function returns, `TempDir` is dropped and the directory (and snapshot `vault.db`) is automatically deleted. `tempfile` explicitly states the directory is deleted when `TempDir` is dropped. ([Docs.rs][1])

### Required change

**File:** `src-tauri/src/services/backup_service.rs`

1. Extend the structure that represents the snapshot (example name: `BackupSource`) to retain ownership of the temp directory until the zip archive is completed.

**Add field** (exact field name required):

```rust
_temp_dir: Option<tempfile::TempDir>,
```

2. In the function that creates the passwordless snapshot (example: `build_backup_source` or equivalent), when you create `TempDir`, store it into the returned `BackupSource`:

**Before**: returning `vault_path` only (and dropping `temp_dir` at end of scope)

**After**: return:

```rust
BackupSource {
  vault_path,
  attachments_path,
  // …
  _temp_dir: Some(temp_dir),
}
```

3. For password-protected mode (encrypted blob copy), set `_temp_dir: None`.

### Acceptance

* Creating a passwordless backup always includes `vault.db` in the resulting archive (no “file not found” and no empty/broken vault).
* No leftover temp directories remain after successful/failed backup (TempDir must still auto-clean once `BackupSource` drops after zip is done).

---

## 3) P0 — Prevent ZipSlip / path traversal during restore (Windows)

### Problem

Current restore logic only checks if the entry path string contains `".."`. This is insufficient for Windows because malicious zip entries can use absolute paths, drive prefixes, UNC paths, or special prefixes that cause writes outside the extraction directory. ZipSlip is a known archive extraction vulnerability. ([security.snyk.io][2])

Additionally, Rust path joining/pushing semantics on Windows can **replace** the base path when the appended path is absolute or has certain prefixes. The standard docs explicitly describe that pushing an absolute path replaces the current path, including Windows-specific prefix/root rules. ([doc.rust-lang.org][3])

### Required change

**File:** `src-tauri/src/services/backup_service.rs`
**Function:** restore extractor (`backup_restore` or equivalent)

Implement strict entry path validation using `std::path::Component`.

#### 3.1 Create a helper function

Add the following helper in `backup_service.rs` (exact logic, do not weaken):

```rust
use std::path::{Path, Component};

fn validate_zip_entry_rel_path_windows(rel: &Path) -> bool {
    // Must not be absolute
    if rel.is_absolute() {
        return false;
    }

    // Must not contain Windows prefix (C:, \\?\ , UNC), root dir, or parent dir
    for c in rel.components() {
        match c {
            Component::Prefix(_) => return false, // Windows drive/UNC/verbatim prefixes
            Component::RootDir => return false,   // leading '\'
            Component::ParentDir => return false, // '..'
            Component::CurDir => {}               // allow '.' (optional; may also reject)
            Component::Normal(_) => {}
        }
    }

    true
}
```

#### 3.2 Apply validation before extraction

For every file entry from the zip:

* Convert the entry name to `Path` (must not be treated purely as string).
* Reject the entry if `validate_zip_entry_rel_path_windows(path) == false`.
* Only then compute `target_path = temp_dir.path().join(path)` and write the extracted file.

**Hard requirement:** Do not rely on substring checks like `contains("..")`.

### Acceptance

* Restore rejects malicious archives with absolute paths, drive prefixes, UNC paths, `..`, and root-leading paths (e.g. `\Windows\...`).
* Restore never writes outside the temporary extraction directory on Windows.

---

## 4) P1 — Do not silently skip attachments on enumeration errors

### Problem

`walkdir::WalkDir` iterator yields `Result<DirEntry, walkdir::Error>` items; errors are part of the iteration stream. ([Docs.rs][4])
If code uses `.filter_map(|e| e.ok())`, enumeration errors are silently ignored, producing partial backups without informing the user.

### Required change

**File:** `src-tauri/src/services/backup_service.rs`
**Function:** archive creation (`create_archive` or equivalent)

Replace any attachment iteration that drops errors with a fail-fast approach:

**Required iteration pattern**:

```rust
for entry_res in WalkDir::new(&source.attachments_path).into_iter() {
    let entry = entry_res.map_err(|_| ErrorCodeString::new("BACKUP_ATTACHMENTS_ENUM_FAILED"))?;
    if entry.file_type().is_file() {
        // add to zip
    }
}
```

### Acceptance

* If any attachment path cannot be read/enumerated, backup fails with `BACKUP_ATTACHMENTS_ENUM_FAILED`.
* No “successful” backup is produced when attachments are partially missing.

---

## 5) P1 — Stream files into ZIP / out of ZIP (avoid RAM spikes)

### Problem

Using `fs::read(...)` / `read_to_end(...)` loads whole files into memory. With many/large attachments, memory usage can spike.

### Required change

**File:** `src-tauri/src/services/backup_service.rs`

#### 5.1 ZIP write: stream file

When adding a file to zip, write in chunks using `std::io::copy` or manual buffered loop (64KB–1MB chunk size). Compute SHA-256 incrementally while streaming.

**Required approach (exact behavior):**

* Open input file: `File::open(...)`
* Create a `BufReader`
* Create a `sha2::Sha256` hasher and call `update()` per chunk
* Write to zip entry writer per chunk
* Do NOT allocate `Vec<u8>` of the entire file.

#### 5.2 ZIP read: stream extraction

During restore extraction:

* Use a buffered loop from zip file entry reader into output file.
* Update SHA-256 per chunk.
* Compare to manifest hash.

### Acceptance

* Creating/restoring backups with large attachments does not cause large memory spikes (no full-file reads).

---

## 6) P1 — Make backup and restore mutually exclusive (single guard)

### Problem

If there is a mutex/guard preventing concurrent backups, restore must also acquire it. Otherwise auto-backup can run while restore replaces files, causing file locks and corruption.

### Required change

**File:** `src-tauri/src/services/backup_service.rs`

1. Ensure the same guard used by backup creation is also acquired by restore at the very beginning.
2. If restore cannot acquire guard (backup in progress), return `BACKUP_ALREADY_RUNNING` (or a dedicated code `BACKUP_RESTORE_BLOCKED`).

### Acceptance

* Cannot run restore while a backup is running, and cannot start a backup while restore is running.
* No “file in use” errors caused by backup/restore overlap.

---

## 7) Regression checks

### Required manual tests (Windows)

1. Passwordless profile:

   * Create backup while actively modifying vault.
   * Confirm archive contains `vault.db` and restore produces a working vault.
2. Restore ZipSlip attempt:

   * Use a test zip containing entries like:

     * `C:\Temp\evil.txt`
     * `\\?\C:\Temp\evil.txt`
     * `..\..\evil.txt`
     * `\Windows\Temp\evil.txt`
   * Restore must fail with `BACKUP_ARCHIVE_INVALID` or `BACKUP_RESTORE_FAILED`.
3. Attachments enumeration:

   * Make one attachment unreadable (permissions/lock) → backup must fail with `BACKUP_ATTACHMENTS_ENUM_FAILED`.
4. Large attachments:

   * Restore/backup works without excessive RAM usage.
5. Concurrency:

   * Trigger auto-backup, then click Restore immediately → restore must be blocked cleanly.

---

## 8) Notes (do not change)

* Keep ZIP entries in **Stored (no compression)** mode.
* Keep SQLite Online Backup API usage for passwordless mode; `WalkDir` behavior must be handled according to its `Result`-yielding iterator design. ([Docs.rs][4])
* Keep path handling consistent with Rust standard path semantics on Windows. ([doc.rust-lang.org][3])

