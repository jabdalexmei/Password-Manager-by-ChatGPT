## Technical Specification (EN): Encrypted ZIP Backup (KeePass-like), Restore / Import-as-new, no profile_id binding

### Goal

Implement a portable **single-file backup** workflow similar in UX to KeePassXC:

* Backup is **one `.zip` file**.
* Backup can be protected by:

  * default: **current profile password**, OR
  * optional: **custom backup password** (set at export time).
* Backup is **NOT bound to `profile_id`**.
* Import flow:

  * user selects backup `.zip`,
  * enters backup password,
  * chooses **Restore** (into current unlocked profile) OR **Import as new profile**.
* **Restore is allowed only when the current profile is unlocked**.
* **Import as new profile** creates a new profile whose password is **the same as the backup password**.

### Non-goals

* No “merge” between vaults.
* No background sync.
* No backward compatibility with old backups unless explicitly implemented later.

---

# A) Backup file format

## A1) File extension and mime

* Output file uses `.zip` extension (user-visible).
* Internally, it is an encrypted container (see A2). The `.zip` is a user-facing choice.

## A2) Container structure

Backup file is a single binary file consisting of:

1. **Header (plaintext JSON, small, required to attempt password validation)**
2. **Encrypted payload blob** (AEAD)

### Header JSON (example fields)

```json
{
  "format": "pm_backup",
  "version": 1,
  "created_at": "RFC3339",
  "kdf": {
    "type": "argon2id",
    "params": { "m": 19456, "t": 2, "p": 1 },
    "salt_b64": "..."
  },
  "crypto": {
    "aead": "xchacha20poly1305",
    "nonce_b64": "..."
  },
  "key_check_b64": "...",
  "payload_size": 1234567
}
```

### Encrypted payload (after decrypt)

Payload is a **ZIP archive** (bytes) with the following fixed paths:

* `manifest.json`
* `vault/`

  * `vault.db`  *(as stored on disk for the profile; if already “protected/encrypted”, keep it as-is)*
  * `attachments/` *(the entire attachments tree as stored on disk)*

`manifest.json` must include:

* `exported_from_app_version`
* `exported_at`
* `has_attachments`
* optional: `vault_display_name` (for UI)
* optional: counts (cards/attachments)

**Important:** No `profile_id` is stored in any field used by crypto decisions. If a profile id is included in manifest for informational purposes, it must not be required to restore/import.

---

# B) Cryptography

## B1) Password -> key derivation

Use Argon2id with the project’s canonical fixed params (same as your existing plan):

* m/t/p fixed
* unique random salt per backup

Derive a 32-byte key: `backup_key`.

## B2) Password validation (“key_check”)

Compute `key_check` using the derived key (fast verification):

* Store `key_check_b64` in header.
* On import, derive key and verify `key_check` before decrypting payload.

## B3) Payload encryption

Encrypt the payload ZIP bytes using:

* AEAD XChaCha20-Poly1305
* Random nonce stored in header
* AAD (associated data): canonical string derived from header fields `format/version/created_at` (excluding `nonce` and `payload_size`).

Output file layout:

* `[u32 header_len][header_json_bytes][ciphertext_bytes]`

---

# C) Backend (Tauri / Rust)

## C1) New services module

Create:

* `src-tauri/src/services/backup_service.rs`

Responsibilities:

* export: collect vault files, zip them, encrypt to output path
* import: read backup file, validate password, decrypt, unzip to target directory

## C2) Backup export command

Add command:

* `export_backup(app: AppHandle, output_path: String, mode: ExportBackupMode) -> Result<()>`

Where `ExportBackupMode` supports:

* `UseProfilePassword`
* `UseCustomPassword { password: String }`

Rules:

* Requires user to be logged-in/unlocked **only to access storage paths/profile context**.
* Source paths:

  * profile vault db path (existing helper)
  * profile attachments root path (existing helper)
* Zip content must include `vault.db` and `attachments/` (if exists).
* Encrypt zip bytes to `output_path`.
* On success, update “last export directory” in user settings (if requested by frontend).

## C3) Backup import commands

### 1) Inspect backup (optional but recommended for UI)

`inspect_backup(app: AppHandle, backup_path: String) -> Result<BackupMeta>`

* reads header only (no password needed)
* returns minimal metadata: created_at, version, payload_size

### 2) Import backup (decrypt + unzip to temp)

`decrypt_backup_to_temp(app: AppHandle, backup_path: String, password: String) -> Result<TempImportId>`

* validates password via key_check
* decrypts payload
* unzips into temp folder (new unique temp id)
* returns `TempImportId`

Temp structure:

* `temp/imports/<id>/vault/vault.db`
* `temp/imports/<id>/vault/attachments/...`
* `temp/imports/<id>/manifest.json`

### 3) Finalize: Restore into current profile

`finalize_restore(app: AppHandle, temp_import_id: String) -> Result<()>`

Rules:

* **Allowed only when a profile is unlocked / active session exists.**
* Replace current profile’s vault storage:

  * overwrite `vault.db`
  * overwrite attachments directory (delete current attachments then copy imported)
* After restore:

  * clear previews (existing previews cleanup)
  * force reload vault data in frontend (frontend can call refresh/list again)
* Delete temp import folder

### 4) Finalize: Import as new profile

`finalize_import_as_new_profile(app: AppHandle, temp_import_id: String, new_profile_name: String, password: String) -> Result<NewProfileId>`

Rules:

* Creates a new profile entry in registry using `new_profile_name`.
* The new profile password must be **the same as the backup password**:

  * i.e., create profile credentials/verifier using the supplied `password`.
* Copy imported `vault.db` and `attachments` into the new profile directory.
* Delete temp import folder
* Return new profile id.

**No use of old profile_id from backup.** A new id is generated.

## C4) File operations must be atomic/safe

* Always write into temp and then rename into place.
* For restore:

  * copy imported db to `vault.db.new`, then rename to `vault.db`
  * for attachments, use `attachments_new/` then swap directories

## C5) Error codes

Return user-friendly error codes already used by frontend (similar to `DB_QUERY_FAILED` etc.):

* `BACKUP_INVALID_FORMAT`
* `BACKUP_UNSUPPORTED_VERSION`
* `BACKUP_PASSWORD_INVALID`
* `BACKUP_DECRYPT_FAILED`
* `BACKUP_UNZIP_FAILED`
* `BACKUP_IO_FAILED`
* `BACKUP_RESTORE_REQUIRES_UNLOCKED_PROFILE`

---

# D) Frontend (React)

## D1) Export UI (Header buttons)

File:

* `src/features/Vault/components/Header/VaultHeader.tsx`

Implement Export button behavior:

* Click Export opens modal `ExportBackupDialog`
* Modal fields:

  * radio:

    * “Use profile password” (default)
    * “Use custom backup password”
  * if custom selected:

    * Password input + Confirm input with validation
  * “Remember export folder” checkbox
* “Save…” triggers `dialog.save()` (Tauri v2 dialog plugin) with default directory:

  * from user settings `default_export_dir` or `last_export_dir`
* Call backend `export_backup` with path + mode.
* On success: toast “Backup exported”.

## D2) Import UI

Import button behavior:

* Click Import opens OS file picker (`dialog.open`) filtered for `.zip`
* After selecting file:

  * open modal `ImportBackupDialog` asking for backup password
  * show two buttons:

    * **Restore** (enabled only if profile is unlocked / session exists)
    * **Import as new profile**
* Flow:

  1. Call `decrypt_backup_to_temp(backup_path, password)`
  2. If user clicks Restore:

     * call `finalize_restore(temp_id)`
  3. If user clicks Import as new profile:

     * ask for `new_profile_name` (input in the same modal or next step)
     * call `finalize_import_as_new_profile(temp_id, new_profile_name, password)`

## D3) Restore button availability rule

Restore button must be disabled unless:

* current profile is active and vault is unlocked
  Use the existing view model/session state (same logic used for protected actions).

If disabled, show hint text:

* “Restore is available only when the profile is unlocked.”

## D4) Settings persistence for export path

Store:

* `last_export_dir` and/or `default_export_dir` in `user_settings.json`
  Use existing settings service:
* `src-tauri/src/services/settings_service.rs`
* `src-tauri/src/data/settings/...`
  Frontend should update the setting when “Remember export folder” is checked.

---

# E) Acceptance Criteria

## Export

1. Export produces a single `.zip` file.
2. If “use profile password” selected, backup password equals current profile password.
3. If “custom password” selected, backup requires that password to import.
4. Export remembers default directory if user requested.

## Import

1. Import prompts for password; wrong password fails with `BACKUP_PASSWORD_INVALID`.
2. After decrypting, user can choose:

   * Restore (only if profile unlocked)
   * Import as new profile
3. Restore overwrites current profile vault data and attachments.
4. Import as new profile creates a new profile with password = backup password and loads the imported data.

## No profile_id binding

* A backup created from one profile can be imported on another machine or into a new profile without requiring the original profile id.

---

# F) Manual Test Plan

1. Create profile A, add card + attachments, export (profile password).
2. Import file:

   * into unlocked profile A → Restore works, data matches.
   * into app with no profile → Import as new profile creates profile and opens with same password.
3. Export with custom backup password:

   * Import with wrong password fails.
   * Import with correct password succeeds.
4. Verify attachments restored.
5. Verify no manual `<svg>` or UI regressions in header buttons.
