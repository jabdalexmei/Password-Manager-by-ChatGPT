
# TS (EN): Fix `OpenClipboard` argument type + remove invalid placeholder + validate clipboard auto-clean integration

## 1) Fix build error: `OpenClipboard(0)` type mismatch

### Problem

`windows-sys` defines `OpenClipboard(HWND)` where `HWND` is a raw pointer type (`*mut c_void`). Passing `0` (usize) causes `E0308`. Rust compiler explicitly suggests `std::ptr::null_mut()`. ([Microsoft Learn][1])

### File

`src-tauri/src/services/clipboard_service.rs`

### Required change

#### Before (current)

```rust
let opened = OpenClipboard(0);
```

#### After (exact)

Add import at top (Windows-only section is fine):

```rust
#[cfg(target_os = "windows")]
use std::ptr;
```

Replace call:

```rust
let opened = OpenClipboard(ptr::null_mut());
```

**Why this is correct:** WinAPI documentation allows `OpenClipboard(NULL)` (with caveat about clipboard owner when later calling `SetClipboardData`, which we do not). We only call `EmptyClipboard`, so this is safe for “wipe”. ([Microsoft Learn][1])

---

## 2) Remove invalid placeholder `...` in clipboard_service.rs

### Problem

Your current file contains a literal line `...` around line ~29 (between error return and `EmptyClipboard()`), which is invalid Rust and is definitely “мертвый/мусорный” код.

### File

`src-tauri/src/services/clipboard_service.rs`

### Required change

Delete the line:

```rust
...
```

No replacement needed — it must not exist.

---

## 3) Make CloseClipboard guaranteed (no leaks on early returns)

### Why

Microsoft docs: after every successful `OpenClipboard`, you must call `CloseClipboard`. ([Microsoft Learn][1])
Right now you call `CloseClipboard()` after `EmptyClipboard()`, but if you ever extend logic, it’s safer to guarantee it even on error paths.

### File

`src-tauri/src/services/clipboard_service.rs`

### Replace the function with this exact implementation

```rust
#[cfg(target_os = "windows")]
use std::ptr;

#[cfg(target_os = "windows")]
use std::time::Duration;

#[cfg(target_os = "windows")]
use windows_sys::Win32::Foundation::GetLastError;

#[cfg(target_os = "windows")]
use windows_sys::Win32::System::DataExchange::{CloseClipboard, EmptyClipboard, OpenClipboard};

#[cfg(target_os = "windows")]
struct ClipboardGuard;

#[cfg(target_os = "windows")]
impl Drop for ClipboardGuard {
    fn drop(&mut self) {
        unsafe {
            CloseClipboard();
        }
    }
}

/// Clears the entire Windows clipboard (all formats).
/// Uses OpenClipboard -> EmptyClipboard -> CloseClipboard.
/// Retries because clipboard may be temporarily locked by other processes.
#[cfg(target_os = "windows")]
pub fn clear_clipboard_all() -> Result<(), String> {
    const ATTEMPTS: usize = 10;
    const SLEEP_MS: u64 = 25;

    for attempt in 0..ATTEMPTS {
        unsafe {
            let opened = OpenClipboard(ptr::null_mut());
            if opened == 0 {
                if attempt + 1 < ATTEMPTS {
                    std::thread::sleep(Duration::from_millis(SLEEP_MS));
                    continue;
                }
                let err = GetLastError();
                return Err(format!("OPENCLIPBOARD_FAILED ({})", err));
            }

            // Ensure CloseClipboard is called no matter what
            let _guard = ClipboardGuard;

            let emptied = EmptyClipboard();
            if emptied == 0 {
                let err = GetLastError();
                return Err(format!("EMPTYCLIPBOARD_FAILED ({})", err));
            }

            return Ok(());
        }
    }

    Err("CLIPBOARD_BUSY".to_string())
}
```

This matches WinAPI rules (Open → Empty → Close; Close always after Open). ([Microsoft Learn][1])

---

# Audit: Is clipboard auto delete/clean implemented correctly in your archive?

## ✅ Что сделано правильно

### A) Нативная очистка через WinAPI

Команда `clipboard_clear_all` вызывает `EmptyClipboard`, что реально очищает clipboard “полностью”, а не “пустой строкой”. ([Microsoft Learn][2])

### B) Фронт больше не делает `writeText('')`

В проекте нет прямых `navigator.clipboard.writeText('')` для очистки — используется `clipboardClearAll()`.

### C) У тебя есть важный fallback

В основных местах (Details/BankCards/History/DataCards) логика уже такая:

* пробуем `readText()`
* если совпадает с “последним скопированным” → wipe
* если `readText()` падает → всё равно делаем wipe

Это правильно, потому что чтение clipboard часто ограничено разрешениями/фокусом/активацией. ([MDN Web Docs][3])

## ⚠️ Что нужно обязательно поправить

* `OpenClipboard(0)` → `OpenClipboard(ptr::null_mut())` (иначе не соберётся)
* удалить строку `...` (иначе файл невалиден)
* лучше гарантировать `CloseClipboard` (guard) — по ТЗ выше

---

# Dead / unused code (по текущему архиву)

* Фронтового `autoLockCleanup()` и invoke-команды под него в архиве **уже нет** (мертвый код убран).
* `security_service::auto_lock_cleanup` остаётся и реально используется из `src-tauri/src/main.rs` (это не мертвяк).

