
Это уже чисто “Rust lifetime + spawn_blocking” ловушка: ты **таскаешь `tauri::State<'_ , Arc<AppState>>` внутрь `spawn_blocking`**, а `spawn_blocking` требует, чтобы всё, что он захватывает, было **`'static`**.
`State<'_ , ...>` — это **заимствование**, оно не `'static`, поэтому и ошибка: *borrowed data escapes outside of function*.

Правильный фикс “по канону” такой:

* **Никогда не передавать `State<...>` в `spawn_blocking`**
* Внутри команды нужно вытащить **Arc<AppState>** (он `'static`) и передать уже его.

Ниже — точное ТЗ, что и где менять.

---

# SPEC — FIX-E0521-SPAWN-BLOCKING-STATE-01

## Goal

Fix Rust build errors `E0521 borrowed data escapes outside of function` by removing `tauri::State<'_, Arc<AppState>>` from `spawn_blocking` closures and passing `Arc<AppState>` instead.

## Root cause

`tauri::async_runtime::spawn_blocking` requires the closure and all captured values to be `'static`.
`State<'_, T>` contains a borrowed reference and is not `'static`.

## Scope (files)

* `src-tauri/src/commands/datacards.rs`
* `src-tauri/src/commands/folders.rs`
* `src-tauri/src/commands/settings.rs`
  (and any other `src-tauri/src/commands/*.rs` that uses `spawn_blocking` and captures `State`)

---

## Part A — Refactor services to accept `&Arc<AppState>` instead of `&State<Arc<AppState>>`

### A1) Update service signatures (mandatory)

Find these service files and change signatures:

* `src-tauri/src/services/datacards_service.rs`
* `src-tauri/src/services/folders_service.rs`
* `src-tauri/src/services/settings_service.rs` (or wherever settings service lives)

**Before (example)**

```rust
pub fn list_datacards(state: &State<Arc<AppState>>) -> Result<Vec<DataCard>>
```

**After**

```rust
pub fn list_datacards(state: &Arc<AppState>) -> Result<Vec<DataCard>>
```

Apply the same rule to all service functions currently taking:

* `state: &State<Arc<AppState>>`
* or `state: State<Arc<AppState>>`

Convert to:

* `state: &Arc<AppState>`

### A2) Update internal helper `require_logged_in`

In each service file where you have something like:

```rust
fn require_logged_in(state: &State<Arc<AppState>>) -> Result<String>
```

Change to:

```rust
fn require_logged_in(state: &Arc<AppState>) -> Result<String>
```

Then inside, replace `state.active_profile...` etc as-is (Arc<AppState> has same fields).

---

## Part B — Fix commands: extract `Arc<AppState>` and pass it into spawn_blocking

### B1) Commands must clone Arc, NOT clone State

In every command function:

* Keep parameter type: `state: State<'_, Arc<AppState>>`
* Immediately extract Arc:

```rust
let app = state.inner().clone();
```

Then in spawn_blocking closure, call the service with `&app`.

### B2) Exact edits for each command file

#### File: `src-tauri/src/commands/datacards.rs`

**Before (wrong pattern)**

```rust
pub async fn list_datacards(state: State<'_, Arc<AppState>>) -> Result<Vec<DataCard>> {
    let state = state.clone();
    tauri::async_runtime::spawn_blocking(move || datacards_service::list_datacards(&state))
        .await
        ...
}
```

**After (required pattern)**

```rust
pub async fn list_datacards(state: State<'_, Arc<AppState>>) -> Result<Vec<DataCard>> {
    let app = state.inner().clone();
    tauri::async_runtime::spawn_blocking(move || datacards_service::list_datacards(&app))
        .await
        .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
}
```

Apply the same transformation to all commands in the file:

* `get_datacard(id, state)` → clone `app`, move `(id, app)` into closure, call `datacards_service::get_datacard(id, &app)`
* `create_datacard(input, state)` → call `...create_datacard(input, &app)`
* `update_datacard(input, state)` → call `...update_datacard(input, &app)`
* `move_datacard_to_folder(input, state)` → call `...move_datacard_to_folder(input, &app)`
* `delete_datacard(id, state)` → call `...delete_datacard(id, &app)`
* `list_deleted_datacards(state)` → call `...list_deleted_datacards(&app)`
* `restore_datacard(id, state)` → call `...restore_datacard(id, &app)`
* `purge_datacard(id, state)` → call `...purge_datacard(id, &app)`
* summary commands: `list_datacards_summary`, `list_deleted_datacards_summary` → same rule

#### File: `src-tauri/src/commands/folders.rs`

Same change:

* Replace all `let state = state.clone();` usage
* Extract `let app = state.inner().clone();`
* spawn_blocking closure calls `folders_service::...(…, &app)`

#### File: `src-tauri/src/commands/settings.rs`

Same:

* Extract `let app = state.inner().clone();`
* Call settings service with `&app`
* Important: do NOT pass `&state` into `spawn_blocking`

---

## Part C — Delete/Remove wrong code patterns (mandatory)

### C1) Remove these patterns everywhere in commands

Developer must delete all occurrences in `src-tauri/src/commands/*.rs`:

1. Capturing `State` into spawn_blocking:

```rust
let state = state.clone();
spawn_blocking(move || ...(&state) ...)
```

2. Passing `State` reference into service:

```rust
service_fn(&state)
```

Instead, only pass `&Arc<AppState>`:

```rust
service_fn(&app)
```

---

## Acceptance Criteria

1. `cargo build` succeeds with no `E0521`.
2. No command captures `tauri::State` inside `spawn_blocking` closures.
3. Services accept `&Arc<AppState>` (not `&State<Arc<AppState>>`).
4. Runtime behavior remains identical (only refactor of state passing).

---

## Quick verification command

From `src-tauri/`:

```bash
cargo clean
cargo build
```

---

Если тебе нужно совсем “без творчества” для разработчика: можно прямо добавить правило в ревью — *в `spawn_blocking` разрешено захватывать только owned types (`Arc`, `String`, `Vec`, `Input`), никаких `&T` и никаких `State<'_ , T>`.*
