
## 1) Create/Edit Data Card: выбор папки (после блока Note)

### Сейчас

* В форме создания/редактирования **нет UI-поля папки**, хотя `folderId` уже есть в состоянии формы и в backend input.
* Фактически карта попадает в папку только через `defaultFolderId`.

### Нужно

* В модалке **Create data card** и **Edit data card** добавить поле **Folder**.
* Расположение: **сразу после поля Note**, перед Tags.
* UX: **ручной поиск + dropdown** (алфавитный список созданных папок).

  * Реализация: `input` + `datalist` (встроенный dropdown), options отсортированы по алфавиту.
  * Папки показывать **только пользовательские** (`isSystem === false`).
  * Должна быть возможность очистить выбор (карта “без папки”).

### Правки по фронту

#### 1.1. Расширить форму: добавить `folderName`

**Файл:**
`src/features/Vault/components/DataCards/useDataCards.ts`

**Изменить тип `DataCardFormState`:**

* добавить поле:

```ts
folderName: string;
```

**Обновить инициализацию `initialForm`:**

* добавить `folderName: ''`.

**В `openCreateModal`:**

* вычислять `folderName` из `defaultFolderId`:

  * если `defaultFolderId !== null`, найти папку в `folders` и подставить `name`, иначе `''`.
* инициализировать `createForm.folderId = defaultFolderId`, `createForm.folderName = (найденное имя или '')`.

**В `openEditModal(card)`:**

* `folderId = card.folderId`
* `folderName = (имя папки по id из folders) || ''`

#### 1.2. Сделать `folderId` реально nullable (не превращать `null` в `''`)

**Файл:**
`src/features/Vault/components/DataCards/useDataCards.ts`

Сейчас `updateCreateField`/`updateEditField` приводят почти всё к `string` и при `null` кладут `''`:

```ts
(value ?? '') as string
```

**Нужно изменить логику для `folderId` и `folderName`:**

* `folderId` хранить строго как `string | null`
* `folderName` как `string`

**Конкретно:**

* В `updateCreateField` и `updateEditField` добавить ветки:

  * если `field === 'folderId'`: класть `value === '' ? null : (value as string | null)`
  * если `field === 'folderName'`: класть `(value ?? '') as string` **и синхронизировать `folderId`**:

    * если `folderName.trim() === ''` → `folderId = null`
    * иначе попытаться найти папку по имени среди `folders.filter(f=>!f.isSystem)`:

      * сравнение **case-insensitive** (`toLowerCase()`).
      * если нашли → `folderId = найденный.id`
      * если не нашли → `folderId = null`

#### 1.3. Валидация: если введено имя папки, но она не найдена — не сохранять

**Файл:**
`src/features/Vault/components/DataCards/useDataCards.ts`

В `submitCreate` и `submitEdit` перед вызовом `onCreate/onUpdate`:

* если `form.folderName.trim() !== ''` и `form.folderId === null`:

  * поставить ошибку валидации и **return**.

Добавить новый текст ошибки:
**Файл:** `src/i18n/English/DataCards.json`
ключ:

```json
"validation.folderNotFound": "Folder not found"
```

Показ ошибки рядом с Folder-полем (см. 1.4).

#### 1.4. Добавить UI-поле Folder после Note

**Файл:**
`src/features/Vault/components/DataCards/DataCards.tsx`

В `renderDialog(...)` сразу **после блока Note** вставить:

* `label`: `t('label.folder')`

* `input` (с dropdown):

  * `value={form.folderName}`
  * `onChange={(e) => onFieldChange('folderName', e.target.value)}`
  * `list="folder-options"`

* `datalist id="folder-options"`:

  * `options` из `viewModel.folders.filter(f=>!f.isSystem)` **в алфавитном порядке** (они уже отсортированы в `useVault`, но здесь всё равно оставить порядок как есть).
  * каждая опция: `value={folder.name}`

* Если есть ошибка `folderError` (см. ниже), показать `<div className="form-error">...`

Для этого в `useDataCards.ts` нужно добавить отдельное состояние ошибки, например:

* `createFolderError`, `editFolderError` (или универсально, но раздельно проще под текущую архитектуру `createError/editError`).

---

## 2) Confirm dialog при удалении карточки

### Сейчас

* Кнопка Delete в `Details` удаляет сразу (через `onDelete`), без подтверждения.

### Нужно

* При нажатии **Delete** показывать confirm dialog.
* Аналогично (рекомендовано, чтобы не было “случайных кликов”) — confirm и для **Purge** в Trash.

### Правки

#### 2.1. Встроить `ConfirmDialog` в Details

**Файл:**
`src/features/Vault/components/Details/Details.tsx`

* импортировать:

```ts
import { ConfirmDialog } from '../../../../components/ConfirmDialog';
```

* добавить состояния:

```ts
const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
const [purgeConfirmOpen, setPurgeConfirmOpen] = useState(false);
```

* заменить `onClick` у кнопок:

  * Delete → `setDeleteConfirmOpen(true)`
  * Purge → `setPurgeConfirmOpen(true)`

* отрендерить `ConfirmDialog`(и) внутри компонента (ниже action buttons), где:

  * `open={deleteConfirmOpen}`
  * `title/message/confirmLabel/cancelLabel` из i18n
  * `onConfirm` вызывает **текущий** обработчик удаления (то есть `detailActions.deleteCard()` / `detailActions.purgeCard()`), затем закрывает диалог.
  * `onCancel` закрывает диалог.

#### 2.2. Добавить тексты в i18n

**Файл:**
`src/i18n/English/Details.json`

Добавить ключи:

```json
"dialog.delete.title": "Delete card",
"dialog.delete.message": "Are you sure you want to delete this card?",
"dialog.delete.confirm": "Delete",
"dialog.purge.title": "Purge card",
"dialog.purge.message": "This will permanently delete the card. Continue?",
"dialog.purge.confirm": "Purge"
```

---

## 3) Information: пустые поля должны быть пустыми, не “—”

### Сейчас (найдено в коде)

В `Details.tsx` везде стоит fallback вида:

* `card.username || t('label.noValue')`, где `label.noValue = "—"`
* `folderName` подставляет `t('label.noFolder')`, тоже `"—"`
* `passwordDisplay` подставляет `"—"` если пароля нет

**Файл:**
`src/features/Vault/components/Details/Details.tsx`

### Нужно

* Если значение `null/''` → показывать **пустую строку**.
* Кнопки Copy/Reveal должны появляться только если реально есть значение (это уже обеспечивается `hasValue`, но его надо упростить).

### Правки

**Файл:** `src/features/Vault/components/Details/Details.tsx`

1. Упростить `hasValue`:

* убрать сравнение с `t('label.noValue')`
* оставить только `trim()` на пустоту.

2. Убрать все `|| t('label.noValue')`:

* заменить на `card.username ?? ''` (и аналогично для email/url/mobile/note/password)

3. `folderName`:

* если `card.folderId === null` → `''`
* если папка не найдена по id → `''`
* **не использовать** `t('label.noFolder')`

4. `passwordDisplay`:

* если `hasPassword === false` → `''` (а не `"—"`)

5. tags:

* если `card.tags.length === 0` → `''` (а не `"—"`)

---

## 4) Баг: Mark favorite пишет “favorite” в tags — так нельзя

### Сейчас (найдено)

1. Фронт:

* `useVault.toggleFavorite()` добавляет/удаляет `'favorite'` в `tags` и сохраняет через `updateCardAction`.
  **Файл:** `src/features/Vault/useVault.ts`
* `useDataCards.normalizeTags()` добавляет `'favorite'` в tags при `isFavorite`.
  **Файл:** `src/features/Vault/components/DataCards/useDataCards.ts`
* Фильтр Favorites построен по `tags.includes('favorite')`.
  **Файл:** `src/features/Vault/useVault.ts`
* UI “звёздочка” тоже местами завязана на теги.
  **Файл:** `src/features/Vault/components/DataCards/DataCards.tsx`, `src/features/Vault/types/mappers.ts`, `Details.tsx`

2. Бэк:

* В SQLite нет поля favorite, `is_favorite` в summary фактически вычисляется из `tags_json`.
  **Файлы:**
  `src-tauri/src/data/sqlite/schema.sql`
  `src-tauri/src/data/sqlite/repo_impl.rs`
  `src-tauri/src/types.rs`

### Нужно

* Favorite — **отдельное свойство**, не теги.
* Никаких автоматических записей `'favorite'` в `tags_json`.
* Favorites-раздел/счётчики/бейджи работают **по boolean**.

### Правки (backend, обязательно)

#### 4.1. SQLite: добавить колонку `is_favorite`

**Файл:** `src-tauri/src/data/sqlite/schema.sql`

В таблицу `datacards` добавить:

```sql
is_favorite INTEGER NOT NULL DEFAULT 0,
```

(между `note` и `tags_json` — не принципиально, но фиксируем порядок для читаемости)

#### 4.2. Миграция DB: v1 → v2, перенос старых favorite-тегов

**Файл:** `src-tauri/src/data/sqlite/migrations.rs`

* `CURRENT_SCHEMA_VERSION` увеличить до `2`
* Добавить ветку миграции `1 => { ... user_version = 2 }`

В миграции сделать строго:

1. `ALTER TABLE datacards ADD COLUMN is_favorite INTEGER NOT NULL DEFAULT 0;`
2. Прочитать все строки: `SELECT id, tags_json FROM datacards;`
3. Для каждой строки:

   * распарсить `tags_json` как `Vec<String>`
   * если содержит `"favorite"`:

     * `is_favorite = 1`
     * удалить `"favorite"` из массива тегов
     * записать обновлённый `tags_json` обратно
   * иначе оставить как есть
4. `PRAGMA user_version = 2;`

#### 4.3. Rust types: `DataCard` тоже должен знать про favorite

**Файл:** `src-tauri/src/types.rs`

* В `struct DataCard` добавить поле:

```rust
pub is_favorite: bool,
```

* В `struct DataCardSummary` оставить `is_favorite` (уже есть).

#### 4.4. repo_impl: учитывать `is_favorite` в SELECT/mapper’ах

**Файл:** `src-tauri/src/data/sqlite/repo_impl.rs`

* В `map_datacard(...)` добавить чтение колонки `is_favorite`
* В `list_datacards_summary` и `list_deleted_datacards_summary` добавить `is_favorite` в SELECT:

  * было: `SELECT id, folder_id, title, ... tags_json, ...`
  * стало: `SELECT id, folder_id, title, ... tags_json, is_favorite, created_at, ...`
* В `map_datacard_summary(...)` брать `is_favorite` **из колонки**, не из тегов.
* В `create_datacard` при INSERT указать `is_favorite` (значение `0`).
* В `update_datacard` **не трогать** `is_favorite`.

#### 4.5. Добавить команду Tauri: set/toggle favorite

**Файлы:**

* `src-tauri/src/commands/datacards.rs`
* `src-tauri/src/services/datacards_service.rs`
* `src-tauri/src/data/sqlite/repo_impl.rs`
* `src-tauri/src/main.rs`

**Реализация:**

* В `types.rs` добавить input:

```rust
pub struct SetDataCardFavoriteInput {
  pub id: String,
  pub is_favorite: bool,
}
```

* Команда `set_datacard_favorite(input: SetDataCardFavoriteInput, state: State<...>) -> Result<bool>`
* Сервис вызывает repo-функцию, repo делает:

```sql
UPDATE datacards SET is_favorite = ?1, updated_at = ?2 WHERE id = ?3
```

* Зарегистрировать команду в `tauri::generate_handler![ ... ]` в `src-tauri/src/main.rs`.

### Правки (frontend)

#### 4.6. TS backend types

**Файл:** `src/features/Vault/types/backend.ts`

* В `BackendDataCard` добавить:

```ts
is_favorite: boolean;
```

#### 4.7. UI types

**Файл:** `src/features/Vault/types/ui.ts`

* В `DataCard` добавить:

```ts
isFavorite: boolean;
```

* Упростить `DataCardSummary` (или оставить как есть, но тогда не дублировать смысл): предпочтительно убрать `isFavorite` из `DataCardSummary extends DataCard` (он уже будет в `DataCard`).

#### 4.8. mappers: больше не вычислять favorite из tags

**Файл:** `src/features/Vault/types/mappers.ts`

* `mapCardFromBackend`: проставлять `isFavorite: card.is_favorite`
* `mapCardSummaryFromBackend`: `isFavorite: card.is_favorite` (и убрать `|| tags.includes('favorite')`)
* `mapCardToSummary`: `isFavorite: card.isFavorite` (и убрать вычисление по тегам)

#### 4.9. API: добавить вызов set favorite

**Файл:** `src/features/Vault/api/vaultApi.ts`
Добавить:

```ts
export async function setDataCardFavorite(input: { id: string; is_favorite: boolean }): Promise<boolean> {
  return invoke('set_datacard_favorite', { input });
}
```

#### 4.10. useVault: favorites-логика только через boolean

**Файл:** `src/features/Vault/useVault.ts`

* `visibleCards`:

  * favorites pool строить по `card.isFavorite === true`
  * убрать `card.tags?.includes('favorite')`
* `counts.favorites` аналогично.
* `toggleFavorite`:

  * НЕ трогать `tags`
  * вызывать `setDataCardFavorite({ id, is_favorite: !current.isFavorite })`
  * обновить локальный `cards` state: для нужной карточки переключить `isFavorite`
  * если карточка загружена в `cardDetailsById`, обновить и там `isFavorite`

#### 4.11. Details: mark/unmark favorite не связан с tags

**Файл:** `src/features/Vault/components/Details/Details.tsx`

* `const isFavorite = card.isFavorite` вместо `card.tags.includes('favorite')`

#### 4.12. useDataCards: удалить добавление favorite в tags

**Файл:** `src/features/Vault/components/DataCards/useDataCards.ts`

* В `normalizeTags(...)` убрать блок:

```ts
if (form.isFavorite && !tagSet.has('favorite')) tagSet.add('favorite');
```

* Поле `isFavorite` в `DataCardFormState` можно удалить полностью (оно нигде не управляется UI и больше не нужно).

---

## 5) Toast: успех зелёный, ошибка красный, авто-скрытие 1 сек

### Сейчас

* `Toaster` не различает success/error и **не закрывается сам**.
* CSS-классы `.toast-success/.toast-error` уже есть, но **не используются**.

### Нужно

1. Успешные тосты — **зелёные**, исчезают через **1 секунду**.
2. Ошибки — **красные**, исчезают через **1 секунду**.

### Правки

#### 5.1. Toaster: добавить variant + автозакрытие

**Файл:** `src/components/Toaster.tsx`

* Изменить типы:

```ts
type ToastVariant = 'success' | 'error';
type Toast = { id: number; message: string; variant: ToastVariant };
```

* `show(message, variant = 'success')`:

  * добавляет toast
  * ставит `setTimeout(() => dismiss(id), 1000)`

* Рендер:

```tsx
<div className={`toast ${toast.variant === 'success' ? 'toast-success' : 'toast-error'}`} ...>
```

#### 5.2. Обновить вызовы

**Файлы:**

* `src/features/Vault/useVault.ts`

  * все ошибки (`handleError`, `lock` error) → `showToast(message, 'error')`
* `src/features/Vault/components/Details/useDetails.tsx`

  * copy success → `showToast(t('toast.copySuccess'), 'success')`
  * copy error → `showToast(t('toast.copyError'), 'error')`

#### 5.3. CSS (если нужно “реально зелёный/красный”, а не только бордер)

**Файл:** `src/styles/ui.css`
В `.toast-success/.toast-error` добавить фон (border уже есть):

```css
.toast-success { background: rgba(34, 197, 94, 0.12); }
.toast-error { background: rgba(239, 68, 68, 0.12); }
```

---

## 6) Удаление папки: confirm dialog всегда + выбор “папка” или “папка+файлы”

### Сейчас

* Если в папке `cardsCount === 0`, удаление происходит **без модалки** (сразу).
* Если `cardsCount > 0`, показывается `DeleteFolderModal` с выбором.

**Файл:** `src/features/Vault/Vault.tsx`

### Нужно

* Confirm dialog должен быть **всегда**, даже если папка пустая.
* В модалке:

  * если папка пустая → показываем подтверждение удаления папки (одна кнопка “Delete folder” + Cancel)
  * если в папке есть карточки → текущие 2 варианта:

    * “Delete folder only”
    * “Delete folder and cards”

### Правки

#### 6.1. Vault.tsx: убрать мгновенное удаление

**Файл:** `src/features/Vault/Vault.tsx`

* В `handleDeleteFolder(...)` убрать ветку:

  * `if (cardsCount === 0) { await onDeleteFolderOnly(...) }`
* Всегда выставлять `pendingFolderDelete` и `showDeleteFolderModal(true)`.

#### 6.2. DeleteFolderModal: два сценария текста/кнопок

**Файл:** `src/features/Vault/components/modals/DeleteFolderModal.tsx`

* Если `cardsCount === 0`:

  * description: “Are you sure you want to delete folder ‘X’?”
  * кнопки: Cancel + Delete folder only
  * кнопку “Delete folder and cards” не показывать
* Если `cardsCount > 0` — оставить как есть.

#### 6.3. i18n

**Файл:** `src/i18n/English/Vault.json`
Добавить:

```json
"vault.delete_folder.empty": "Are you sure you want to delete folder \"{{name}}\"?"
```

---

# Критерии приёмки (коротко, но проверяемо)

1. **Folder field**:

* В Create/Edit модалке поле Folder стоит **после Note**.
* Можно выбрать папку через ввод/выпадающий список.
* Карта сохраняется в выбранной папке (`folder_id` уходит в backend как id).
* При вводе несуществующей папки — сохранение блокируется ошибкой “Folder not found”.

2. **Delete card confirm**:

* При Delete всегда появляется confirm.
* При Purge (в Trash) — confirm тоже.

3. **Пустые поля**:

* В Information нет “—” у пустых username/email/url/mobile/password/note/tags/folder — там пусто.

4. **Favorite отдельно от tags**:

* Mark favorite больше **не добавляет** `'favorite'` в `tags`.
* Favorites-раздел работает по boolean `is_favorite`.
* После миграции старые `'favorite'`-теги:

  * переносятся в `is_favorite=1`
  * удаляются из `tags_json`.

5. **Toast**:

* Success toast зелёный, error toast красный.
* Любой toast исчезает сам через **1 секунду**.

6. **Delete folder confirm всегда**:

* Для пустой папки — confirm обязателен.
* Для непустой — выбор “folder only” / “folder + cards”.

---

