

## Technical Specification (EN): Workspace-first storage (Obsidian-like) + hardening (Windows)

### 0) Goals

1. Always show a Workspace picker screen until a workspace is selected.
2. Workspace selection:

   * User may **Create** a new workspace by picking an empty folder OR selecting a folder (app will initialize it).
   * User may enable **Use default path** (create workspace at `<app_dir>\Password Manager Vault`).
3. **Rule #2 (critical):** All real data must live strictly under the selected workspace root:

   * `<Workspace>\.pm-workspace.json` (marker)
   * `<Workspace>\Profiles\...` (all profiles, per-profile data, attachments, backups, vault db/encrypted files)
   * No profile/vault/attachments data outside the workspace folder.
4. Keep `workspaces registry` near the exe (portable-friendly): stored in `app_dir` (current behavior).
5. No DB migrations (dev version).
6. Fix and harden weak points discovered in current code:

   * Workspace switching must persist/cleanup active vault + clear all SQLite pools to avoid file locks.
   * `workspace_list` must not create directories as a side effect.
   * Replace fragile `fs::write(...)` on critical files with atomic writes (power-loss / crash safety, flash drive friendly).
   * Zeroize decrypted buffers after copying into SQLite-owned memory.
   * Remove panic (`unwrap`) in attachments import.

### 1) Non-goals

* No database schema migrations.
* No change to encryption algorithms or KDF parameters.
* No background sync / cloud features.

---

## 2) UX Requirements (Frontend)

### 2.1 Workspace screen behavior

* On startup, if workspace is not selected → show Workspace screen.
* Workspace screen shows:

  * Left list: **all known workspaces** (from registry), not “recent”.
  * Main panel:

    * “Choose the folder to keep your data”
    * Button **Create**:

      * If `Use default path` checked → create default workspace at `<app_dir>\Password Manager Vault`.
      * Else → open folder picker `open({ directory: true, multiple: false })`.
    * Button **Open data folder** (enabled only when selected workspace is active and valid).
    * Checkbox “Use default path” remains (as you asked).

### 2.2 Error handling

* For Create/Select/Open actions:

  * Catch backend errors and show a toast with error `code` (and a friendly message when possible).
* If default path fails due to permissions (e.g. installed under Program Files), toast must tell user to choose another folder.

---

## 3) Backend Requirements (Rust/Tauri)

### 3.1 Workspace marker format

* Marker file: `<Workspace>\.pm-workspace.json`
* Contents (JSON, pretty):

```json
{ "schema_version": 1 }
```

### 3.2 Workspace validity rules

* Workspace folder exists.
* Marker exists.
* Workspace is writable (attempt create+delete a temp file). Do NOT create `Profiles\` during `workspace_list` (no side effects).

### 3.3 Workspace switching safety (critical)

When selecting/creating a workspace:

1. If a profile is logged in → persist active vault (if any), lock it, wipe keys from memory.
2. Clear **all** SQLite pools (not only the current active profile), to avoid file locks when switching workspace or deleting profiles.
3. Then set `workspace_root`.

### 3.4 Atomic writes (critical)

Replace plain `fs::write(...)` with atomic write for critical files:

* Workspace marker `.pm-workspace.json`
* Encrypted vault file writes (`write_encrypted_file`)
* User settings JSON files
* KDF salt file
* Attachment storage file writes

Atomic write must:

* Write to a temp file in the same directory
* `sync_all()` temp
* Rename temp into place with a rollback strategy
* Best effort cleanup on failure

### 3.5 Zeroization (security hardening)

When creating `rusqlite::serialize::OwnedData` from decrypted bytes, wipe the original `Vec<u8>` after copying.
`OwnedData::from_raw_nonnull` requires memory allocated via `sqlite3_malloc64`.
Also, `sqlite3_deserialize` assumes the buffer remains valid for the lifetime of the connection; we already allocate SQLite-owned memory, which matches this model.

---

# 4) Exact code changes (files, patches)

> All paths are relative to the project root
> `Password-Manager-by-ChatGPT-codex-github-mention-add-persistence-after-vault-mutations/`

---

## 4.1 Add shared atomic write utility

### File: `src-tauri/src/main.rs`

Inside `mod data { ... }`, add a new module `fs`.

**Insert right after `pub mod storage_paths;` (near line ~6):**

```rust
pub mod fs {
    pub mod atomic_write;
}
```

---

### New file: `src-tauri/src/data/fs/atomic_write.rs`

**Create this file with the following code:**

```rust
use std::fs::{self, OpenOptions};
use std::io::{self, Write};
use std::path::Path;
use uuid::Uuid;

/// Atomic file write:
/// - write to temp in same directory
/// - fsync temp
/// - rename current -> backup (if exists)
/// - rename temp -> target
/// - cleanup backup
pub fn write_atomic(path: &Path, bytes: &[u8]) -> io::Result<()> {
    let parent = path.parent().ok_or_else(|| {
        io::Error::new(io::ErrorKind::InvalidInput, "write_atomic: path has no parent")
    })?;
    fs::create_dir_all(parent)?;

    let file_name = path
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("file");

    let tmp_path = parent.join(format!(".{}.tmp.{}", file_name, Uuid::new_v4()));
    let bak_path = parent.join(format!(".{}.bak.{}", file_name, Uuid::new_v4()));

    let result: io::Result<()> = (|| {
        // 1) write temp
        let mut f = OpenOptions::new()
            .write(true)
            .create_new(true)
            .open(&tmp_path)?;
        f.write_all(bytes)?;
        f.sync_all()?;
        drop(f);

        // 2) move current to backup (if exists)
        if path.exists() {
            fs::rename(path, &bak_path)?;
        }

        // 3) move temp into place
        fs::rename(&tmp_path, path)?;

        // 4) remove backup
        if bak_path.exists() {
            let _ = fs::remove_file(&bak_path);
        }

        Ok(())
    })();

    // Best-effort cleanup/rollback
    if result.is_err() {
        let _ = fs::remove_file(&tmp_path);
        if bak_path.exists() && !path.exists() {
            let _ = fs::rename(&bak_path, path);
        }
    }

    result
}
```

---

## 4.2 Use atomic writes for encrypted file writes

### File: `src-tauri/src/data/crypto/cipher.rs`

**Add import near the top:**

```rust
use crate::data::fs::atomic_write::write_atomic;
```

**Replace the function `write_encrypted_file` (around lines ~81–83) with:**

```rust
pub fn write_encrypted_file(path: &std::path::Path, blob: &[u8]) -> Result<()> {
    write_atomic(path, blob).map_err(|_| ErrorCodeString::new("ENCRYPTED_FILE_WRITE"))
}
```

---

## 4.3 Use atomic writes for global settings

### File: `src-tauri/src/data/settings/config.rs`

**Add import:**

```rust
use crate::data::fs::atomic_write::write_atomic;
```

**Replace `save_settings` with:**

```rust
pub fn save_settings(sp: &StoragePaths, settings: &UserSettings) -> Result<()> {
    let serialized = serde_json::to_string_pretty(settings)
        .map_err(|_| ErrorCodeString::new("SETTINGS_WRITE"))?;
    let path = settings_path(sp)?;
    write_atomic(&path, serialized.as_bytes()).map_err(|_| ErrorCodeString::new("SETTINGS_WRITE"))
}
```

---

## 4.4 Make workspace marker write atomic

### File: `src-tauri/src/commands/workspace.rs`

**Add import near other `use` lines:**

```rust
use crate::data::fs::atomic_write::write_atomic;
```

**Replace `ensure_marker` (lines ~29–38) with:**

```rust
fn ensure_marker(root: &Path) -> Result<()> {
    let marker = marker_path(root);
    if marker.exists() {
        return Ok(());
    }
    let payload = serde_json::json!({ "schema_version": 1 });
    let serialized = serde_json::to_string_pretty(&payload)
        .map_err(|_| ErrorCodeString::new("WORKSPACE_NOT_WRITABLE"))?;

    write_atomic(&marker, serialized.as_bytes())
        .map_err(|_| ErrorCodeString::new("WORKSPACE_NOT_WRITABLE"))
}
```

---

## 4.5 Remove side effects from `workspace_list` (no directory creation)

### File: `src-tauri/src/commands/workspace.rs`

**1) Add helper at top-level (below `validate_workspace_root` is fine):**

```rust
use std::io::Write;

fn is_dir_writable(root: &Path) -> bool {
    if !root.exists() || !root.is_dir() {
        return false;
    }
    let test_path = root.join(format!(".pm-write-test-{}", uuid::Uuid::new_v4()));
    match std::fs::OpenOptions::new()
        .write(true)
        .create_new(true)
        .open(&test_path)
    {
        Ok(mut f) => {
            let _ = f.write_all(b"test");
            let _ = f.sync_all();
            let _ = std::fs::remove_file(&test_path);
            true
        }
        Err(_) => false,
    }
}
```

**2) Replace `workspace_status` (currently creates `Profiles/`) with:**

```rust
fn workspace_status(root: &Path) -> Result<(bool, bool)> {
    if !root.exists() {
        return Ok((false, false));
    }
    let marker = marker_path(root);
    if !marker.exists() {
        return Ok((true, false));
    }

    // "valid" means selectable: marker exists AND the folder is writable.
    Ok((true, is_dir_writable(root)))
}
```

This keeps the list “pure”: it won’t create `Profiles\` just by listing.

---

## 4.6 Workspace switching must persist/cleanup + clear all pools

### File: `src-tauri/src/data/sqlite/pool.rs`

**Add function near `clear_pool`:**

```rust
pub fn clear_all_pools() {
    if let Ok(mut pools) = POOLS.lock() {
        pools.clear();
    }
}
```

---

### File: `src-tauri/src/app_state.rs`

**1) Add import:**

```rust
use std::sync::Arc;
```

**2) Add a public cleanup method inside `impl AppState { ... }`:**

```rust
pub fn logout_and_cleanup(self: &Arc<Self>) -> Result<()> {
    let is_logged_in = self
        .logged_in_profile
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
        .is_some();

    // Persist + lock vault only if we are actually logged in
    if is_logged_in {
        crate::services::security_service::lock_vault(self)?;
    }

    // Drop ALL connections (important for workspace switching & profile deletion)
    crate::data::sqlite::pool::clear_all_pools();

    // Ensure keys/session state are gone even if lock_vault was skipped
    self.clear_security_state();

    Ok(())
}
```

---

### File: `src-tauri/src/commands/workspace.rs`

**In `workspace_select`:**
Before:

```rust
validate_workspace_root(&resolved)?;
app_state.set_workspace_root(resolved)?;
```

**Change to:**

```rust
validate_workspace_root(&resolved)?;

// IMPORTANT: cleanup old workspace session before switching root
app_state.logout_and_cleanup()?;

// Now switch workspace root
app_state.set_workspace_root(resolved)?;
```

**In `workspace_create` and `workspace_create_default`:**
Before:

```rust
let record = upsert_workspace(...);
app_state.set_workspace_root(root)?;
```

**Change to:**

```rust
let record = upsert_workspace(...);

// IMPORTANT: cleanup old workspace session before switching root
app_state.logout_and_cleanup()?;

// Now switch workspace root
app_state.set_workspace_root(root)?;
```

**In `workspace_remove` when removing the active workspace:**
Before:

```rust
if was_active {
    registry.active_workspace_id = None;
    app_state.clear_workspace_root()?;
}
```

**Change to:**

```rust
if was_active {
    registry.active_workspace_id = None;

    // IMPORTANT: persist/lock + clear pools before clearing the workspace
    app_state.logout_and_cleanup()?;

    app_state.clear_workspace_root()?;
}
```

---

## 4.7 Profile deletion must clear DB pool locks

### File: `src-tauri/src/commands/profiles.rs`

Inside `profile_delete` closure:

**Before (existing):**

```rust
if should_lock {
    security_service::lock_vault(&app_state)?;
}
let delete_result = profiles_service::delete_profile(&storage_paths, &id);
```

**Change to:**

```rust
// Always clear pool for this profile id to avoid file locks during deletion
crate::data::sqlite::pool::clear_pool(&id);

if should_lock {
    // Persist + lock + clear all pools
    app_state.logout_and_cleanup()?;
}

let delete_result = profiles_service::delete_profile(&storage_paths, &id);
```

(You can keep `use crate::services::{profiles_service, security_service};` even if `security_service` becomes unused; or remove it to satisfy lint.)

---

## 4.8 Make per-profile user settings atomic

### File: `src-tauri/src/services/settings_service.rs`

**Add import near top:**

```rust
use crate::data::fs::atomic_write::write_atomic;
```

**In `get_settings`, replace the default creation write:**
Before:

```rust
fs::write(&path, serialized).map_err(|_| ErrorCodeString::new("SETTINGS_WRITE"))?;
```

After:

```rust
write_atomic(&path, serialized.as_bytes())
    .map_err(|_| ErrorCodeString::new("SETTINGS_WRITE"))?;
```

**In `update_settings`, replace:**
Before:

```rust
fs::write(path, serialized).map_err(|_| ErrorCodeString::new("SETTINGS_WRITE"))?;
```

After:

```rust
write_atomic(&path, serialized.as_bytes())
    .map_err(|_| ErrorCodeString::new("SETTINGS_WRITE"))?;
```

---

## 4.9 Make KDF salt write atomic + rollback profile init on failure

### File: `src-tauri/src/services/profiles_service.rs`

**Add import:**

```rust
use crate::data::fs::atomic_write::write_atomic;
```

**Replace salt write in `create_profile` (lines ~35–37):**
Before:

```rust
fs::write(kdf_salt_path(sp, &profile.id)?, &salt)
    .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
```

After:

```rust
let salt_path = kdf_salt_path(sp, &profile.id)?;
write_atomic(&salt_path, &salt)
    .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
```

**Additionally (critical): add rollback if any init step fails after registry entry creation.**
Wrap the initialization block (after `let profile = registry::create_profile(...) ?;`) like this:

```rust
let profile = registry::create_profile(sp, name, password.clone())?;

let init_result: Result<()> = (|| {
    ensure_profile_dirs(sp, &profile.id)
        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;

    let is_passwordless = password.as_ref().map(|p| p.is_empty()).unwrap_or(true);
    if is_passwordless {
        init_database_passwordless(sp, &profile.id)?;
    } else {
        let salt = generate_kdf_salt();
        let salt_path = kdf_salt_path(sp, &profile.id)?;
        write_atomic(&salt_path, &salt)
            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;

        let pwd = password.unwrap_or_default();
        let key = Zeroizing::new(derive_master_key(&pwd, &salt)?);
        key_check::create_key_check_file(sp, &profile.id, &key)?;
        init_database_protected_encrypted(sp, &profile.id, &key)?;
    }

    let _ = get_settings(sp, &profile.id)?;
    Ok(())
})();

if let Err(err) = init_result {
    // Best-effort cleanup to avoid half-created profiles
    let _ = registry::delete_profile(sp, &profile.id);
    if let Ok(dir) = crate::data::profiles::paths::profile_dir(sp, &profile.id) {
        let _ = fs::remove_dir_all(dir);
    }
    return Err(err);
}

Ok(profile)
```

---

## 4.10 Attachment import: remove panic + atomic writes

### File: `src-tauri/src/services/attachments_service.rs`

**Add import near top:**

```rust
use crate::data::fs::atomic_write::write_atomic;
```

**Replace the `unwrap()` on filename (around line ~102):**
Before:

```rust
let file_name = source.file_name().unwrap().to_string_lossy().to_string();
```

After:

```rust
let file_name = source
    .file_name()
    .ok_or_else(|| ErrorCodeString::new("ATTACHMENT_INVALID_SOURCE_PATH"))?
    .to_string_lossy()
    .to_string();
```

**Replace attachment file writes (around lines ~125–129):**
Before:

```rust
fs::write(&file_path, &encrypted)
    .map_err(|_| ErrorCodeString::new("ATTACHMENT_WRITE_FAILED"))?;
...
fs::write(&file_path, &bytes)
    .map_err(|_| ErrorCodeString::new("ATTACHMENT_WRITE_FAILED"))?;
```

After:

```rust
write_atomic(&file_path, &encrypted)
    .map_err(|_| ErrorCodeString::new("ATTACHMENT_WRITE_FAILED"))?;
...
write_atomic(&file_path, &bytes)
    .map_err(|_| ErrorCodeString::new("ATTACHMENT_WRITE_FAILED"))?;
```

(Keep the export/write to `target` as-is, since it’s user-chosen destination.)

---

## 4.11 Zeroize decrypted buffer after copying to SQLite-owned memory

### File: `src-tauri/src/services/security_service.rs`

**Add import near top (alongside `Zeroizing`):**

```rust
use zeroize::Zeroize;
```

**Replace `owned_data_from_bytes` (lines ~17–24) with:**

```rust
fn owned_data_from_bytes(mut bytes: Vec<u8>) -> Result<OwnedData> {
    let mem = unsafe { sqlite3_malloc64(bytes.len() as u64) };
    if mem.is_null() {
        return Err(ErrorCodeString::new("SQLITE_OOM"));
    }

    let owned = unsafe {
        std::ptr::copy_nonoverlapping(bytes.as_ptr(), mem as *mut u8, bytes.len());
        OwnedData::from_raw_nonnull(NonNull::new_unchecked(mem as *mut u8), bytes.len())
    };

    bytes.zeroize();
    Ok(owned)
}
```

This matches the `OwnedData` safety contract (SQLite allocation)  and prevents leaving decrypted DB bytes in memory longer than needed.

---

## 4.12 Frontend: Workspace screen error toasts + default path friendly error

### File: `src/features/Workspace/Workspace.tsx`

**1) Add import:**

```ts
import { useToaster } from '../../components/Toaster';
```

**2) Inside component, add:**

```ts
const { show } = useToaster();
```

**3) Add a small helper:**

```ts
const mapWorkspaceError = (code?: string) => {
  switch (code) {
    case 'WORKSPACE_NOT_WRITABLE':
      return t('notWritable'); // add translation key
    case 'WORKSPACE_INVALID_MARKER':
      return t('invalid');
    case 'WORKSPACE_FOLDER_MISSING':
      return t('missing');
    default:
      return t('operationFailed');
  }
};
```

**4) Wrap `handleSelect` with catch:**

```ts
const handleSelect = useCallback(
  async (id: string) => {
    setBusy(true);
    try {
      await workspaceSelect(id);
      await refresh();
      onWorkspaceReady();
    } catch (err: any) {
      show(mapWorkspaceError(err?.code), { title: t('errorTitle') });
    } finally {
      setBusy(false);
    }
  },
  [onWorkspaceReady, refresh, show, t]
);
```

**5) Wrap `handleCreate` with catch + keep “Use default path”:**

```ts
const handleCreate = useCallback(async () => {
  setBusy(true);
  try {
    if (useDefaultPath) {
      await workspaceCreateDefault();
    } else {
      const selected = await open({
        directory: true,
        multiple: false,
        title: t('chooseFolder'),
      });
      if (typeof selected !== 'string') {
        return;
      }
      await workspaceCreate(selected);
    }
    await refresh();
    onWorkspaceReady();
  } catch (err: any) {
    show(mapWorkspaceError(err?.code), { title: t('errorTitle') });
  } finally {
    setBusy(false);
  }
}, [onWorkspaceReady, refresh, show, t, useDefaultPath]);
```

**6) Wrap `handleOpenDataFolder`:**

```ts
const handleOpenDataFolder = useCallback(async () => {
  if (!selectedWorkspace || !selectedWorkspace.is_active || !selectedWorkspace.valid) {
    return;
  }
  try {
    await workspaceOpenInExplorer();
  } catch (err: any) {
    show(mapWorkspaceError(err?.code), { title: t('errorTitle') });
  }
}, [selectedWorkspace, show, t]);
```

**7) Add translations**
Update i18n file for Workspace (where your `t('...')` keys live), add at least:

* `errorTitle`
* `operationFailed`
* `notWritable`

(Keep strings short, e.g. “Selected folder is not writable. Please choose another location.”)

---

# 5) Manual test plan (Windows)

1. Fresh start (no workspace selected):

   * App shows Workspace screen.
   * “Create” without default path → pick folder `D:\PM Vault` → creates marker + Profiles dir; becomes active; UI enters app.
2. Close app while logged in, re-open:

   * Workspace is still active (from registry).
3. Add attachments (both passwordless and password-protected profile):

   * Attachment file written atomically; no partial file after forced close (kill process mid-write).
4. `workspace_list` side-effects:

   * With multiple registered folders, opening Workspace screen must NOT create `Profiles\` inside each listed folder.
5. Workspace switching:

   * Log in, create data, switch to another workspace:

     * No “database is locked”
     * Old workspace vault is persisted (if applicable)
6. Installed-under-Program-Files scenario:

   * If user ticks “Use default path” and app_dir is not writable → backend returns `WORKSPACE_NOT_WRITABLE`, UI shows toast and user can choose another folder.

---

# 6) Notes / Rationale

* Folder picker implementation follows Tauri dialog plugin `open({ directory: true, multiple: false })`.
* `OwnedData::from_raw_nonnull` requires SQLite allocation (`sqlite3_malloc64`), which we keep, and we wipe the plaintext buffer after copy.
* `sqlite3_deserialize` assumes the passed buffer remains valid for the connection lifetime; using SQLite-owned memory matches that expectation.

---

