
## Technical Specification (EN): Add detailed SQLite diagnostics for `DB_QUERY_FAILED` (Custom Fields debugging)

### Background

The application currently collapses most SQLite/rusqlite failures into a generic `DB_QUERY_FAILED` error code. This hides the real root cause (e.g. `no such table`, `no such column`, `database is locked`, malformed SQL, etc.). `rusqlite::Error` carries structured info (e.g. `Error::SqliteFailure(..., Some(message))`), but it is discarded today. ([Docs.rs][1])

This TS adds **detailed error logging** (SQL + operation name + rusqlite error debug) in the most important DB execution points.

### Goals

1. When any DB operation fails, print a **detailed log** including:

   * operation tag (e.g. `list_datacards_summary.prepare`)
   * SQL query text (or “N/A” for non-SQL failures)
   * full `rusqlite::Error` debug output
2. Ensure logs are visible in development (`cargo tauri dev`) and also available in release builds on Windows (where stdout/terminal output can be missing). ([GitHub][2])
3. Minimal behavioral change: do not change DB logic or error codes (still return `DB_QUERY_FAILED`), only add diagnostics.

### Non-goals

* No schema changes/migrations.
* No refactoring of repositories.
* No change to existing UI flows.

---

## Implementation

### 1) Add a shared helper for logging sqlite errors

**File:** `src-tauri/src/data/sqlite/diagnostics.rs` (NEW)

Create:

```rust
use rusqlite::Error;

pub fn log_sqlite_err(op: &str, sql: &str, err: &Error) {
    eprintln!(
        "[DB][{op}] rusqlite error: {err:?}\n[DB][{op}] sql: {sql}"
    );
}
```

Rationale: `rusqlite::Error` contains `SqliteFailure` details including message and extended code. ([Docs.rs][1])

---

### 2) Add detailed logs around the most frequent failing queries

**File:** `src-tauri/src/data/sqlite/repo_impl.rs`

#### 2.1 Import the helper

At top imports:

```rust
use crate::data::sqlite::diagnostics::log_sqlite_err;
```

#### 2.2 Patch `list_folders(...)`

Locate `prepare(...)`, `query_map(...)`, and `collect(...)` error mapping and replace generic `map_err(|_| ...)` with logging.

Example required pattern:

```rust
let sql = "SELECT * FROM folders WHERE deleted_at IS NULL ORDER BY name ASC";

let mut stmt = conn.prepare(sql).map_err(|e| {
    log_sqlite_err("list_folders.prepare", sql, &e);
    ErrorCodeString::new("DB_QUERY_FAILED")
})?;

let rows = stmt.query_map([], map_folder).map_err(|e| {
    log_sqlite_err("list_folders.query_map", sql, &e);
    ErrorCodeString::new("DB_QUERY_FAILED")
})?;

let folders = rows.collect::<rusqlite::Result<Vec<_>>>().map_err(|e| {
    log_sqlite_err("list_folders.collect", sql, &e);
    ErrorCodeString::new("DB_QUERY_FAILED")
})?;
```

#### 2.3 Patch `list_datacards_summary(...)`

This function is typically called during vault refresh and frequently triggers the reported error.

Wrap:

* `conn.prepare(&query)`
* `stmt.query_map(...)`
* `collect::<rusqlite::Result<Vec<_>>>()`

with the same pattern, using `&query` as SQL text and operation tags:

* `list_datacards_summary.prepare`
* `list_datacards_summary.query_map`
* `list_datacards_summary.collect`

---

### 3) Log DB target + open failures for connection pool (very important for “password protected vault”)

**File:** `src-tauri/src/data/sqlite/pool.rs`

Add a log line in `get_or_create_pool(...)` after target/key resolution:

```rust
eprintln!("[DB][pool] profile_id={profile_id} target={target:?} key={key}");
```

Replace the pool build error mapping:

```rust
.build(manager)
.map_err(|e| {
    eprintln!("[DB][pool] build failed: {e:?}");
    ErrorCodeString::new("DB_OPEN_FAILED")
})?
```

Rationale: in-memory shared databases require URI filenames and shared cache; misconfiguration can lead to separate “empty” DBs per connection. ([SQLite][3])

---

### 4) Log resolved DB path and migration version at initialization

#### 4.1 Passwordless init logs

**File:** `src-tauri/src/data/sqlite/init.rs`

In `init_database_passwordless(...)`, before opening:

```rust
eprintln!("[DB][init] passwordless vault path: {}", vault_db_path.display());
```

Wrap `Connection::open(...)` errors:

```rust
let conn = Connection::open(&vault_db_path).map_err(|e| {
    eprintln!("[DB][init] open failed: {e:?}");
    ErrorCodeString::new("DB_OPEN_FAILED")
})?;
```

#### 4.2 Migration version logging

**File:** `src-tauri/src/data/sqlite/migrations.rs`

In `migrate_to_latest(...)`, after reading `PRAGMA user_version`:

```rust
eprintln!("[DB][migrate] user_version={version}, current={CURRENT_SCHEMA_VERSION}");
```

Rationale: using `PRAGMA user_version` is a standard schema versioning approach and the value is critical for debugging which schema is actually in use. ([Lev Lazinskiy][4])

---

### 5) Ensure logs exist in Windows release builds (stdout may be missing)

Because release builds on Windows may not reliably show stdout/stderr in a terminal, configure tauri plugin logging to write to a file (while still logging to stdout in dev). ([GitHub][2])

**File:** `src-tauri/src/main.rs` (or `src-tauri/src/lib.rs`, depending on your project entry)

Add (or ensure present) `tauri-plugin-log` initialization with default targets (stdout + file). Per docs, default includes stdout and a file target. ([Tauri][5])

Example (adapt to your existing builder chain):

```rust
.use(tauri_plugin_log::Builder::new().build())
```

Then, replace `eprintln!` in `log_sqlite_err` with `log::error!` if you want everything to go through the plugin, OR keep `eprintln!` but also add a `log::error!` line for file persistence.

---

## Acceptance Criteria

1. When a DB failure happens, the terminal (dev) prints a log like:

   * `[DB][list_datacards_summary.prepare] rusqlite error: ...`
   * `sql: SELECT ...`
2. In Windows release builds, the same diagnostics are available in the app log file (tauri log plugin output). ([Tauri][5])
3. No functional behavior changes:

   * frontend still receives `code: "DB_QUERY_FAILED"` (no API change required)
4. Logs include enough detail to identify root cause without guessing:

   * `no such column ...`
   * `no such table ...`
   * `database is locked`
   * etc. (rusqlite debug output includes these messages). ([Android Git Repositories][6])

---

## Notes (why this is necessary)

* `rusqlite::Error` debug output contains structured details (error code + optional message). ([Android Git Repositories][6])
* In-memory shared SQLite requires URI usage; pool mis-targeting can create multiple empty DBs. ([SQLite][3])
* Windows release builds may not show terminal output; file logging is recommended. ([GitHub][2])

