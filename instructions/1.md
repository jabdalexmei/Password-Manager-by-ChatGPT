

## TS (English): Fix `update_datacard` failing when `password_value` is NULL (affects custom fields edits)

### Summary

Editing a datacard (including updating custom field values) fails with generic “Operation failed” because backend `repo_impl::update_datacard` reads `password_value` as non-null `String`. For cards where `password_value` is `NULL`, rusqlite throws a conversion error which is mapped to `DB_QUERY_FAILED`.

### Scope

Backend only (Rust / Tauri). No DB migration required.

### File(s)

* `src-tauri/src/data/sqlite/repo_impl.rs`

### Root Cause

In `update_datacard`, the code currently does:

```rust
let existing_password: Option<String> = conn
    .query_row(
        "SELECT password_value FROM datacards WHERE id = ?1",
        params![input.id],
        |row| row.get(0),
    )
    .optional()
    .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
```

Because `.optional()` only converts “no rows” to `None`, the inner type is **String**, not `Option<String>`. If `password_value` is `NULL`, `row.get::<_, String>(0)` fails -> `DB_QUERY_FAILED`.

### Required Changes

#### 1) Read nullable `password_value` as `Option<String>` and keep “card not found” semantics

In `src-tauri/src/data/sqlite/repo_impl.rs`, inside `pub fn update_datacard(...)`, replace the `existing_password` query block with this exact code:

```rust
let existing_password_row: Option<Option<String>> = conn
    .query_row(
        "SELECT password_value FROM datacards WHERE id = ?1",
        params![input.id],
        |row| row.get::<_, Option<String>>(0),
    )
    .optional()
    .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;

let existing_password: Option<String> = match existing_password_row {
    None => return Err(ErrorCodeString::new("DATACARD_NOT_FOUND")),
    Some(value) => value, // may be None if DB value is NULL
};
```

#### 2) Keep password history logic intact (no data loss)

Keep the trimming and history logic, but it must now work with `existing_password: Option<String>` (nullable). The following block can remain as-is, it will now behave correctly:

```rust
let old_trimmed = existing_password
    .as_deref()
    .unwrap_or("")
    .trim()
    .to_string();
let new_trimmed = input.password.as_deref().unwrap_or("").trim().to_string();

if !old_trimmed.is_empty() && old_trimmed != new_trimmed {
    insert_password_history(
        state,
        profile_id,
        &input.id,
        existing_password.as_deref().unwrap_or(""),
        &now,
    )?;
}
```

✅ Important behavior preserved:

* If old password is NULL/empty → no history entry.
* If old password existed and user changes/clears it → history entry stored with previous value.
* Custom fields edits won’t crash just because password is NULL.

### Acceptance Criteria

1. Create a new datacard **without** password, add a custom field, save.
2. Open Edit dialog, change only the custom field value, save.

   * Expected: Save succeeds, no “Operation failed”.
3. Repeat with password set later:

   * Setting password from NULL → no history entry created.
   * Changing password from “A” to “B” → history entry created with “A”.
4. No `DB_QUERY_FAILED` logged for this scenario.

### Optional (Debug Quality Improvement, not required for the fix)

In the same function, replace the current `.map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))` on the `query_row` with logging of the original error (only for dev), so future failures show the real cause.

---

