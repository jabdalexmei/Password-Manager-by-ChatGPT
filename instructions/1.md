

# ✅ SUPER-precise diff-like plan (TS in English)

## TS-01: Fix backup restore for protected profiles (drop in-memory session before swapping files)

### Goal

After `backup_restore`, the application must not continue using an outdated in-memory decrypted vault (`state.vault_session.conn`). The restore workflow must **force-close** the active in-memory vault session (without persisting) so that:

* file replacement is not blocked by open handles
* after restore, the vault is **locked** and must be re-unlocked by user (freshly loaded from restored `vault.db`)

### Background (why)

* Repository layer uses in-memory connection when `vault_session` exists (`src-tauri/src/data/sqlite/repo_impl.rs`).
* `backup_restore` currently replaces the vault files but does **not** clear `vault_session`, so the backend keeps serving stale data.

### Changes

#### 1) Add a new function to clear vault session WITHOUT persisting

**File:** `src-tauri/src/services/security_service.rs`

Add this function near `lock_vault` (keep style consistent):

```rust
pub fn drop_active_session_without_persist(state: &Arc<AppState>) -> Result<bool> {
    let storage_paths = state.get_storage_paths()?;

    // Determine active profile id
    let active_id = state
        .active_profile
        .lock()
        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
        .clone();

    let Some(profile_id) = active_id else {
        // nothing to drop
        return Ok(true);
    };

    // Clear attachment previews (safe even if folder missing)
    attachments_service::clear_previews_for_profile(state, &profile_id)?;

    // Drop in-memory session
    {
        let mut session = state
            .vault_session
            .lock()
            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
        *session = None;
    }

    // Drop sqlite pools for that profile (file connections)
    clear_pool(&profile_id);

    // Extra: sanity check profile exists (optional)
    let _ = registry::get_profile(&storage_paths, &profile_id)?;

    Ok(true)
}
```

Notes:

* This is intentionally **NOT** calling `persist_active_vault()`.
* We reuse existing helpers: `attachments_service::clear_previews_for_profile`, `clear_pool`.

#### 2) Call it inside restore BEFORE touching vault.db / attachments

**File:** `src-tauri/src/services/backup_service.rs`

Inside `pub fn backup_restore(...)` do this **right after** acquiring guard and before any file moves/renames:

Find:

```rust
pub fn backup_restore(state: &Arc<AppState>, backup_path: String) -> Result<bool> {
    let _guard = ensure_backup_guard(state)?;
    let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
    ...
```

Replace with:

```rust
pub fn backup_restore(state: &Arc<AppState>, backup_path: String) -> Result<bool> {
    let _guard = ensure_backup_guard(state)?;

    // We need active unlocked profile to validate ownership etc.
    let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;

    // IMPORTANT: if this profile is protected, it can have an in-memory decrypted DB connection.
    // Drop it before swapping files, otherwise restore can succeed but app continues using stale memory DB.
    security_service::drop_active_session_without_persist(state)?;
    ...
```

Expected behavior after this change:

* Restore succeeds
* Vault becomes locked (because session is removed)
* Frontend will receive `VAULT_LOCKED` on next data calls and must show unlock screen (already your existing behavior).

---

## TS-02: Fix Add2FAModal tab switching after file upload

### Goal

While Add2FA modal is open, switching the `existingUri` prop must not force the tab back to `"text"`. The tab reset must happen only when the modal transitions from closed → open.

### Changes

**File:** `src/features/Vault/components/modals/Add2FAModal.tsx`

Find current effect:

```ts
useEffect(() => {
  if (!isOpen) return;
  setTextValue(existingUri ?? '');
  setTab('text');
}, [existingUri, isOpen]);
```

Replace with a “open-transition only” effect:

```ts
const wasOpenRef = React.useRef(false);

useEffect(() => {
  const wasOpen = wasOpenRef.current;
  wasOpenRef.current = isOpen;

  // Only reset when the modal is newly opened
  if (!wasOpen && isOpen) {
    setTextValue(existingUri ?? '');
    setTab('text');
  }
}, [isOpen, existingUri]);
```

Why this works:

* Changing `existingUri` while already open will no longer reset the tab.
* When the modal opens, it initializes correctly.

---

## TS-03: Adjust backup rename retry window (match requested 40–60 × 25ms)

### Goal

Make rename retry shorter and more granular (Windows file locks). Requested: **40–60 attempts × 25ms** (≈ 1–1.5s).

### Changes

**File:** `src-tauri/src/services/backup_service.rs`

Find `fn rename_with_retry(...)`:

Current core loop:

```rust
for _ in 0..25 {
    match fs::rename(src, dst) {
        ...
        std::thread::sleep(Duration::from_millis(80));
```

Replace constants:

```rust
const ATTEMPTS: usize = 60;
const SLEEP_MS: u64 = 25;

for _ in 0..ATTEMPTS {
    match fs::rename(src, dst) {
        Ok(()) => return Ok(()),
        Err(e) => {
            if e.kind() == std::io::ErrorKind::PermissionDenied {
                last_err = Some(e);
                std::thread::sleep(Duration::from_millis(SLEEP_MS));
                continue;
            }
            return Err(e);
        }
    }
}
```

---

## TS-04: Remove dead “contentReference” artifact

### Goal

Remove stray text injected into comment.

### Changes

**File:** `src-tauri/src/data/sqlite/init.rs`

Replace:

```rust
// WAL persistence is documented by SQLite. :contentReference[oaicite:1]{index=1}
```

With:

```rust
// WAL persistence is documented by SQLite.
```

(Shared-cache/WAL docs exist, но ссылку внутрь кода ты всё равно не используешь.)

---

## TS-05 (Optional hardening): Verify that only one invoke_handler is used (prevent silent command loss)

### Why (sanity)

Tauri explicitly warns: multiple `invoke_handler` calls → работает только последний .
В твоём `src-tauri/src/main.rs` сейчас **один** `.invoke_handler(...)` — это нормально. Этот пункт — просто “не сломать в будущем”.

No code change required **right now** (just keep it this way).

