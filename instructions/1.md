

## TS (EN): Fix chacha20poly1305 feature, unify password verification, implement attachments (add files to DataCard)

### Scope

1. Fix build failure caused by invalid `chacha20poly1305` feature usage.
2. Remove `password_hash` as a verification mechanism and standardize on `key_check + kdf_salt` for protected profiles.
3. Implement file attachments for DataCards (backend + frontend): add/list/remove attachments; store attachments under the active profile; encrypt attachments for protected profiles using existing XChaCha20-Poly1305 helpers.

### Non-goals

* No compatibility requirements for “old profiles” (no plaintext→encrypted migration requirement).
* No export/import/backups/search in this TS.

---

### 1) Build fix: remove non-existent feature `xchacha20`

#### File: `src-tauri/Cargo.toml`

Replace dependency entry:

**From**

```toml
chacha20poly1305 = { version = "0.10", features = ["xchacha20"] }
```

**To (recommended)**

```toml
chacha20poly1305 = "0.10.1"
```

Notes:

* `XChaCha20Poly1305` is provided by the crate without a dedicated `xchacha20` feature flag.

---

### 2) Standardize master password verification on `key_check` only

#### Goal

* Remove `password_hash` field from the profile registry data model.
* Use `has_password: bool` + `{kdf_salt.bin, key_check.bin}` as the only protected-profile mechanism.

#### Backend changes

##### File: `src-tauri/src/data/profiles/registry.rs`

1. Update `ProfileRecord` struct:

* **Remove**

  * `password_hash: Option<String>`
* **Add**

  * `has_password: bool`

2. Update registry serialization:

* Ensure `save_registry()` writes `has_password` instead of `password_hash`.

3. Update `ProfileMeta` mapping:

* Replace `has_password: value.password_hash.is_some()` with `has_password: value.has_password`.

4. Update profile creation:

* In `create_profile(...)`, set:

  * `has_password = password.as_ref().map(|p| !p.is_empty()).unwrap_or(false)`
* Remove the call to `hash_password()` and do not store a password hash in the registry.

5. Update verification:

* In `verify_profile_password(sp, id, password) -> Result<bool>`:

  * If `record.has_password == false` → return `Ok(true)`
  * Else:

    * Read `kdf_salt.bin`
    * `derive_master_key(password, &salt)`
    * `key_check::verify_key_check_file(sp, id, &key)`

##### File: `src-tauri/src/data/crypto/kdf.rs`

* After step 2 above, `hash_password()` and `verify_password()` become unused.

  * Option A (clean): remove them.
  * Option B (acceptable): keep them but ensure they are not referenced anywhere.

---

### 3) Attachments feature (add files to a DataCard)

#### UX requirements

* In the DataCard details panel, show an **Attachments** section:

  * list existing attachments (file name + size)
  * “Add file” button
  * per-item “Remove” button
* Adding a file uses OS file picker and sends the selected file path to backend.
* For protected profile:

  * attachment is stored encrypted at rest using existing `encrypt_attachment_blob()` (XChaCha20-Poly1305).
* For passwordless profile:

  * stored as plaintext bytes.
* When a card is soft-deleted, attachments must become invisible (soft-deleted too).
* When a card is restored, attachments become visible again.
* When a card is purged, attachment files must be physically removed.

---

#### Backend: Data model & storage

##### File: `src-tauri/src/types.rs`

Add new structs:

```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AttachmentMeta {
    pub id: String,
    pub datacard_id: String,
    pub file_name: String,
    pub mime_type: Option<String>,
    pub byte_size: i64,
    pub created_at: String,
    pub updated_at: String,
    pub deleted_at: Option<String>,
}
```

##### File: `src-tauri/src/data/profiles/paths.rs`

Add helper:

```rust
pub fn attachment_file_path(sp: &StoragePaths, profile_id: &str, attachment_id: &str) -> PathBuf {
    profile_dir(sp, profile_id).join("attachments").join(format!("{attachment_id}.bin"))
}
```

##### File: `src-tauri/src/data/sqlite/schema.sql`

Add a new table:

```sql
CREATE TABLE IF NOT EXISTS attachments (
  id          TEXT PRIMARY KEY,
  datacard_id TEXT NOT NULL,

  file_name   TEXT NOT NULL,
  mime_type   TEXT NULL,
  byte_size   INTEGER NOT NULL,

  created_at  TEXT NOT NULL,
  updated_at  TEXT NOT NULL,
  deleted_at  TEXT NULL,

  FOREIGN KEY(datacard_id) REFERENCES datacards(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_attachments_datacard
ON attachments(datacard_id);

CREATE INDEX IF NOT EXISTS idx_attachments_deleted
ON attachments(deleted_at);
```

##### File: `src-tauri/src/data/sqlite/migrations.rs`

* Bump schema version:

  * When initializing from version `0`, execute updated schema and set `PRAGMA user_version = 3;`
* Add migration for existing version `2`:

  * `ALTER TABLE` is not needed (new table). Execute a batch that creates `attachments` table + indexes, then set `user_version = 3`.

---

#### Backend: repository/service/commands

##### File: `src-tauri/src/data/sqlite/repo_impl.rs`

Add repository functions for attachments (exact signatures may match your repo style, but must exist as concrete functions):

* Insert:

  * `fn insert_attachment(conn: &Connection, meta: &AttachmentMeta) -> Result<()>`
* List by card (not deleted):

  * `fn list_attachments_by_datacard(conn: &Connection, datacard_id: &str) -> Result<Vec<AttachmentMeta>>`
* Soft delete by card:

  * `fn soft_delete_attachments_by_datacard(conn: &Connection, datacard_id: &str, deleted_at: &str) -> Result<()>`
* Restore by card:

  * `fn restore_attachments_by_datacard(conn: &Connection, datacard_id: &str) -> Result<()>`
* Get by id:

  * `fn get_attachment(conn: &Connection, attachment_id: &str) -> Result<Option<AttachmentMeta>>`
* Soft delete single:

  * `fn soft_delete_attachment(conn: &Connection, attachment_id: &str, deleted_at: &str) -> Result<()>`
* Purge (delete row):

  * `fn purge_attachment(conn: &Connection, attachment_id: &str) -> Result<()>`

##### New file: `src-tauri/src/services/attachments_service.rs`

Responsibilities:

* Validate login state (must be logged in).
* Resolve active profile id + determine if protected (presence of `vault_key` in `AppState`).
* Create `AttachmentMeta` (uuid id, timestamps).
* Read source file bytes:

  * Validate: file exists, is file, and size <= e.g. 50MB (define a constant).
* Store file:

  * If protected: `cipher::encrypt_attachment_blob(profile_id, attachment_id, &vault_key, &bytes)` then write to `attachment_file_path(...)`
  * If passwordless: write raw bytes to `attachment_file_path(...)`
* Insert DB row in `attachments` table.

Public service functions:

* `add_attachment_from_path(app: &AppHandle, datacard_id: String, source_path: String) -> Result<AttachmentMeta>`
* `list_attachments(app: &AppHandle, datacard_id: String) -> Result<Vec<AttachmentMeta>>`
* `remove_attachment(app: &AppHandle, attachment_id: String) -> Result<()>` (soft delete + keep file until purge)
* `purge_attachment(app: &AppHandle, attachment_id: String) -> Result<()>` (delete DB row + delete file)
* `save_attachment_to_path(app: &AppHandle, attachment_id: String, target_path: String) -> Result<()>`

  * For protected: decrypt and write plaintext to `target_path`
  * For passwordless: copy stored file to `target_path`

##### New file: `src-tauri/src/commands/attachments.rs`

Expose Tauri commands:

* `list_attachments(datacard_id: String) -> Result<Vec<AttachmentMeta>>`
* `add_attachment_from_path(datacard_id: String, source_path: String) -> Result<AttachmentMeta>`
* `remove_attachment(attachment_id: String) -> Result<()>`
* `purge_attachment(attachment_id: String) -> Result<()>`
* `save_attachment_to_path(attachment_id: String, target_path: String) -> Result<()>`

##### File: `src-tauri/src/commands/mod.rs`

Add:

```rust
pub mod attachments;
```

##### File: `src-tauri/src/main.rs`

Add new commands to `tauri::generate_handler![ ... ]` list:

* `list_attachments`
* `add_attachment_from_path`
* `remove_attachment`
* `purge_attachment`
* `save_attachment_to_path`

##### File: `src-tauri/src/services/datacards_service.rs`

Integrate attachments lifecycle with card operations:

* On `delete_datacard` (soft delete):

  * call `soft_delete_attachments_by_datacard(datacard_id, deleted_at)`
* On `restore_datacard`:

  * call `restore_attachments_by_datacard(datacard_id)`
* On `purge_datacard`:

  * list attachments by datacard including deleted, delete each attachment file from disk, then purge attachment rows (or rely on cascade row deletion and only delete files explicitly)

---

#### Frontend changes

##### File: `src/features/Vault/types/ui.ts`

Add:

```ts
export type Attachment = {
  id: string;
  datacardId: string;
  fileName: string;
  mimeType: string | null;
  byteSize: number;
  createdAt: string;
  updatedAt: string;
  deletedAt: string | null;
};
```

##### File: `src/features/Vault/types/backend.ts`

Add backend DTO equivalent for attachments (naming consistent with your existing backend types file), e.g.:

* `BackendAttachmentMeta`

##### File: `src/features/Vault/api/vaultApi.ts`

Add functions:

* `listAttachments(datacardId: string): Promise<BackendAttachmentMeta[]>`
* `addAttachmentFromPath(datacardId: string, sourcePath: string): Promise<BackendAttachmentMeta>`
* `removeAttachment(attachmentId: string): Promise<void>`
* `purgeAttachment(attachmentId: string): Promise<void>`
* `saveAttachmentToPath(attachmentId: string, targetPath: string): Promise<void>`

All must use `invoke(...)` with command names from backend.

##### File: `src/features/Vault/components/Details/useDetails.tsx` (or a new hook)

Implement:

* state: `attachments: Attachment[]`
* effect: when `card?.id` changes → call `listAttachments(card.id)`
* action: `onAddAttachment()`:

  * open file picker (Tauri dialog) and obtain file path string
  * call `addAttachmentFromPath(card.id, path)`
  * refresh list
* action: `onRemoveAttachment(attachmentId)`:

  * call `removeAttachment(attachmentId)`
  * refresh list

##### File: `src/features/Vault/components/Details/Details.tsx`

Add UI section “Attachments”:

* list items (name, size)
* “Add file” button
* “Remove” per item

