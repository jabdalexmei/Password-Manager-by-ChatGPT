

# SPEC — CLEANUP-WARNINGS-CANON-01

## Goal

Remove all current `dead_code` warnings **without adding allow(dead_code)** by:

1. Making path management canonical and actually used (StoragePaths as the single source of truth)
2. Using `verify_profile_password` in the login flow
3. Using `clear_pool` when locking/switching profile
4. Deleting unused placeholder crypto and unused unused profile path helpers

Target: `cargo build` shows **0 warnings** from the list you provided.

## Scope

Rust backend only: `src-tauri/src/**`.

---

## 1) Make `StoragePaths` canonical and used everywhere

### 1.1 Update `AppState` to own StoragePaths

**File:** `src-tauri/src/app_state.rs`

Add a field:

```rust
use crate::data::storage_paths::StoragePaths;

pub struct AppState {
    // existing fields...
    pub storage_paths: StoragePaths,
}
```

Where `AppState` is constructed (usually in `main.rs`), initialize:

```rust
let storage_paths = StoragePaths::new()?; // or StoragePaths::resolve()? (use actual constructor present)
let app_state = Arc::new(AppState {
   // existing fields...
   storage_paths,
});
```

### 1.2 Use StoragePaths in all path functions that currently re-compute directories

**File:** `src-tauri/src/data/profiles/paths.rs`

* Delete the functions:

  * `pub fn app_dir() -> PathBuf`
  * `pub fn data_root() -> PathBuf`

* For every remaining function in this module that builds paths, change signature to accept `&StoragePaths`:

**Before**

```rust
pub fn profiles_dir() -> PathBuf { ... }
pub fn profile_dir(profile_id: &str) -> PathBuf { ... }
pub fn vault_db_path(profile_id: &str) -> PathBuf { ... }
```

**After**

```rust
use crate::data::storage_paths::StoragePaths;

pub fn profiles_dir(sp: &StoragePaths) -> PathBuf { ... }
pub fn profile_dir(sp: &StoragePaths, profile_id: &str) -> PathBuf { ... }
pub fn vault_db_path(sp: &StoragePaths, profile_id: &str) -> PathBuf { ... }
```

All implementations must use only:

* `sp.data_root()` and/or `sp.app_dir()` (the getters in `storage_paths.rs`)

This removes the warnings for unused `app_dir/data_root` fields and getters by ensuring they are used.

### 1.3 Update all call-sites to pass `&state.storage_paths`

Search in Rust backend for calls into `profiles::paths::*` functions and update them.
Any service/repo code that needs paths must use:

* `&state.storage_paths` (from `Arc<AppState>`)

Example updates (conceptual):

* Anywhere you had: `vault_db_path(profile_id)`
  Replace with: `vault_db_path(&state.storage_paths, profile_id)`

---

## 2) Use `verify_profile_password` in login flow

### 2.1 Wire password verification into `login_vault`

**File:** `src-tauri/src/services/security_service.rs` (or the file where `login_vault` logic lives)

In the login function:

1. Determine the active profile id (existing logic).
2. Call:

```rust
let ok = registry::verify_profile_password(&profile_id, &password)?;
if !ok {
    return Err(ErrorCodeString::new("INVALID_PASSWORD"));
}
```

3. Only if ok, mark vault as unlocked/logged in (existing behavior).

This removes the warning:

* `verify_profile_password` is never used

---

## 3) Use `clear_pool` when locking and switching profiles

### 3.1 Clear pool on vault lock

**File:** `src-tauri/src/services/security_service.rs`

In the function that locks the vault (or equivalent):

* After determining which profile is being locked (profile id), call:

```rust
crate::data::sqlite::pool::clear_pool(&profile_id);
```

### 3.2 Clear pool when switching active profile

**File:** `src-tauri/src/services/profiles_service.rs`

When changing active profile:

* Read old active profile id (if any) before overwriting it.
* After switch:

```rust
if let Some(old_id) = old_active_profile_id {
    crate::data::sqlite::pool::clear_pool(&old_id);
}
```

This removes the warning:

* `clear_pool` is never used
  …and prevents stale pooled connections across profile switches.

---

## 4) Delete unused placeholder crypto modules (must be removed)

### 4.1 Remove placeholder encrypt/decrypt

**File:** `src-tauri/src/data/crypto/cipher.rs`

Delete the functions entirely:

* `encrypt_placeholder`
* `decrypt_placeholder`

If the file becomes empty, delete the file.

### 4.2 Remove unused KeyCheck

**File:** `src-tauri/src/data/crypto/key_check.rs`

Delete:

* the `KeyCheck` struct
* any other content in that file

If file becomes empty, delete it.

### 4.3 Remove module exports/references

**File:** `src-tauri/src/data/crypto/mod.rs` (or wherever crypto modules are declared)

Remove:

* `pub mod cipher;`
* `pub mod key_check;`

Also search the backend for any `cipher::` or `key_check::` uses and delete those references (they should not exist in canon flow).

This removes warnings:

* encrypt_placeholder never used
* decrypt_placeholder never used
* KeyCheck never constructed

---

## 5) Delete unused profile path helper functions (not part of current canon)

### 5.1 Remove unused helpers

**File:** `src-tauri/src/data/profiles/paths.rs`

Delete these functions completely (and any references if they exist):

* `attachments_dir(profile_id: &str)`
* `backups_dir(profile_id: &str)`
* `active_profile_path()`
* `profile_exists(id: &str)`

These are currently unused and not required for the current stage.

This removes warnings:

* attachments_dir never used
* backups_dir never used
* active_profile_path never used
* profile_exists never used

---

## 6) Acceptance Criteria

1. `cargo build` produces **0 warnings** from:

* StoragePaths fields/getters unused
* placeholder crypto functions unused
* KeyCheck unused
* profiles/paths helpers unused
* verify_profile_password unused
* clear_pool unused

2. Path resolution is canonical:

* All directories used for profiles/DB are derived from `state.storage_paths`.

3. Security correctness:

* Vault login verifies password using `verify_profile_password`.

4. Stability:

* SQLite pool is cleared on vault lock and profile switch.

---

## 7) Verification steps (developer must run)

From `src-tauri/`:

```bash
cargo clean
cargo build
```

Expected output:

* Build succeeds
* No `dead_code` warnings listed earlier

---
