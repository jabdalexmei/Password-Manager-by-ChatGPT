

## Technical Specification (EN): Fix React infinite re-render + finalize Tauri v2 + implement secure in-app attachment panel

### Goal

1. Fix frontend crash: **“Maximum update depth exceeded”** caused by unstable dependencies in `useEffect`.
2. Ensure project builds on **Tauri v2** without capability/permission errors.
3. Implement “Attachments” panel in **Information** (Details view) with:

   * **Eye** = in-app preview (no plaintext file written to disk)
   * **Download** = export decrypted file to user-selected path
   * **Trash** = delete with confirmation
   * **Add file** button (top-right), optional drag & drop.

---

## A) Frontend: Fix “Maximum update depth exceeded”

### Problem

Your `useTranslation()` returns a new `t` function on every render. Any `useEffect(..., [t])` will re-run every render and can loop if it calls `setState`. This is exactly what happens in `src/features/Vault/components/Details/useDetails.tsx` (effect calls `setShowPassword(false)` and refreshes attachments).

### Required change (make `t` stable)

**File:** `src/lib/i18n.ts`

1. Change `useTranslation` to return a **memoized** `t` (stable identity) using `useCallback`.
2. Return a memoized `{ t }` object to avoid identity churn.

**Replace** current `useTranslation` implementation with:

```ts
import { useCallback, useMemo } from 'react';

export const useTranslation = (namespace?: Namespace) => {
  const dict = useMemo(() => (namespace ? dictionaries[namespace] : undefined), [namespace]);

  const t = useCallback(
    (key: string, params?: Record<string, string | number>): string => {
      if (!dict || !(key in dict)) return key;

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      let result = (dict as any)[key] as string;

      if (params) {
        Object.entries(params).forEach(([paramKey, value]) => {
          const pattern = new RegExp(`{{${paramKey}}}`, 'g');
          result = result.replace(pattern, String(value));
        });
      }

      return result;
    },
    [dict]
  );

  return useMemo(() => ({ t }), [t]);
};
```

### Acceptance criteria

* App no longer logs “Maximum update depth exceeded” when opening Details panel.
* Effects depending on `t` don’t re-run every render.

---

## B) Tauri v2: Fix build errors (capabilities + opener call)

### B1) Fix capabilities permission error: `Permission opener:default not found`

**File:** `src-tauri/capabilities/default.json`

Currently contains:

```json
"permissions": [
  "core:default",
  "dialog:allow-open",
  "opener:default"
]
```

**Change required:**

* Remove `"opener:default"` from `permissions` **until** you actually use opener from the frontend side with a confirmed permission name supported by your installed plugin version.

**Result example:**

```json
"permissions": [
  "core:default",
  "dialog:allow-open",
  "dialog:allow-save"
]
```

> Notes:
>
> * You already use dialog from frontend for file picking and will need `dialog:allow-save` for export (Download icon).

### B2) Fix Rust error for `open_path(..., None)` type inference (E0283)

If you keep any usage of `tauri-plugin-opener` `open_path`, the second argument is:
`Option<impl Into<String>>`, so `None` is ambiguous.

**File:** `src-tauri/src/services/attachments_service.rs`

Where you call:

```rs
app.opener().open_path(preview_path_str, None)
```

**Must become:**

```rs
app.opener().open_path(preview_path_str, None::<String>)
```

(or `Option::<String>::None`).

### Acceptance criteria

* `cargo tauri dev` passes Rust compilation stage.
* Capability generation no longer fails on `opener:default`.

---

## C) Attachments: Secure in-app preview + Download + Delete + New panel UI

### Security requirement

**Preview must happen inside the app** and must not persist decrypted data to disk (no preview files in temp folders).
Export is allowed to write decrypted bytes to user selected path.

### C1) Backend: add command to fetch decrypted bytes for preview

#### New command

**File:** `src-tauri/src/commands/attachments.rs`

Add a new command:

```rs
#[tauri::command]
pub async fn get_attachment_bytes_base64(app: AppHandle, attachment_id: String) -> Result<AttachmentPreviewDto> { ... }
```

#### DTO

**File:** `src-tauri/src/types.rs` (or wherever `AttachmentMeta` is defined; keep consistency)

Add:

```rs
use serde::Serialize;

#[derive(Serialize)]
pub struct AttachmentPreviewDto {
    pub file_name: String,
    pub bytes_base64: String,
}
```

#### Service function

**File:** `src-tauri/src/services/attachments_service.rs`

Add a pure read/decrypt function (no filesystem writes):

```rs
pub fn read_attachment_bytes(app: &AppHandle, attachment_id: String) -> Result<(String, Vec<u8>)> {
    // 1) require_logged_in
    // 2) load meta; validate not deleted
    // 3) fs::read encrypted stored_path
    // 4) if session.vault_key exists -> decrypt_attachment_blob(...)
    // 5) return (meta.file_name.clone(), output_bytes)
}
```

Then implement `get_attachment_bytes_base64` by calling the service and encoding bytes.

#### Dependency

**File:** `src-tauri/Cargo.toml`

Add:

```toml
base64 = "0.22"
```

Use:

```rs
use base64::Engine;
use base64::engine::general_purpose::STANDARD as BASE64;
```

Encode:

```rs
let b64 = BASE64.encode(&bytes);
```

#### Register command

**File:** `src-tauri/src/main.rs`

Add `get_attachment_bytes_base64` to `invoke_handler`.

### C2) Backend: keep export as-is, but make it reachable from UI

You already have:

* `save_attachment_to_path(attachment_id, target_path)` → writes decrypted bytes to `target_path`

Keep it.

### C3) Backend: delete flow

You already have:

* `remove_attachment(attachment_id)` (soft delete)
* `purge_attachment(attachment_id)` (hard delete)

UI requirement says “delete with confirmation” — define it precisely:

* Trash icon in Information panel does **soft delete** by default (call `remove_attachment`).
* Optional: show “Delete permanently” only in Trash mode (call `purge_attachment`), but this is secondary.

---

## D) Frontend: Implement the new “Attachments” panel in Information (Details)

### D1) API additions

**File:** `src/features/Vault/api/vaultApi.ts`

Add:

```ts
export type AttachmentPreviewDto = {
  fileName: string;
  bytesBase64: string;
};

export async function getAttachmentBytesBase64(attachmentId: string): Promise<AttachmentPreviewDto> {
  return invoke('get_attachment_bytes_base64', { attachmentId });
}
```

### D2) UI layout (match screenshot)

**File:** `src/features/Vault/components/Details/Details.tsx`

Replace current attachment block (currently renders rows with text buttons “Open/Remove” and “Add”) with a panel layout:

* Header row:

  * Left: “Attachments” label + paperclip icon
  * Right: “+ Add file” button
* Each attachment row:

  * Left: filename + secondary line `mime / size` (mime can be derived on frontend from extension or kept simple: `ext + size`)
  * Right: icon buttons:

    * Eye (preview)
    * Download (export)
    * Trash (delete confirm)

### D3) Preview modal

Create a modal component to show decrypted bytes as a Blob URL.

**New file:** `src/features/Vault/components/modals/AttachmentPreviewModal.tsx`

Requirements:

* Props: `{ open: boolean; fileName: string; mime: string; objectUrl: string; onClose: () => void }`
* If `mime.startsWith('image/')` → render `<img src={objectUrl} />`
* Else if `mime === 'application/pdf'` → render `<iframe src={objectUrl} />`
* Else if `mime.startsWith('text/')` → fetch text from bytes OR render `<iframe>` (acceptable), but simplest is: show “Preview not supported” + Download button.

Object URL lifecycle:

* On open: create URL from Blob
* On close/unmount: `URL.revokeObjectURL(url)`

### D4) Hook changes

**File:** `src/features/Vault/components/Details/useDetails.tsx`

Replace `onOpenAttachment` behavior:

* Do **not** call `openAttachment()` (external open).
* New flow for Eye icon:

  1. call `getAttachmentBytesBase64(attachmentId)`
  2. decode base64 → `Uint8Array`
  3. create Blob + object URL
  4. open preview modal in Details panel state

Also update “Add attachment”:

* Change `open({ multiple: false })` → `open({ multiple: true })`
* For each selected path: call `addAttachmentFromPath(card.id, path)`
* Then refresh list once at end.

Download icon:

* Use `save` dialog from `@tauri-apps/plugin-dialog`:

  * `const targetPath = await save({ defaultPath: fileName })`
  * if `targetPath` set → `await saveAttachment(attachmentId, targetPath)`

Delete icon:

* Show confirmation dialog (`ConfirmDialog` already exists).
* On confirm: call `removeAttachment(attachmentId)` then refresh list.

### D5) CSS

**File:** `src/styles/screens/vault.css`

Add styles for:

* `.attachments-panel`
* `.attachments-header`
* `.attachments-row`
* `.attachments-meta`
* `.attachments-actions`
* icon buttons matching existing button styles (use existing `.icon-button` patterns if present, otherwise create small rounded buttons like in screenshot).

---

## Acceptance criteria (end-to-end)

1. Frontend doesn’t crash with “Maximum update depth exceeded”.
2. `cargo tauri dev` succeeds (no permission error about `opener:default`).
3. In Details → Information:

   * Attachments panel matches the screenshot layout (header + Add file + rows).
   * Eye opens in-app preview without writing decrypted bytes to disk.
   * Download prompts for a path and writes decrypted file there.
   * Delete asks confirmation and removes attachment; list updates.
4. Create Data Card: existing attach flow remains working (paths selected, uploaded after create).

---

