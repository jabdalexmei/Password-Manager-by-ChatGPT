ВЫПОЛНИ ВСЕ ЧТО ТУТ НАПИСАНО!

## TS (EN) — Incremental Parts (small PRs, easy verification)

### Global Delivery Rules (applies to all parts)

* Deliver each part as a separate PR/branch with commits referencing the part ID (e.g., `P1`, `P2`).
* No placeholders/stubs. If a part introduces UI, the backend must work for that part (and vice versa).
* Provide proof for each part: screenshots + console/log snippets for the acceptance checks.
* Do not modify unrelated styling/theme in these parts.

---

# Part 0 — Fix build blocker: remove vendored lucide-react and use npm lucide-react

### Goal

`npm run dev` must work. Remove `vendor/lucide-react` (contains JSX in `.js`).

### Required changes

1. **Delete** directory:

* `vendor/lucide-react/`

2. Update imports across the React codebase:

* Replace any imports from `vendor/lucide-react` (or similar) to:

  * `import { ... } from "lucide-react";`

3. Ensure dependency exists:

* `package.json`: add dependency `lucide-react` (current stable).
* Remove any dependency that points to vendor path.

4. Update Vite config only if needed:

* Prefer no special transpile for lucide (npm package should be fine).

### Acceptance checks

* `npm install` succeeds.
* `npm run dev` starts without the previous “invalid JS syntax” error.
* Icons render in UI (any page).

---

# Part 1 — Fix Tauri invoke payload keys (camelCase → snake_case)

### Goal

Eliminate “Operation failed” caused by wrong argument names.

### Files to modify

* `src/features/Vault/api/vaultApi.ts`

### Required changes (exact)

Update invoke payload keys to match Rust command args:

**Backup**

* `invoke('export_backup_command', { outputPath, mode, customPassword })`
  → `invoke('export_backup_command', { output_path: outputPath, mode, custom_password: customPassword ?? null })`

* `invoke('decrypt_backup_to_temp_command', { backupPath, password })`
  → `invoke('decrypt_backup_to_temp_command', { backup_path: backupPath, password })`

* `invoke('finalize_restore_command', { tempId })`
  → `invoke('finalize_restore_command', { temp_id: tempId })`

* `invoke('finalize_import_as_new_profile_command', { tempId, newProfileName, password })`
  → `invoke('finalize_import_as_new_profile_command', { temp_id: tempId, new_profile_name: newProfileName, password })`

**Password history**

* `invoke('get_datacard_password_history', { datacardId })`
  → `invoke('get_datacard_password_history', { datacard_id: datacardId })`

* `invoke('clear_datacard_password_history', { datacardId })`
  → `invoke('clear_datacard_password_history', { datacard_id: datacardId })`

**Attachments**

* `list_attachments`: `{ datacardId }` → `{ datacard_id: datacardId }`
* `add_attachment_from_path`: `{ datacardId, sourcePath }` → `{ datacard_id: datacardId, source_path: sourcePath }`
* `remove_attachment/purge_attachment`: `{ attachmentId }` → `{ attachment_id: attachmentId }`
* `save_attachment_to_path`: `{ attachmentId, targetPath }` → `{ attachment_id: attachmentId, target_path: targetPath }`
* `get_attachment_bytes_base64`: `{ attachmentId }` → `{ attachment_id: attachmentId }`

### Acceptance checks

* Editing card + saving does not show generic “Operation failed”.
* Attachments list call returns data instead of failing.
* Password history commands return/clear without failing (even if history is empty).

---

# Part 2 — Fix Password History API contract (Rust DTO must include datacard_id)

### Goal

Frontend expects `datacard_id`, backend must provide it.

### Files to modify

* `src-tauri/src/commands/password_history.rs`

### Required changes

1. Update `PasswordHistoryRowDto` to include:

* `pub datacard_id: String`

2. In mapping, set `datacard_id` from the service row.

Currently DTO is:

```rust
pub struct PasswordHistoryRowDto {
  pub id: String,
  pub password_value: String,
  pub created_at: String,
}
```

Must become:

```rust
pub struct PasswordHistoryRowDto {
  pub id: String,
  pub datacard_id: String,
  pub password_value: String,
  pub created_at: String,
}
```

### Acceptance checks

* `getPasswordHistory()` returns entries where frontend mapping `entry.datacard_id` is defined (no undefined).
* Password history dialog lists entries correctly.

---

# Part 3 — Fix Data Loss on update (bank_card/custom_fields must not be wiped)

### Goal

Stop wiping fields when updating a card.

### Files to modify

* `src/features/Vault/types/mappers.ts`

### Required changes

Current code:

* `mapCreateCardToBackend()` sets `bank_card: null`, `custom_fields: []`
* `mapUpdateCardToBackend()` spreads `mapCreateCardToBackend(input)` → wipes fields on every update.

**Requirement**

* For update payload, do NOT hardcode null/empty for unsupported UI sections.

Implement one of these (choose A):

**Option A (recommended): split create vs update payload types**

* `mapCreateCardToBackend()` may keep defaults (fine for new cards).
* `mapUpdateCardToBackend()` must map only editable fields and **must not send** `bank_card` and `custom_fields` unless edit UI supports them.

Concretely:

* `BackendUpdateDataCardInput` should be changed to allow optional `bank_card/custom_fields` OR create a dedicated update type on frontend that omits them.

### Acceptance checks

* Create a card → add some `custom_fields/bank_card` (if backend supports) → edit title → save → those fields remain intact.
* At minimum: editing any card never “resets” fields that weren’t edited.

---

# Part 4 — Password History full flow (write history on password changes + UI accessible even when password empty)

### Goal

History works reliably and is reachable even if password field is hidden.

### Backend requirements

* Ensure history table exists for any DB state:

  * Add an “ensure tables exist” step that runs even when `PRAGMA user_version == CURRENT_SCHEMA_VERSION`.
  * File: `src-tauri/src/data/sqlite/migrations.rs`
    Add a small function `ensure_schema_safety(conn)` executing `CREATE TABLE IF NOT EXISTS datacard_password_history...` and call it for all versions (including `CURRENT_SCHEMA_VERSION` path).

### UI requirements

* If Details panel hides empty password field, user must still be able to open history.
* Add a “Password history” action button in a stable location in Information panel (not inside password row).

  * Files:

    * `src/features/Vault/components/Details/Details.tsx`
    * `src/features/Vault/components/modals/PasswordHistoryDialog.tsx`

### Acceptance checks

* Change password twice → history shows previous passwords.
* Clear password → previous password is recorded in history.
* Current password empty → history button still visible and dialog opens.
* Clear history works.

---

# Part 5 — Attachments full flow (add/list/delete + download + internal preview)

### Goal

Implement toolbar behavior: Eye=preview inside app, Export=download, Trash=delete.

### Backend

* Ensure commands work with encryption:

  * Use existing `get_attachment_bytes_base64` (already exists in Rust commands).
  * Confirm it decrypts attachment content when vault key exists.
* Ensure delete and save-to-path commands use correct args.

### Frontend

* Update attachment panel UI to match semantics:

  * Eye: opens in-app preview modal (image/pdf/else fallback message)
  * Export: save dialog + call `save_attachment_to_path`
  * Trash: confirm + `remove_attachment` (soft) or `purge_attachment` (hard) depending on your design (explicitly decide one here; default: `remove_attachment`).

Files (likely):

* `src/features/Vault/components/Details/useDetails.tsx`
* `src/features/Vault/components/Details/Details.tsx`
* new modal: `src/features/Vault/components/modals/AttachmentPreviewDialog.tsx`

### Acceptance checks

* Add attachment → appears.
* Eye opens preview inside app (png/jpg/pdf).
* Export downloads to chosen path.
* Delete removes after confirmation.

---

# Part 6 — Backup end-to-end (replace stubs with real implementation + UI Restore/Import-as-new)

### Goal

Encrypted `.zip` backup works like “KeePass-style file”, with no profile_id binding.

### Backend

* Implement real logic in:

  * `src-tauri/src/services/backup_service.rs` (remove `BACKUP_UNSUPPORTED_VERSION`)
* Inputs:

  * export: `output_path`, `mode`, `custom_password`
  * import: `backup_path`, `password`
* Output format:

  * ZIP containing encrypted vault db + attachments + manifest
* Import UI choice:

  * **Restore** (enabled only when profile unlocked)
  * **Import as new profile** (creates a profile; password = backup password)

### Frontend

* Backup UI should call the corrected command payloads from Part 1.
* Use your existing settings fields:

  * `default_export_dir`, `last_export_dir` in `BackendUserSettings`.

### Acceptance checks

* Export backup succeeds and produces `.zip`.
* Import with wrong password fails cleanly.
* Import as new profile creates new profile and opens.
* Restore overwrites current profile (only when unlocked).

---

