

# PERF-STABILITY-02 — Fix remaining freezes/lag: async commands for Profiles/Security, remove full refresh reloads, harden SQLite pool

## Goal

Make the app stable and responsive by eliminating the remaining sources of UI stalls:

1. **Profiles** and **Security** Tauri commands are still synchronous and can block UI (I/O + Argon2).
2. Frontend still performs **full Vault refresh** after actions (`refreshActive()`), causing lag.
3. SQLite pool needs **timeouts** to prevent rare “hangs” under contention.

## Scope

Backend (Rust/Tauri):

* `src-tauri/src/commands/profiles.rs`
* `src-tauri/src/commands/security.rs`
* `src-tauri/src/data/sqlite/pool.rs`

Frontend (React):

* `src/features/Vault/useVault.ts`

---

## Part A — Backend: convert Profiles commands to async + spawn_blocking

### A1) Update function signatures and wrap service calls

**File:** `src-tauri/src/commands/profiles.rs`

For every exported `#[tauri::command]` function in this file:

#### Required changes (for each command)

1. Change signature from:

```rust
pub fn xxx(..., state: State<'_, Arc<AppState>>) -> Result<T>
```

to:

```rust
pub async fn xxx(..., state: State<'_, Arc<AppState>>) -> Result<T>
```

2. Replace direct service calls with:

```rust
let state = state.inner().clone(); // clone Arc<AppState>
tauri::async_runtime::spawn_blocking(move || {
    // call the original service function here
}).await.map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
```

#### Example: profiles_list

**Before**

```rust
#[tauri::command]
pub fn profiles_list(state: State<'_, Arc<AppState>>) -> Result<ProfilesList> {
    profiles_service::profiles_list(&state)
}
```

**After**

```rust
#[tauri::command]
pub async fn profiles_list(state: State<'_, Arc<AppState>>) -> Result<ProfilesList> {
    let state = state.inner().clone();
    tauri::async_runtime::spawn_blocking(move || {
        profiles_service::profiles_list(&tauri::State::from(state)) // if your service requires State
    })
    .await
    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
}
```

**Important (do this the clean way):**
If your service functions currently accept `&State<Arc<AppState>>`, refactor them to accept `&Arc<AppState>` instead.

### A2) Refactor services to accept `&Arc<AppState>` (recommended)

**File:** `src-tauri/src/services/profiles_service.rs` (or wherever profiles service lives)

For each service function:

* Replace `state: &State<Arc<AppState>>` with `state: &Arc<AppState>`
* Update call sites accordingly.

This prevents needing to reconstruct `State` and makes spawn_blocking clean.

### A3) Commands to convert (minimum)

Convert all commands in:

* `src-tauri/src/commands/profiles.rs`
  including (typical list):
* `profiles_list`
* `profile_create`
* `profile_delete`
* `set_active_profile`
  (and any others present)

**Acceptance criteria (A):**

* Creating/deleting profiles no longer freezes UI.
* Switching profiles does not stall the window.

---

## Part B — Backend: convert Security commands to async + spawn_blocking

### B1) Update function signatures and wrap heavy calls

**File:** `src-tauri/src/commands/security.rs`

Same pattern as Part A:

* every `#[tauri::command] pub fn` becomes `pub async fn`
* wrap internal operations in `spawn_blocking`

### B2) Commands to convert (minimum)

Convert all commands in:

* `src-tauri/src/commands/security.rs`
  especially:
* `login_vault` (Argon2 + DB init)
* `lock_vault`
* `is_logged_in`
* `auto_lock_cleanup` (if it does I/O)

### B3) Refactor security service to accept `&Arc<AppState>` (recommended)

**File:** `src-tauri/src/services/security_service.rs` (or equivalent)

Replace `&State<Arc<AppState>>` arguments with `&Arc<AppState>`.

**Acceptance criteria (B):**

* Login/unlock is responsive (UI doesn’t “hang” during Argon2).
* Lock operation does not freeze the window.

---

## Part C — Backend: harden SQLite pool to avoid rare hangs (timeouts)

### C1) Add busy timeout on SQLite connection

**File:** `src-tauri/src/data/sqlite/pool.rs`

Inside your `CustomizeConnection` implementation (e.g. `Pragmas::on_acquire`), add:

```rust
use std::time::Duration;

conn.busy_timeout(Duration::from_secs(3))?;
```

Place it before or after PRAGMAs (either is fine).

### C2) Add pool connection timeout

**File:** `src-tauri/src/data/sqlite/pool.rs`

Where you build the pool, add:

```rust
use std::time::Duration;

let pool = r2d2::Pool::builder()
    .max_size(8)
    .connection_timeout(Duration::from_secs(3))
    .build(manager)
    .map_err(|_| ErrorCodeString::new("DB_POOL_FAILED"))?;
```

**Acceptance criteria (C):**

* No infinite waiting on SQLite locks.
* Under load, requests either succeed or fail fast with a controlled error.

---

## Part D — Frontend: remove full refresh reloads after mutations

### D1) Remove/replace `await refreshActive()` after actions

**File:** `src/features/Vault/useVault.ts`

#### Required rule

After a successful mutation (create/update/delete/move/restore/purge), **do not call** `refreshActive()`.

### D2) Exact replacements (what to do instead)

#### Create folder

**Remove:** `await refreshActive();` after create.
**Do instead:**

* append returned folder to `folders` state
* set selected navigation to that folder

Example logic:

```ts
setFolders(prev => [...prev, createdFolder].sort(byName));
setSelectedNav({ type: 'folder', id: createdFolder.id });
```

#### Create data card

**Remove:** `await refreshActive();`
**Do instead:**

* insert returned summary/card into `cards` state
* select it immediately

```ts
setCards(prev => [createdCard, ...prev]);
setSelectedCardId(createdCard.id);
```

#### Update data card

**Remove:** `await refreshActive();`
**Do instead:** update single item by id

```ts
setCards(prev => prev.map(c => c.id === updatedId ? { ...c, ...updatedFields } : c));
```

#### Delete data card (soft-delete)

**Remove:** `await refreshActive();`
**Do instead:**

* remove from `cards`
* if `trashLoaded === true`, push into `deletedCards`

```ts
setCards(prev => prev.filter(c => c.id !== id));
if (trashLoaded) setDeletedCards(prev => [deletedSummary, ...prev]);
```

#### Restore/Purge in Deleted mode

**Remove:** any `refreshActive()` or repeated `refreshTrash()` used as a crutch.
**Do instead:**

* Restore: remove from deleted list, add back to active list
* Purge: remove from deleted list

### D3) Keep refresh only for lifecycle events

`refreshActive()` is allowed only in:

* initial Vault load after unlock
* switching active profile
* manual refresh (optional button)

**Explicit deletion requirement**
Delete or stop calling any helper that triggers “full reload after every click”.
If there is a common `afterAction()` that always refreshes, it must be removed or rewritten.

**Acceptance criteria (D):**

* Create/Edit/Delete no longer triggers a visible “stall” from full list reload.
* UI updates instantly with local state changes.

---

## Part E — Verification steps (developer must run)

### E1) Build + run

* `cargo build` (src-tauri)
* run app and test:

  * create profile
  * set password / login
  * create folder
  * create data card
  * edit card
  * delete + go to Deleted
  * restore + purge

### E2) Performance sanity

* Open Vault with 200+ cards
* Type in search
* Select different cards quickly
  Expected: no freezing, no multi-second “hang” after each click.

---

## Definition of Done

1. All commands in `commands/profiles.rs` and `commands/security.rs` are `async` and use `spawn_blocking`.
2. SQLite pool has `busy_timeout` and pool `connection_timeout`.
3. `useVault.ts` no longer calls `refreshActive()` after every mutation; state updates are local and minimal.
4. App no longer “lags/hangs” during login/profile operations or after button clicks in Vault.

---
