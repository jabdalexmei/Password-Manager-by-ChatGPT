

# Technical Specification: Attachments panel in Information (in-app preview, download, delete w/ confirmation)

## Goal

Implement an Attachments panel in the Information (Details) view matching the provided UI:

* Header with “Attachments” label and “Add file” button.
* Attachment row shows filename + “mime / size” subtitle.
* Actions per attachment:

  1. **Preview (eye)**: open an in-app preview modal **without writing decrypted bytes to disk**.
  2. **Download (export)**: save decrypted file to a user-selected path on disk.
  3. **Delete (trash)**: delete attachment with confirmation.

## Non-goals

* No external OS opening via opener plugin.
* No persistent decrypted preview files on disk.
* No advanced inline preview for every possible file format; only supported types (defined below).

---

## Preview support matrix

Preview in-app must support:

* `image/*` (png, jpg, webp, gif): render `<img>` in modal.
* `text/*` (txt, json, etc.): render `<pre>` in modal (UTF-8; if decode fails show “Cannot preview”).
* `application/pdf`: render in `<iframe>` using a Blob URL (if base64 size <= limit).

Everything else:

* show modal message “Preview not supported. Use Download.”

### Preview size limits

To avoid UI freezing and IPC overhead:

* `MAX_PREVIEW_BYTES = 8 * 1024 * 1024` (8 MiB) for images/text/pdf.
  If attachment is larger:
* return error code `ATTACHMENT_TOO_LARGE_FOR_PREVIEW`.

---

## Backend (Rust) changes

### 1) Remove/stop using external opener for preview

If `open_attachment` command exists, it will no longer be used for preview. Keep it only if still needed elsewhere; otherwise remove from handler list to avoid dead code.

### 2) Add command to fetch decrypted bytes for preview (in-memory only)

#### File: `src-tauri/src/types.rs`

Add a response struct:

```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AttachmentPreviewPayload {
    pub attachment_id: String,
    pub file_name: String,
    pub mime_type: String,
    pub byte_size: i64,
    pub base64_data: String,
}
```

#### Add dependency for base64

**File:** `src-tauri/Cargo.toml`
Add:

```toml
base64 = "0.22"
```

#### File: `src-tauri/src/services/attachments_service.rs`

Add constant near top:

```rust
const MAX_PREVIEW_BYTES: usize = 8 * 1024 * 1024;
```

Add function:

```rust
pub fn get_attachment_preview(app: &AppHandle, attachment_id: String) -> Result<AttachmentPreviewPayload> {
    let session = require_logged_in(app)?;

    let meta = repo_impl::get_attachment(&session.state, &session.profile_id, &attachment_id)?
        .ok_or_else(|| ErrorCodeString::new("ATTACHMENT_NOT_FOUND"))?;

    if meta.deleted_at.is_some() {
        return Err(ErrorCodeString::new("ATTACHMENT_NOT_FOUND"));
    }

    if meta.byte_size as usize > MAX_PREVIEW_BYTES {
        return Err(ErrorCodeString::new("ATTACHMENT_TOO_LARGE_FOR_PREVIEW"));
    }

    let stored_path = attachment_file_path(&session.state.storage_paths, &session.profile_id, &meta.id);
    let bytes = std::fs::read(&stored_path).map_err(|_| ErrorCodeString::new("ATTACHMENT_READ_FAILED"))?;

    // Decrypt in-memory only
    let output_bytes = if let Some(key) = session.vault_key {
        cipher::decrypt_attachment_blob(&session.profile_id, &meta.id, &key, &bytes)?
    } else {
        bytes
    };

    if output_bytes.len() > MAX_PREVIEW_BYTES {
        return Err(ErrorCodeString::new("ATTACHMENT_TOO_LARGE_FOR_PREVIEW"));
    }

    // mime_type fallback
    let mime = meta.mime_type.clone().unwrap_or_else(|| "application/octet-stream".to_string());

    let base64_data = base64::engine::general_purpose::STANDARD.encode(output_bytes);

    Ok(AttachmentPreviewPayload {
        attachment_id: meta.id,
        file_name: meta.file_name,
        mime_type: mime,
        byte_size: meta.byte_size,
        base64_data,
    })
}
```

Notes:

* Use the project’s existing `Result<T>` + `ErrorCodeString` pattern (no `anyhow`).
* No temp files are created for preview.

#### File: `src-tauri/src/commands/attachments.rs`

Add command:

```rust
#[tauri::command]
pub async fn get_attachment_preview(app: AppHandle, attachment_id: String) -> Result<AttachmentPreviewPayload> {
    tauri::async_runtime::spawn_blocking(move || {
        attachments_service::get_attachment_preview(&app, attachment_id)
    })
    .await
    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
}
```

#### File: `src-tauri/src/main.rs`

Add `get_attachment_preview` to `tauri::generate_handler![ ... ]`.

---

## Download (save to disk)

This likely already exists as `save_attachment_to_path(attachment_id, target_path)` in backend. If it exists, keep it.

If missing, implement it in:

* `src-tauri/src/services/attachments_service.rs`
* `src-tauri/src/commands/attachments.rs`
  Behavior:
* read stored file
* decrypt if protected
* write plaintext to `target_path`

---

## Delete with confirmation

Use **permanent delete** (purge) for this UI action.

Backend should already have:

* `purge_attachment(attachment_id)` deleting DB row + deleting stored file.
  If only soft delete exists, implement purge:
* delete file `profiles/<id>/attachments/<attachment_id>.bin`
* delete row from `attachments` table

---

## Frontend (React) changes

### 1) Attachments panel UI to match screenshot

#### File: `src/features/Vault/components/Details/Details.tsx`

Replace current attachments section with a dedicated component.

**New file:** `src/features/Vault/components/Details/AttachmentsPanel.tsx`

Responsibilities:

* render header:

  * left: paperclip icon + “Attachments”
  * right: “+ Add file” button
* render list rows:

  * left: file name (bold) + subtitle `mime / size`
  * right: 3 icon buttons: Eye, Download, Trash (trash is red)
* render hint line at bottom:

  * “Drop files here or use the Add file button”
  * (drag&drop behavior optional; text required)

#### Styling

**File:** `src/styles/ui.css` (or vault-specific CSS file)
Add styles for:

* `.attachments-panel`
* `.attachments-header`
* `.attachments-list`
* `.attachment-row`
* `.attachment-actions`
* `.icon-btn`, `.icon-btn--danger`
* `.attachments-hint`

UI must match:

* rounded container
* subtle border
* list row background
* action buttons grouped on right

### 2) In-app preview modal

**New file:** `src/features/Vault/components/Details/AttachmentPreviewModal.tsx`

Props:

```ts
type Props = {
  isOpen: boolean;
  title: string;
  mimeType: string;
  base64Data: string;
  onClose: () => void;
};
```

Behavior:

* For `image/*`: `<img src={`data:${mimeType};base64,${base64Data}`} />`
* For `text/*`: decode base64 to string and render `<pre>`
* For `application/pdf`: convert base64 → Uint8Array → Blob → `URL.createObjectURL(blob)` → `<iframe src={blobUrl} />`

  * revoke object URL on close/unmount
* For unsupported mime: render message + “Use Download”.

### 3) Frontend API functions

#### File: `src/features/Vault/api/vaultApi.ts`

Add:

```ts
export async function getAttachmentPreview(attachmentId: string): Promise<BackendAttachmentPreviewPayload> {
  return invoke('get_attachment_preview', { attachmentId });
}
```

Define DTO in `src/features/Vault/types/backend.ts`:

```ts
export type BackendAttachmentPreviewPayload = {
  attachmentId: string;
  fileName: string;
  mimeType: string;
  byteSize: number;
  base64Data: string;
};
```

Map to UI type if needed.

### 4) Hook wiring (Details)

#### File: `src/features/Vault/components/Details/useDetails.tsx`

Add state:

* `previewOpen: boolean`
* `previewPayload: { title, mimeType, base64Data } | null`
* `isPreviewLoading: boolean`

Add handler for eye button:

```ts
const onPreviewAttachment = useCallback(async (attachmentId: string) => {
  setIsPreviewLoading(true);
  try {
    const payload = await getAttachmentPreview(attachmentId);
    setPreviewPayload({
      title: payload.fileName,
      mimeType: payload.mimeType,
      base64Data: payload.base64Data,
    });
    setPreviewOpen(true);
  } catch (e) {
    // handle ATTACHMENT_TOO_LARGE_FOR_PREVIEW and generic errors
    showToast(t('attachments.previewError'), 'error');
  } finally {
    setIsPreviewLoading(false);
  }
}, [showToast, t]);
```

Expose to `AttachmentsPanel`.

### 5) Download button behavior

Download must:

1. Ask user where to save (Save dialog).
2. Call backend `save_attachment_to_path(attachmentId, targetPath)`.

Frontend uses Tauri v2 dialog plugin:

* `import { save } from '@tauri-apps/plugin-dialog';`

In `useDetails.tsx`:

```ts
const onDownloadAttachment = useCallback(async (attachmentId: string, defaultName: string) => {
  const targetPath = await save({ defaultPath: defaultName });
  if (!targetPath) return;
  await saveAttachmentToPath(attachmentId, targetPath);
  showToast(t('attachments.downloadSuccess'), 'success');
}, [showToast, t]);
```

### 6) Delete with confirmation

Implement confirmation modal:

**New file:** `src/components/ConfirmDialog.tsx` (if not already exists)
or use existing modal system.

Behavior:

* Click trash → open confirm dialog:

  * title: “Delete attachment?”
  * body: “This will permanently remove the file from this card.”
  * buttons: Cancel / Delete (danger)
* On confirm:

  * call `purgeAttachment(attachmentId)`
  * refresh attachments list

---

## i18n

**File:** `src/i18n/English/Details.json` (or appropriate file)
Add:

```json
"attachments.title": "Attachments",
"attachments.addFile": "Add file",
"attachments.hint": "Drop files here or use the Add file button",
"attachments.previewError": "Unable to preview this attachment",
"attachments.downloadSuccess": "File saved",
"attachments.deleteTitle": "Delete attachment?",
"attachments.deleteBody": "This will permanently remove the file from this card.",
"attachments.deleteConfirm": "Delete",
"attachments.open": "Preview",
"attachments.download": "Download",
"attachments.delete": "Delete"
```

---

## Acceptance Criteria

1. Information view shows Attachments panel visually matching the provided screenshot:

   * header + “Add file”
   * list row with filename + `mime / size`
   * actions Eye / Download / Delete on the right
2. Eye opens an in-app modal:

   * images render inside app
   * pdf renders in iframe via Blob URL
   * text renders in `<pre>`
   * no decrypted temp files are created on disk for preview
3. Download opens a Save dialog and writes decrypted file to the chosen location
4. Delete requires confirmation and then removes the attachment from the list
5. Protected profile data remains encrypted at rest:

   * stored attachments remain encrypted
   * preview only decrypts in-memory

---

