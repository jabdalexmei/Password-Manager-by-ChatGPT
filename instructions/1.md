

# Technical Specification (EN): Bugfix & Hardening Pass (Windows-only)

## Scope

Fix all identified functional/UI bugs and harden weak points that may cause errors on Windows. Backward compatibility of settings is **out of scope** (project is in active dev).

---

## 1) Fix: Import/Export icons swapped in Vault header

### Problem

Export button displays import icon and import button displays download icon → confusing UX.

### File

`src/features/Vault/components/Header/VaultHeader.tsx`

### Change

Swap icons used in the two buttons.

#### Before

```tsx
<button ... aria-label={t('export')} onClick={onExportBackup}>
  <IconImport />
</button>
<button ... aria-label={t('import')} onClick={onImportBackup}>
  <IconDownload />
</button>
```

#### After

```tsx
<button ... aria-label={t('export')} onClick={onExportBackup}>
  <IconDownload />
</button>
<button ... aria-label={t('import')} onClick={onImportBackup}>
  <IconImport />
</button>
```

---

## 2) Fix: `Dialog` ignores `onOpenChange` (modal close behavior broken)

### Problem

`Dialog` defines `onOpenChange`, and screens rely on it (e.g. Settings modal), but `Dialog` never calls it. Result: expected close by clicking backdrop / pressing Esc does not work.

### File

`src/components/ui/dialog.tsx`

### Change

Implement:

* Backdrop click closes dialog (only when clicking the backdrop itself)
* `Escape` closes dialog
* Keep behavior no-op if `onOpenChange` is not provided

This aligns with typical accessible modal behavior (keyboard support for activation/closing is required).

#### Replace file contents with

```tsx
import React, { useEffect } from 'react';

type DialogProps = {
  open: boolean;
  onOpenChange?: (open: boolean) => void;
  children: React.ReactNode;
};

type DialogSlotProps = React.HTMLAttributes<HTMLDivElement>;
type DialogTitleProps = React.HTMLAttributes<HTMLHeadingElement>;

const mergeClasses = (base: string, extra?: string) => (extra ? `${base} ${extra}` : base);

export function Dialog({ open, onOpenChange, children }: DialogProps) {
  useEffect(() => {
    if (!open) return;

    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onOpenChange?.(false);
      }
    };

    window.addEventListener('keydown', onKeyDown);
    return () => window.removeEventListener('keydown', onKeyDown);
  }, [open, onOpenChange]);

  if (!open) return null;

  return (
    <div
      className="dialog-backdrop"
      onMouseDown={(e) => {
        if (e.target === e.currentTarget) {
          onOpenChange?.(false);
        }
      }}
    >
      {children}
    </div>
  );
}

export function DialogContent({ className, ...props }: DialogSlotProps) {
  return <div className={mergeClasses('dialog', className)} role="dialog" aria-modal="true" {...props} />;
}

export function DialogHeader({ className, ...props }: DialogSlotProps) {
  return <div className={mergeClasses('dialog-header', className)} {...props} />;
}

export function DialogTitle({ className, ...props }: DialogTitleProps) {
  return <h2 className={mergeClasses('dialog-title', className)} {...props} />;
}

export function DialogFooter({ className, ...props }: DialogSlotProps) {
  return <div className={mergeClasses('dialog-footer', className)} {...props} />;
}
```

---

## 3) Clipboard wipe hardening (Windows): increase retry window to 60×25ms

### Problem

Clipboard is a shared OS resource. `OpenClipboard` can fail when another process holds it; Microsoft explicitly notes this.
Your current implementation retries only 10×25ms = 250ms which is often not enough in real Windows usage.

### File

`src-tauri/src/services/clipboard_service.rs`

### Change

Increase attempts to 60 (≈ 1.5s). Keep sleep at 25ms. Also keep strict rule: every successful `OpenClipboard` must be followed by `CloseClipboard` (already enforced by guard).

#### Before

```rust
const ATTEMPTS: usize = 10;
const SLEEP_MS: u64 = 25;
```

#### After

```rust
const ATTEMPTS: usize = 60;
const SLEEP_MS: u64 = 25;
```

### Acceptance

* On a “clipboard busy” scenario, app retries up to ~1.5s before returning `CLIPBOARD_BUSY`.
* No clipboard handle leaks (CloseClipboard always called after successful open).

---

## 4) Ensure `clipboard_clear_all` remains correctly registered as a Tauri command

### Problem to avoid

Tauri requires registering all commands inside a single `invoke_handler(generate_handler![...])`. Multiple `invoke_handler` calls override the previous one.

### File

`src-tauri/src/main.rs`

### Requirement

Verify `clipboard_clear_all` is present exactly once inside the existing `tauri::generate_handler![ ... ]` list and there is only one `.invoke_handler(...)` call.

(No code changes needed if current state matches.)

---

## 5) Auto-backup spam hardening (already present, but lock it as a rule)

### Requirement

Keep the existing behavior:

* In `src/features/Vault/Vault.tsx`, when `createBackupIfDueAuto()` returns `BACKUP_ALREADY_RUNNING`, ignore it silently (no toast).
  Only show real errors.

This prevents “false error spam” during manual export/restore.

(If any future refactor touches this block, preserve the ignore rule.)

---

## 6) Remove trivial dead/low-quality code and formatting hazards (small but “ideal”)

### 6.1 Remove unused translation variable in Toaster provider (minor cleanup)

**File:** `src/components/Toaster.tsx`

Currently:

```ts
const { t: tCommon } = useTranslation('Common');
```

`ToasterProvider` never uses `tCommon`. Remove it to avoid lint/noUnusedLocals churn.

#### Change

Delete that line from `ToasterProvider` only. Keep `useTranslation` usage in `useToaster()` (it is used there).

---

## Final acceptance checklist

1. Import/export icons visually match their actions.
2. Settings modal (and any modal using `Dialog`) closes via backdrop click and Esc.
3. Clipboard wipe is resilient on Windows (60×25ms retries) and follows WinAPI rules.
4. No accidental Tauri command registration regression (single `invoke_handler` rule).
5. Auto-backup does not spam errors on `BACKUP_ALREADY_RUNNING`.

