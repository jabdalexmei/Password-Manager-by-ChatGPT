
# Technical Specification (EN): Backup / Restore / Auto-Backup (SQLite Online Backup API + ZIP Stored)

## 0. Scope

Implement backups for the Password Manager app:

1. **Export** (manual backup): user clicks Export icon → modal → choose destination path (or “Use default path”) → create backup archive.

2. **Import** (restore): user clicks Import icon → choose backup archive file → restore vault.db + attachments → force lock/logout → user reopens vault.

3. **Auto-backup**: enable/disable + configurable interval (minutes) via Settings modal in Vault header. While the app is running and the vault is open, the app will create backups automatically using default path.

Backups must:

* use **SQLite Online Backup API** for passwordless vaults (safe hot backup) ([SQLite][1])
* be packed as **ZIP with Stored (no compression)** entries ([Crates.io][2])
* include `manifest.json` with metadata + SHA-256 checksums for integrity verification.

---

## 1. Definitions

* **Profile root**: `profiles/<profile_id>/`
* **Vault file**: `profiles/<profile_id>/vault.db`

  * passwordless: real SQLite file
  * password-protected: encrypted blob written by `persist_active_vault` (NOT a SQLite file)
* **Attachments**: `profiles/<profile_id>/attachments/*.bin`
* **Default backup folder**: `profiles/<profile_id>/backups/` (already created by `ensure_profile_dirs`)

---

## 2. UX Requirements

### 2.1 Export (VaultHeader Download icon)

**Location**: `src/features/Vault/components/Header/VaultHeader.tsx`

* Enable Export button (remove `disabled`).
* On click, open **Export Backup** modal.

**Export Backup Modal**

* Checkbox: `Use default path`
* If checked:

  * destination is auto-generated:
    `profiles/<profile_id>/backups/backup_<YYYY-MM-DD_HH-mm-ss>_<profile_id>.pmbackup.zip`
* If unchecked:

  * user chooses destination file using `@tauri-apps/plugin-dialog` `save()` ([Tauri][3])
  * suggested default filename: `backup_<timestamp>_<profile_id>.pmbackup.zip`
  * file filter: `pmbackup`, `zip`
* Show progress state while backup runs (disable modal controls).
* On success: toast “Backup created”
* On failure: toast with error code.

### 2.2 Import (VaultHeader Import icon)

* Enable Import button (remove `disabled`).
* On click:

  * open file dialog `open()` (single file) with filter (`pmbackup`, `zip`) ([Tauri][3])
  * show confirmation dialog:

    * title: “Restore backup”
    * body: “This will replace your current vault and attachments. You will be logged out/locked.”
* On confirm:

  * call backend restore command
  * after success: **force lock/logout UI flow** (call `onLocked()` / navigate back to login)
  * toast “Backup restored. Please log in again.”
* On failure: toast with error code.

### 2.3 Settings (VaultHeader Settings icon)

* Enable Settings button.
* Add minimal Settings modal containing only “Backups” section:

  * Toggle: `Auto backup enabled`
  * Dropdown / numeric input: `Interval (minutes)` (allowed range in validation)
  * Numeric input: `Retention days`
  * Save button
* Save triggers backend `update_settings` with merged settings object (do not reset unrelated settings).

---

## 3. Backup File Format

Backup archive: **ZIP (Stored / no compression)** ([Crates.io][2])

### 3.1 ZIP internal structure

```
manifest.json
vault.db
attachments/<attachment_id>.bin
(optional) config.json
(optional) user_settings.json
```

### 3.2 manifest.json schema (required)

```json
{
  "format_version": 1,
  "created_at_utc": "2025-12-26T10:15:30Z",
  "app_version": "0.1.0",
  "profile_id": "<uuid>",
  "vault_mode": "passwordless" | "protected",
  "files": [
    { "path": "vault.db", "sha256": "<hex>", "bytes": 123456 },
    { "path": "attachments/<id>.bin", "sha256": "<hex>", "bytes": 999 }
  ]
}
```

### 3.3 Integrity rules

* On backup create: compute SHA-256 for every file written into the archive and write to `manifest.json`.
* On restore: verify every file against `manifest.json` before applying changes. If any mismatch → abort restore with error code `BACKUP_INTEGRITY_FAILED`.

---

## 4. Backend Requirements (Rust)

### 4.1 New dependencies

**File**: `src-tauri/Cargo.toml`

1. Enable rusqlite backup feature (required for Online Backup API wrapper) ([Docs.rs][4])
   Change:

```toml
rusqlite = { version = "0.32", features = ["bundled", "serialize"] }
```

To:

```toml
rusqlite = { version = "0.32", features = ["bundled", "serialize", "backup"] }
```

2. Add ZIP writer (Stored method) ([Crates.io][2])

```toml
zip = { version = "0.6", default-features = false }
```

3. Add hashing + traversal + temp dir:

```toml
sha2 = "0.10"
hex = "0.4"
walkdir = "2.5"
tempfile = "3.10"
```

### 4.2 New module files

Create files:

* `src-tauri/src/commands/backup.rs`
* `src-tauri/src/services/backup_service.rs`

Update module exports:

**File**: `src-tauri/src/commands/mod.rs`

```rust
pub mod backup;
```

**File**: `src-tauri/src/main.rs`

* Add in `mod services { ... }`:

```rust
pub mod backup_service;
```

* Add in `use commands::{ ... }`:

```rust
backup::*,
```

* Add to `invoke_handler` list:

```rust
backup_create,
backup_restore,
backup_list,
backup_create_if_due_auto,
```

### 4.3 Path helpers

**File**: `src-tauri/src/data/profiles/paths.rs`

Add new functions:

* `backups_dir(sp, profile_id) -> PathBuf`  (returns `profile_dir/sp/.../backups`)
* `backup_registry_path(sp, profile_id) -> PathBuf` (returns `backups/registry.json`)

### 4.4 Backup registry

Store auto-backup metadata and list of local backups.

**Path**: `profiles/<profile_id>/backups/registry.json`

Schema:

```json
{
  "last_auto_backup_at_utc": "2025-12-26T10:00:00Z",
  "backups": [
    {
      "id": "backup_2025-12-26_10-00-00",
      "created_at_utc": "2025-12-26T10:00:00Z",
      "path": ".../profiles/<id>/backups/backup_....pmbackup.zip",
      "bytes": 1234567
    }
  ]
}
```

### 4.5 Commands API

#### 4.5.1 `backup_create`

**Command**: `backup_create(destination_path: Option<String>, use_default_path: bool) -> String`

* Requires user to be logged in (`VAULT_LOCKED` if not).
* Returns the final backup path string.

Behavior:

1. Resolve profile_id from state (same pattern as settings_service).
2. If `use_default_path == true`:

   * destination = `profiles/<id>/backups/<generated>.pmbackup.zip`
3. Else:

   * `destination_path` must be Some and valid → else `BACKUP_DESTINATION_REQUIRED`.
4. Create backup archive (see §4.7).
5. Update backups registry.
6. Apply retention policy (`backup_retention_days` from profile settings).

#### 4.5.2 `backup_list`

**Command**: `backup_list() -> Vec<BackupListItem>`

`BackupListItem`:

```rust
#[derive(Serialize)]
pub struct BackupListItem {
  pub id: String,
  pub created_at_utc: String,
  pub path: String,
  pub bytes: i64
}
```

List from registry, and filter out entries whose files no longer exist.

#### 4.5.3 `backup_restore`

**Command**: `backup_restore(backup_path: String) -> bool`

Behavior:

1. Call `security_service::lock_vault(state)` first (ensures:

   * protected vault is persisted to disk
   * DB pools cleared
   * user is logged out)
2. Open zip, read `manifest.json`, validate checksums.
3. Extract into temp directory.
4. Apply restore atomically:

   * Replace `profiles/<id>/vault.db`
   * Replace `profiles/<id>/attachments/` directory:

     * move current to `attachments.old.<uuid>`
     * move extracted `attachments/` into place
     * cleanup old on success, rollback on failure
5. Delete SQLite sidecar files for passwordless if present:

   * `vault.db-wal`
   * `vault.db-shm`
6. Return `true` if success.

#### 4.5.4 `backup_create_if_due_auto`

**Command**: `backup_create_if_due_auto() -> Option<String>`

* Reads profile settings:

  * `auto_backup_enabled`
  * `auto_backup_interval_minutes`
* Reads registry `last_auto_backup_at_utc`
* If not due → return `None`
* If due → create backup using default path and update `last_auto_backup_at_utc`, return `Some(path)`

This command will be called periodically from the frontend timer while the vault is open.

### 4.6 Settings changes (backend)

**File**: `src-tauri/src/types.rs` (struct `UserSettings`)

Add fields (with serde defaults so old JSON does not break):

```rust
#[serde(default = "default_auto_backup_interval_minutes")]
pub auto_backup_interval_minutes: i64,
pub auto_backup_enabled: bool,
```

Rules:

* Keep existing fields (`backups_enabled`, `backup_frequency`) for backward compatibility OR repurpose them carefully:

  * Preferred: **reuse `backups_enabled` as `auto_backup_enabled`** (keep JSON key name stable), and introduce `backup_interval_minutes`.
  * If renaming fields: must implement backward-compatible deserialization (do not break existing `user_settings.json`).

**File**: `src-tauri/src/services/settings_service.rs`

* Extend `validate_settings`:

  * `auto_backup_interval_minutes` must be in range `[5, 525600]` (min 5 minutes, max 1 year) when auto-backup enabled.
  * retention days remains `[1, 3650]`.

### 4.7 Backup creation algorithm (core logic)

Implement in `src-tauri/src/services/backup_service.rs`.

#### 4.7.1 Vault snapshot rules

* Determine vault mode:

  * `registry::get_profile(...).has_password == false` → passwordless
  * else → protected
* If protected:

  * call `security_service::persist_active_vault(state)` to flush current in-memory DB into encrypted blob file.
* If passwordless:

  * perform hot backup from source DB to temp `vault.db` using `rusqlite::backup` (Online Backup API wrapper) ([Docs.rs][4])
  * use `run_to_completion(pages_per_step, pause_between_pages, progress)` semantics (no UI progress required initially).

Online Backup API guarantees safe copying for running DB via init/step/finish pattern. ([SQLite][1])

#### 4.7.2 ZIP writing (Stored)

* Write to temporary file next to destination: `<dest>.tmp`
* ZIP entries must be created with **Stored** compression method (no compression). ([Crates.io][2])
* Add files in this order:

  1. `vault.db` (from temp snapshot)
  2. `attachments/**` (walk directory)
  3. `manifest.json` (write last, includes SHA-256 for all other files)
* Close ZIP writer.
* Rename `<dest>.tmp` → `<dest>` atomically.

#### 4.7.3 Concurrency guard

Ensure only one backup runs at a time:

* add `backup_guard: Mutex<()>` in `AppState` or a static mutex in backup_service module.
* If already locked → return error `BACKUP_ALREADY_RUNNING`.

### 4.8 Error codes (string codes)

Return `ErrorCodeString::new("<CODE>")` with these codes (minimum):

* `BACKUP_DESTINATION_REQUIRED`
* `BACKUP_DESTINATION_UNAVAILABLE`
* `BACKUP_ALREADY_RUNNING`
* `BACKUP_CREATE_FAILED`
* `BACKUP_ZIP_WRITE_FAILED`
* `BACKUP_MANIFEST_MISSING`
* `BACKUP_MANIFEST_INVALID`
* `BACKUP_INTEGRITY_FAILED`
* `BACKUP_RESTORE_FAILED`
* `BACKUP_ARCHIVE_INVALID`

---

## 5. Frontend Requirements (React/TS)

### 5.1 Add dialog plugin usage

Use `@tauri-apps/plugin-dialog` for save/open dialogs. ([Tauri][3])
Note: dialog-selected paths are added to scope but not persisted across restarts. This is acceptable because actual file writing is done via Rust commands. ([Tauri 中文网][5])

### 5.2 API additions

**File**: `src/features/Vault/api/vaultApi.ts`

Add:

```ts
export async function createBackup(destinationPath: string | null, useDefaultPath: boolean): Promise<string> {
  return invoke('backup_create', { destinationPath, useDefaultPath });
}

export async function restoreBackup(backupPath: string): Promise<boolean> {
  return invoke('backup_restore', { backupPath });
}

export async function listBackups(): Promise<Array<{ id: string; created_at_utc: string; path: string; bytes: number }>> {
  return invoke('backup_list');
}

export async function createBackupIfDueAuto(): Promise<string | null> {
  return invoke('backup_create_if_due_auto');
}

export async function updateSettings(settings: BackendUserSettings): Promise<boolean> {
  return invoke('update_settings', { settings });
}
```

### 5.3 Settings type updates

**File**: `src/features/Vault/types/backend.ts`

Extend `BackendUserSettings` with:

* `auto_backup_enabled: boolean` (or reuse existing `backups_enabled`)
* `auto_backup_interval_minutes: number` (or `backup_interval_minutes`)

Ensure UI merges these values properly.

### 5.4 VaultHeader wiring

**File**: `src/features/Vault/components/Header/VaultHeader.tsx`

* Add props:

  * `onExportBackup`
  * `onImportBackup`
  * `onOpenSettings`
* Remove `disabled` from export/import/settings buttons and call handlers.

### 5.5 New modals

Create:

* `src/features/Vault/components/modals/ExportBackupModal.tsx`
* `src/features/Vault/components/modals/ImportBackupModal.tsx`
* `src/features/Vault/components/modals/SettingsModal.tsx` (Backups-only section)

### 5.6 Auto-backup timer (while Vault is open)

**File**: `src/features/Vault/Vault.tsx`

When vault is mounted and settings loaded:

* If `auto_backup_enabled`:

  * start `setInterval` every 60 seconds:

    * call `createBackupIfDueAuto()`
    * if returned path is non-null → show toast “Auto-backup created”
* Clear interval on unmount.

Backend remains the source of truth for “due” logic (registry timestamp + interval).

---

## 6. i18n (English) strings

Add keys to `src/i18n/English/Vault.json`:

* `backup.export.title`
* `backup.export.useDefaultPath`
* `backup.export.choosePath`
* `backup.export.create`
* `backup.export.success`
* `backup.import.confirmTitle`
* `backup.import.confirmBody`
* `backup.import.chooseFile`
* `backup.import.restore`
* `backup.import.success`
* `backup.settings.title`
* `backup.settings.autoEnabled`
* `backup.settings.intervalMinutes`
* `backup.settings.retentionDays`
* `backup.settings.save`

(If Russian locale later: add equivalent RU JSON.)

---

## 7. Acceptance Criteria

1. Manual Export:

* Works for passwordless vault by producing valid ZIP that restores correctly.
* Uses SQLite online backup (no corrupted vault on hot backup). ([SQLite][1])
* Produces ZIP entries with Stored method (no compression). ([Crates.io][2])

2. Manual Import/Restore:

* Validates manifest + checksums.
* Restores vault and attachments atomically.
* Logs user out/locks vault after restore.

3. Auto-backup:

* Toggle + interval configurable in Settings modal.
* When enabled, backups appear in `profiles/<id>/backups/` automatically while vault is open.
* Retention deletes old backups.

4. No breaking changes:

* Existing `user_settings.json` must still load after updating settings schema (serde defaults required).

