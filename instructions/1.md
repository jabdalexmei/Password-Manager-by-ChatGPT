# Technical Specification (EN): Implement Auto-Lock (inactivity) + Settings UI (default 60s)

## 0) Context (current codebase)

* Settings model already contains fields:

  * `auto_lock_enabled: bool`
  * `auto_lock_timeout: i64` (seconds)
    in `src-tauri/src/types.rs` (UserSettings).
* Backend validation already enforces `auto_lock_timeout` in `[30..86400]` inside `src-tauri/src/services/settings_service.rs`.
* Frontend already has a `lock()` callback inside `src/features/Vault/useVault.ts` which calls `lockVault()` and then calls `onLocked()`.

## Goal

1. Add working inactivity-based auto-lock:

   * When enabled, after `N` seconds with no activity in the app window, lock the vault.
2. Add Settings UI controls:

   * **Enable auto-lock** (toggle)
   * **Auto-lock timeout (seconds)** (number input)
3. Default value “hardcoded” to **60 seconds** (new profiles / missing fields):

   * `auto_lock_enabled = true`
   * `auto_lock_timeout = 60`

## Accessibility requirement (toggle)

Implement toggles as WAI-ARIA Switch pattern: `role="switch"` + `aria-checked`, keyboard support (Space toggles). ([W3C][1])

---

## 1) Backend: defaults + serde fallback for missing fields

### File

`src-tauri/src/types.rs`

### 1.1 Add serde defaults for auto-lock fields in `UserSettings`

**Find:**

```rust
pub struct UserSettings {
    pub auto_hide_secret_timeout_seconds: i64,
    pub auto_lock_enabled: bool,
    pub auto_lock_timeout: i64,
    pub reveal_requires_confirmation: bool,
    ...
}
```

**Replace the two fields with:**

```rust
pub struct UserSettings {
    pub auto_hide_secret_timeout_seconds: i64,

    #[serde(default = "default_auto_lock_enabled")]
    pub auto_lock_enabled: bool,

    #[serde(default = "default_auto_lock_timeout_seconds")]
    pub auto_lock_timeout: i64,

    pub reveal_requires_confirmation: bool,
    ...
}
```

### 1.2 Add default functions (place near other defaults, e.g. near `default_auto_backup_interval_minutes`)

Add these functions in the same file (recommended near your existing defaults at the bottom):

```rust
fn default_auto_lock_enabled() -> bool {
    true
}

fn default_auto_lock_timeout_seconds() -> i64 {
    60
}
```

### 1.3 Change `UserSettings::default()` to 60 seconds

**Find in `impl Default for UserSettings`:**

```rust
auto_lock_enabled: true,
auto_lock_timeout: 300,
```

**Replace with:**

```rust
auto_lock_enabled: default_auto_lock_enabled(),
auto_lock_timeout: default_auto_lock_timeout_seconds(),
```

✅ Result:

* New profiles get 60 seconds.
* Old `user_settings.json` that don’t have these fields won’t crash—serde will fill defaults.

---

## 2) Frontend: Settings UI (toggle + timeout input)

### File

`src/features/Vault/components/modals/SettingsModal.tsx`

### 2.1 Add state

At the top of `SettingsModal` component state, add:

```tsx
const [autoLockEnabled, setAutoLockEnabled] = useState(false);
const [autoLockTimeoutSeconds, setAutoLockTimeoutSeconds] = useState('60');
```

### 2.2 Hydrate from `settings` when modal opens

In existing `useEffect(() => { if (!open || !settings) return; ... }, [open, settings]);`
add:

```tsx
setAutoLockEnabled(settings.auto_lock_enabled);
setAutoLockTimeoutSeconds(String(settings.auto_lock_timeout));
```

### 2.3 Update validation (`canSave`)

Inside your existing `canSave` `useMemo`, parse and validate:

```tsx
const lockTimeout = Number(autoLockTimeoutSeconds);
if (!Number.isFinite(lockTimeout)) return false;
if (autoLockEnabled && (lockTimeout < 30 || lockTimeout > 86400)) return false;
```

(Keep your existing backup validations unchanged.)

### 2.4 Update `handleSave()`

Inside `handleSave()`, parse/validate lock timeout and include fields in payload:

Add:

```tsx
const lockTimeout = Number(autoLockTimeoutSeconds);

if (!Number.isFinite(lockTimeout)) return;
if (autoLockEnabled && (lockTimeout < 30 || lockTimeout > 86400)) return;
```

Then in `nextSettings` add:

```tsx
auto_lock_enabled: autoLockEnabled,
auto_lock_timeout: lockTimeout,
```

### 2.5 UI layout: add “Security” section ABOVE “Backups”

In modal body, before the Backups subtitle, insert:

```tsx
<h3 id="security-title" style={subtitleStyle}>
  Security
</h3>

<div role="group" aria-labelledby="security-title" style={{ display: 'flex', flexDirection: 'column', gap: 14 }}>
  <div className="form-field" style={toggleRowStyle}>
    <label className="form-label" id="auto-lock-enabled-label" htmlFor="auto-lock-enabled-switch">
      Enable auto-lock
    </label>

    <div style={{ display: 'flex', justifyContent: 'center' }}>
      <button
        id="auto-lock-enabled-switch"
        type="button"
        role="switch"
        aria-checked={autoLockEnabled}
        aria-labelledby="auto-lock-enabled-label"
        disabled={busy}
        onClick={() => setAutoLockEnabled((v) => !v)}
        onKeyDown={(e) => {
          if (busy) return;
          if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            setAutoLockEnabled((v) => !v);
          }
        }}
        style={{
          width: 44,
          height: 24,
          borderRadius: 9999,
          border: autoLockEnabled
            ? '1px solid rgba(34, 197, 94, 0.95)'
            : '1px solid rgba(255, 255, 255, 0.25)',
          background: autoLockEnabled
            ? 'rgba(34, 197, 94, 0.55)'
            : 'rgba(255, 255, 255, 0.14)',
          padding: 0,
          display: 'inline-flex',
          alignItems: 'center',
          justifyContent: 'flex-start',
          cursor: busy ? 'not-allowed' : 'pointer',
          opacity: busy ? 0.65 : 1,
          outline: 'none',
        }}
      >
        <span
          style={{
            width: 18,
            height: 18,
            borderRadius: 9999,
            background: 'rgba(255, 255, 255, 0.95)',
            transform: autoLockEnabled ? 'translateX(22px)' : 'translateX(2px)',
            transition: 'transform 160ms ease',
          }}
        />
      </button>
    </div>
  </div>

  <div className="form-field">
    <label className="form-label" htmlFor="auto-lock-timeout-seconds">
      Auto-lock timeout (seconds)
    </label>
    <input
      id="auto-lock-timeout-seconds"
      type="number"
      min={30}
      max={86400}
      value={autoLockTimeoutSeconds}
      disabled={busy || !autoLockEnabled}
      inputMode="numeric"
      onChange={(event) => setAutoLockTimeoutSeconds(event.target.value)}
      style={fullWidthInputStyle}
    />
  </div>
</div>
```

This matches switch semantics + keyboard expectations for switches. ([W3C][1])

---

## 3) Frontend: inactivity timer that triggers lock

### File

`src/features/Vault/useVault.ts`

### 3.1 Add auto-lock effect (exact code)

Insert the following `useEffect` **after** your existing `const lock = useCallback(async () => { ... }, [...])` definition (so it can call `lock()`):

```ts
useEffect(() => {
  if (!settings?.auto_lock_enabled) return;

  const timeoutSec = Number(settings.auto_lock_timeout);
  if (!Number.isFinite(timeoutSec) || timeoutSec < 30 || timeoutSec > 86400) return;

  let timerId: number | null = null;

  const schedule = () => {
    if (timerId !== null) {
      window.clearTimeout(timerId);
    }
    timerId = window.setTimeout(() => {
      void lock();
    }, timeoutSec * 1000);
  };

  const onActivity = () => {
    schedule();
  };

  // start countdown immediately
  schedule();

  window.addEventListener('pointerdown', onActivity, { passive: true });
  window.addEventListener('keydown', onActivity);
  window.addEventListener('wheel', onActivity, { passive: true });
  window.addEventListener('focus', onActivity);

  return () => {
    if (timerId !== null) window.clearTimeout(timerId);
    window.removeEventListener('pointerdown', onActivity);
    window.removeEventListener('keydown', onActivity);
    window.removeEventListener('wheel', onActivity);
    window.removeEventListener('focus', onActivity);
  };
}, [settings?.auto_lock_enabled, settings?.auto_lock_timeout, lock]);
```

### Notes

* This is window-only inactivity (within your app), which is fine for your requirement (Windows-only, no OS idle API).
* On any user interaction event, timer resets.
* When timer fires, it calls your existing `lock()` which already handles backend lock + state reset + `onLocked()`.

---

## Acceptance Criteria

1. Defaults:

* New profiles / missing fields → `auto_lock_enabled=true` and `auto_lock_timeout=60`.

2. Settings UI:

* Security section exists above Backups.
* Enable auto-lock is a green switch when ON.
* Timeout input is disabled when auto-lock OFF.
* Save persists values.

3. Runtime:

* If enabled, after N seconds of no activity → vault locks (same as manual lock).
* Any pointerdown/keydown/wheel/focus resets countdown.

