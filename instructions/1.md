

## 1) Seed phrase: перенос из custom fields в datacards (DB + backend + frontend)

### File: `src-tauri/src/data/sqlite/schema.sql`

**Why:** add first-class columns to store encrypted seed phrase + selected word count.

```diff
--- before: src-tauri/src/data/sqlite/schema.sql
+++ after:  src-tauri/src/data/sqlite/schema.sql
@@
 CREATE TABLE IF NOT EXISTS datacards (
   id           TEXT PRIMARY KEY,
   folder_id    TEXT NULL,
 
   title        TEXT NOT NULL,
   url          TEXT NULL,
   email        TEXT NULL,
   username     TEXT NULL,
   mobile_phone TEXT NULL,
   note         TEXT NULL,
 
   is_favorite  INTEGER NOT NULL DEFAULT 0,
 
   tags_json           TEXT NOT NULL DEFAULT '[]',
   password_value      TEXT NULL,
   totp_uri            TEXT NULL,
+  seed_phrase_value   TEXT NULL,
+  seed_phrase_words   INTEGER NULL,
   custom_fields_json  TEXT NOT NULL DEFAULT '[]',
 
   created_at   TEXT NOT NULL,
   updated_at   TEXT NOT NULL,
   deleted_at   TEXT NULL
 );
```

---

### File: `src-tauri/src/data/sqlite/migrations.rs`

**Why:** bump schema version + safe upgrade from v6 → v7 by `ALTER TABLE` (без миграций-файлов, без “миллиарда” дропов на ровном месте).

```diff
--- before: src-tauri/src/data/sqlite/migrations.rs
+++ after:  src-tauri/src/data/sqlite/migrations.rs
@@
 use rusqlite::Connection;
 use rusqlite::OptionalExtension;
 
 use crate::error::{ErrorCodeString, Result};
 
-const CURRENT_SCHEMA_VERSION: i32 = 6;
+const CURRENT_SCHEMA_VERSION: i32 = 7;
 
 pub fn migrate_to_latest(conn: &Connection) -> Result<()> {
@@
     log::info!(
         "[DB][migrate] user_version={version}, current={CURRENT_SCHEMA_VERSION}"
     );
 
-    if version < CURRENT_SCHEMA_VERSION {
-        conn.execute_batch(
-            "PRAGMA foreign_keys = OFF;
-DROP TABLE IF EXISTS attachments;
-DROP TABLE IF EXISTS datacard_password_history;
-DROP TABLE IF EXISTS password_history;
-DROP TABLE IF EXISTS datacards;
-DROP TABLE IF EXISTS folders;
-DROP TABLE IF EXISTS user_settings;
-DROP TABLE IF EXISTS bank_cards;",
-        )
-        .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
-
-        conn.execute_batch(include_str!("schema.sql"))
-            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
-        conn.execute_batch(&format!("PRAGMA user_version = {CURRENT_SCHEMA_VERSION};"))
-            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
-        conn.execute_batch("PRAGMA foreign_keys = ON;")
-            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
-        return Ok(());
-    }
+    // Fresh DB (or reset state): create full schema at latest version.
+    if version == 0 {
+        conn.execute_batch(include_str!("schema.sql"))
+            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+        conn.execute_batch(&format!("PRAGMA user_version = {CURRENT_SCHEMA_VERSION};"))
+            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+        return Ok(());
+    }
+
+    // Legacy versions: easiest/safest is rebuild (you said old data is not important).
+    if version < 6 {
+        conn.execute_batch(
+            "PRAGMA foreign_keys = OFF;
+DROP TABLE IF EXISTS attachments;
+DROP TABLE IF EXISTS datacard_password_history;
+DROP TABLE IF EXISTS password_history;
+DROP TABLE IF EXISTS datacards;
+DROP TABLE IF EXISTS folders;
+DROP TABLE IF EXISTS user_settings;
+DROP TABLE IF EXISTS bank_cards;",
+        )
+        .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+
+        conn.execute_batch(include_str!("schema.sql"))
+            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+        conn.execute_batch(&format!("PRAGMA user_version = {CURRENT_SCHEMA_VERSION};"))
+            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+        conn.execute_batch("PRAGMA foreign_keys = ON;")
+            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+        return Ok(());
+    }
+
+    // v6 -> v7: add seed phrase columns (idempotent).
+    if version == 6 {
+        if !has_column(conn, "datacards", "seed_phrase_value")? {
+            conn.execute_batch("ALTER TABLE datacards ADD COLUMN seed_phrase_value TEXT NULL;")
+                .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+        }
+        if !has_column(conn, "datacards", "seed_phrase_words")? {
+            conn.execute_batch("ALTER TABLE datacards ADD COLUMN seed_phrase_words INTEGER NULL;")
+                .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+        }
+
+        conn.execute_batch(&format!("PRAGMA user_version = {CURRENT_SCHEMA_VERSION};"))
+            .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+        return Ok(());
+    }
 
     match version {
         CURRENT_SCHEMA_VERSION => Ok(()),
         _ => Err(ErrorCodeString::new("DB_MIGRATION_FAILED")),
     }
 }
 
 fn has_table(conn: &Connection, name: &str) -> Result<bool> {
@@
     Ok(exists.is_some())
 }
 
+fn has_column(conn: &Connection, table: &str, column: &str) -> Result<bool> {
+    let sql = "SELECT 1 FROM pragma_table_info(?1) WHERE name = ?2 LIMIT 1";
+    let exists: Option<i32> = conn
+        .query_row(sql, [table, column], |row| row.get(0))
+        .optional()
+        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+    Ok(exists.is_some())
+}
+
 pub fn validate_core_schema(conn: &Connection) -> Result<()> {
     let required = ["folders", "datacards", "bank_cards"];
     for table in required {
         if !has_table(conn, table)? {
```

---

### File: `src-tauri/src/types.rs`

**Why:** expose seed phrase + word count through backend API (create/update/get).

```diff
--- before: src-tauri/src/types.rs
+++ after:  src-tauri/src/types.rs
@@
 pub struct DataCard {
@@
     pub deleted_at: Option<String>,
 
     pub password: Option<String>,
     pub totp_uri: Option<String>,
+    pub seed_phrase: Option<String>,
+    pub seed_phrase_words: Option<i32>,
     pub custom_fields: Vec<CustomField>,
 }
@@
 pub struct CreateDataCardInput {
@@
     pub password: Option<String>,
     pub totp_uri: Option<String>,
+    pub seed_phrase: Option<String>,
+    pub seed_phrase_words: Option<i32>,
     pub custom_fields: Vec<CustomField>,
     pub folder_id: Option<String>,
 }
@@
 pub struct UpdateDataCardInput {
@@
     pub password: Option<String>,
     pub totp_uri: Option<String>,
+    pub seed_phrase: Option<String>,
+    pub seed_phrase_words: Option<i32>,
     pub custom_fields: Vec<CustomField>,
     pub folder_id: Option<String>,
 }
```

---

### File: `src-tauri/src/data/sqlite/repo_impl.rs`

**Why:** read/write new DB columns.

```diff
--- before: src-tauri/src/data/sqlite/repo_impl.rs
+++ after:  src-tauri/src/data/sqlite/repo_impl.rs
@@
 fn map_datacard(row: &rusqlite::Row) -> rusqlite::Result<DataCard> {
     Ok(DataCard {
@@
         deleted_at: row.get("deleted_at")?,
         password: row.get("password_value")?,
         totp_uri: row.get("totp_uri")?,
+        seed_phrase: row.get("seed_phrase_value")?,
+        seed_phrase_words: row.get("seed_phrase_words")?,
         custom_fields: deserialize_json(row.get::<_, String>("custom_fields_json")?)?,
     })
 }
@@
 pub fn create_datacard(
@@
     with_connection(state, profile_id, |conn| {
         let tags_json = serialize_json(&input.tags)?;
         let custom_fields_json = serialize_json(&input.custom_fields)?;
         let now = Utc::now().to_rfc3339();
         let id = Uuid::new_v4().to_string();
         conn.execute(
-            "INSERT INTO datacards (id, folder_id, title, url, email, username, mobile_phone, note, is_favorite, tags_json, password_value, totp_uri, custom_fields_json, created_at, updated_at, deleted_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, 0, ?9, ?10, ?11, ?12, ?13, ?14, NULL)",
+            "INSERT INTO datacards (id, folder_id, title, url, email, username, mobile_phone, note, is_favorite, tags_json, password_value, totp_uri, seed_phrase_value, seed_phrase_words, custom_fields_json, created_at, updated_at, deleted_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, 0, ?9, ?10, ?11, ?12, ?13, ?14, ?15, ?16, NULL)",
             params![
                 id,
                 input.folder_id,
                 input.title,
                 input.url,
                 input.email,
                 input.username,
                 input.mobile_phone,
                 input.note,
                 tags_json,
                 input.password,
                 input.totp_uri,
+                input.seed_phrase,
+                input.seed_phrase_words,
                 custom_fields_json,
                 now,
                 now
             ],
         )
         .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
 
         get_datacard_by_id_conn(conn, &id)
     })
 }
@@
 pub fn update_datacard(
@@
         let rows = conn
             .execute(
-                "UPDATE datacards SET title = ?1, url = ?2, email = ?3, username = ?4, mobile_phone = ?5, note = ?6, tags_json = ?7, password_value = ?8, totp_uri = ?9, custom_fields_json = ?10, folder_id = ?11, updated_at = ?12 WHERE id = ?13",
+                "UPDATE datacards SET title = ?1, url = ?2, email = ?3, username = ?4, mobile_phone = ?5, note = ?6, tags_json = ?7, password_value = ?8, totp_uri = ?9, seed_phrase_value = ?10, seed_phrase_words = ?11, custom_fields_json = ?12, folder_id = ?13, updated_at = ?14 WHERE id = ?15",
                 params![
                     input.title,
                     input.url,
                     input.email,
                     input.username,
                     input.mobile_phone,
                     input.note,
                     tags_json,
                     input.password,
                     input.totp_uri,
+                    input.seed_phrase,
+                    input.seed_phrase_words,
                     custom_fields_json,
                     input.folder_id,
                     now,
                     input.id
                 ],
             )
             .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
```

---

### File: `src-tauri/src/services/datacards_service.rs`

**Why:** validate seed phrase and enforce correct Count (12/18/24) at the backend, чтобы UI/DB не расходились.

```diff
--- before: src-tauri/src/services/datacards_service.rs
+++ after:  src-tauri/src/services/datacards_service.rs
@@
 use crate::error::{ErrorCodeString, Result};
 use crate::state::AppState;
 use crate::types::{CreateDataCardInput, DataCard, DataCardSummary, UpdateDataCardInput};
@@
 pub fn create_datacard(state: &Arc<AppState>, profile_id: &str, input: CreateDataCardInput) -> Result<DataCard> {
-    repo_impl::create_datacard(state, profile_id, &input)
+    let mut input = input;
+    let (seed_phrase, seed_phrase_words) = normalize_seed_phrase(input.seed_phrase, input.seed_phrase_words)?;
+    input.seed_phrase = seed_phrase;
+    input.seed_phrase_words = seed_phrase_words;
+    repo_impl::create_datacard(state, profile_id, &input)
 }
 
 pub fn update_datacard(
     state: &Arc<AppState>,
     profile_id: &str,
     input: UpdateDataCardInput,
 ) -> Result<bool> {
-    repo_impl::update_datacard(state, profile_id, &input)
+    let mut input = input;
+    let (seed_phrase, seed_phrase_words) = normalize_seed_phrase(input.seed_phrase, input.seed_phrase_words)?;
+    input.seed_phrase = seed_phrase;
+    input.seed_phrase_words = seed_phrase_words;
+    repo_impl::update_datacard(state, profile_id, &input)
 }
+
+fn normalize_seed_phrase(
+    seed_phrase: Option<String>,
+    seed_phrase_words: Option<i32>,
+) -> Result<(Option<String>, Option<i32>)> {
+    let normalized = seed_phrase.unwrap_or_default().trim().to_string();
+    if normalized.is_empty() {
+        return Ok((None, None));
+    }
+
+    let words = seed_phrase_words.ok_or_else(|| ErrorCodeString::new("SEED_PHRASE_WORD_COUNT_MISSING"))?;
+    if words != 12 && words != 18 && words != 24 {
+        return Err(ErrorCodeString::new("SEED_PHRASE_WORD_COUNT_INVALID"));
+    }
+
+    let actual = normalized.split_whitespace().count() as i32;
+    if actual != words {
+        return Err(ErrorCodeString::new("SEED_PHRASE_WORD_COUNT_MISMATCH"));
+    }
+
+    Ok((Some(normalized), Some(words)))
+}
```

---

### File: `src/features/Vault/types/backend.ts`

**Why:** frontend must send/receive new fields.

```diff
--- before: src/features/Vault/types/backend.ts
+++ after:  src/features/Vault/types/backend.ts
@@
 export type BackendDataCard = {
@@
   password: string | null;
   totp_uri: string | null;
+  seed_phrase: string | null;
+  seed_phrase_words: number | null;
   custom_fields: BackendCustomField[];
 };
@@
 export type BackendCreateDataCardInput = {
@@
   password: string | null;
   totp_uri: string | null;
+  seed_phrase: string | null;
+  seed_phrase_words: number | null;
   custom_fields: BackendCustomField[];
 };
```

---

### File: `src/features/Vault/types/ui.ts`

**Why:** app state/form needs to carry seed phrase and count.

```diff
--- before: src/features/Vault/types/ui.ts
+++ after:  src/features/Vault/types/ui.ts
@@
 export type DataCard = {
@@
   password: string | null;
   totpUri: string | null;
+  seedPhrase: string | null;
+  seedPhraseWords: number | null;
   customFields: CustomField[];
 };
@@
 export type CreateDataCardInput = {
@@
   password: string | null;
   totpUri: string | null;
+  seedPhrase: string | null;
+  seedPhraseWords: number | null;
   customFields: CustomField[];
 };
```

---

### File: `src/features/Vault/types/mappers.ts`

**Why:** map backend snake_case fields into UI camelCase.

```diff
--- before: src/features/Vault/types/mappers.ts
+++ after:  src/features/Vault/types/mappers.ts
@@
 export const mapBackendDataCardToUi = (card: BackendDataCard): DataCard => ({
@@
   password: card.password,
   totpUri: card.totp_uri,
+  seedPhrase: card.seed_phrase,
+  seedPhraseWords: card.seed_phrase_words,
   customFields: card.custom_fields.map(mapBackendCustomFieldToUi),
 });
@@
 export const mapCreateDataCardInputToBackend = (input: CreateDataCardInput): BackendCreateDataCardInput => ({
@@
   password: input.password,
   totp_uri: input.totpUri,
+  seed_phrase: input.seedPhrase,
+  seed_phrase_words: input.seedPhraseWords,
   custom_fields: input.customFields.map(mapCustomFieldInputToBackend),
 });
```

---

### File: `src/features/Vault/components/DataCards/useDataCards.ts`

**Why:** stop using custom fields for seed phrase; keep it in form state and send to backend.

```diff
--- before: src/features/Vault/components/DataCards/useDataCards.ts
+++ after:  src/features/Vault/components/DataCards/useDataCards.ts
@@
 export type DataCardFormState = {
   title: string;
   folderId: string | null;
   folderName: string;
   url: string;
   email: string;
   username: string;
   password: string;
   mobilePhone: string;
   note: string;
   tagsText: string;
   totpUri: string;
+  seedPhrase: string;
+  seedPhraseWords: number;
   customFields: CustomFieldFormRow[];
 };
@@
 export type DataCardsViewModel = {
@@
-  setCreateCustomFieldByKey: (key: string, value: string, type: CustomFieldType) => void;
-  setEditCustomFieldByKey: (key: string, value: string, type: CustomFieldType) => void;
   createAttachments: { name: string; path: string }[];
   removeCreateAttachment: (path: string) => void;
 };
@@
 const blankForm: DataCardFormState = {
   title: '',
   folderId: null,
   folderName: '',
   url: '',
   email: '',
   username: '',
   password: '',
   mobilePhone: '',
   note: '',
   tagsText: '',
   totpUri: '',
+  seedPhrase: '',
+  seedPhraseWords: 0,
   customFields: [],
 };
@@
   const openEditModal = useCallback(
     (card: DataCard) => {
       setEditForm({
@@
         tagsText: card.tags.join(', '),
         totpUri: card.totpUri ?? '',
+        seedPhrase: card.seedPhrase ?? '',
+        seedPhraseWords: card.seedPhraseWords ?? 0,
         customFields: card.customFields.map((field) => ({
           id: crypto.randomUUID(),
           key: field.key,
           value: field.value,
           type: field.type,
         })),
       });
       setIsEditOpen(true);
     },
     []
   );
@@
   const buildCreateInput = useCallback((form: DataCardFormState): CreateDataCardInput => {
@@
     return {
@@
       password: normalized(form.password),
       totpUri: normalized(form.totpUri),
+      seedPhrase: normalized(form.seedPhrase),
+      seedPhraseWords: form.seedPhraseWords > 0 ? form.seedPhraseWords : null,
       customFields: customFields.map((f) => ({ key: f.key.trim(), value: f.value, type: f.type })),
     };
   }, []);
@@
   const buildUpdateInput = useCallback((id: string, form: DataCardFormState): UpdateDataCardInput => {
     const base = buildCreateInput(form);
     return { ...base, id };
   }, [buildCreateInput]);
@@
-  const setCreateCustomFieldByKey = useCallback((key: string, value: string, type: CustomFieldType) => {
-    setCreateForm((prev) => {
-      const existing = prev.customFields.find((f) => f.key === key);
-      if (existing) {
-        return {
-          ...prev,
-          customFields: prev.customFields.map((f) => (f.key === key ? { ...f, value, type } : f)),
-        };
-      }
-      return {
-        ...prev,
-        customFields: [
-          ...prev.customFields,
-          { id: crypto.randomUUID(), key, value, type },
-        ],
-      };
-    });
-  }, []);
-
-  const setEditCustomFieldByKey = useCallback((key: string, value: string, type: CustomFieldType) => {
-    setEditForm((prev) => {
-      if (!prev) return prev;
-      const existing = prev.customFields.find((f) => f.key === key);
-      if (existing) {
-        return {
-          ...prev,
-          customFields: prev.customFields.map((f) => (f.key === key ? { ...f, value, type } : f)),
-        };
-      }
-      return {
-        ...prev,
-        customFields: [
-          ...prev.customFields,
-          { id: crypto.randomUUID(), key, value, type },
-        ],
-      };
-    });
-  }, []);
@@
   return {
@@
-    setCreateCustomFieldByKey,
-    setEditCustomFieldByKey,
     createAttachments,
     removeCreateAttachment,
   };
```

---

### File: `src/features/Vault/components/DataCards/DataCards.tsx`

**Why:** UI logic: seed phrase summary uses `seedPhraseWords`, action menu shows Add/Edit правильно, и seed phrase больше не “портит” custom fields.

```diff
--- before: src/features/Vault/components/DataCards/DataCards.tsx
+++ after:  src/features/Vault/components/DataCards/DataCards.tsx
@@
-import { SeedPhraseModal } from '../modals/SeedPhraseModal';
+import { SeedPhraseModal } from '../modals/SeedPhraseModal';
@@
-const SEED_PHRASE_FIELD_KEY = 'Seed phrase';
-const SEED_PHRASE_COUNT_KEY = '__seed_phrase_count';
-
 type DialogMode = 'create' | 'edit' | null;
@@
-  const visibleCustomFields = form.customFields.filter(
-    (field) => field.key !== SEED_PHRASE_FIELD_KEY && field.key !== SEED_PHRASE_COUNT_KEY
-  );
+  const visibleCustomFields = form.customFields;
@@
-  const seedPhraseRow = form.customFields.find((f) => f.key === SEED_PHRASE_FIELD_KEY);
-  const seedPhraseCountRow = form.customFields.find((f) => f.key === SEED_PHRASE_COUNT_KEY);
-  const seedPhraseValue = seedPhraseRow ? seedPhraseRow.value : '';
-  const seedPhraseWordCount =
-    seedPhraseCountRow && seedPhraseCountRow.value.trim()
-      ? Number(seedPhraseCountRow.value.trim())
-      : (seedPhraseValue.trim() ? seedPhraseValue.trim().split(/\s+/).filter(Boolean).length : 0);
+  const seedPhraseValue = form.seedPhrase;
+  const seedPhraseWordCount = form.seedPhraseWords;
@@
-  const handleOpenSeedPhrase = () => {
+  const handleOpenSeedPhrase = () => {
     setIsSeedPhraseOpen(true);
     setIsActionMenuOpen(false);
   };
@@
           <div className="dialog-actionmenu">
@@
-            <button type="button" className="dialog-actionmenu-item" onClick={handleOpenSeedPhrase}>
-              {t('seedPhrase.addAction')}
-            </button>
+            <button type="button" className="dialog-actionmenu-item" onClick={handleOpenSeedPhrase}>
+              {seedPhraseWordCount > 0 ? t('seedPhrase.editAction') : t('seedPhrase.addAction')}
+            </button>
@@
-            {visibleCustomFields.length > 0 && (
+            {visibleCustomFields.length > 0 && (
               <button type="button" className="dialog-actionmenu-item" onClick={() => setIsEditFieldsOpen(true)}>
                 {t('customFields.editFields')}
               </button>
             )}
@@
         {seedPhraseWordCount > 0 && (
           <div className="seedphrase-summary">
             <div className="seedphrase-summary-count">{t('seedPhrase.wordsCount', { count: seedPhraseWordCount })}</div>
-            <button className="btn btn-secondary" type="button" onClick={handleOpenSeedPhrase}>
-              {t('seedPhrase.editAction')}
-            </button>
+            <button className="btn btn-secondary" type="button" onClick={handleOpenSeedPhrase}>
+              {t('seedPhrase.editAction')}
+            </button>
           </div>
         )}
@@
       <SeedPhraseModal
         isOpen={isSeedPhraseOpen}
-        existingPhrase={seedPhraseValue || null}
+        existingPhrase={seedPhraseValue || null}
         onCancel={() => setIsSeedPhraseOpen(false)}
         onSave={(words, wordCount) => {
           const phrase = words.join(' ');
           if (dialogMode === 'create') {
-            viewModel.setCreateCustomFieldByKey(SEED_PHRASE_FIELD_KEY, phrase, 'secret');
-            viewModel.setCreateCustomFieldByKey(SEED_PHRASE_COUNT_KEY, String(wordCount), 'text');
+            setCreateForm((prev) => ({ ...prev, seedPhrase: phrase, seedPhraseWords: wordCount }));
           } else {
-            viewModel.setEditCustomFieldByKey(SEED_PHRASE_FIELD_KEY, phrase, 'secret');
-            viewModel.setEditCustomFieldByKey(SEED_PHRASE_COUNT_KEY, String(wordCount), 'text');
+            setEditForm((prev) => (prev ? { ...prev, seedPhrase: phrase, seedPhraseWords: wordCount } : prev));
           }
           setIsSeedPhraseOpen(false);
         }}
       />
```

> ВАЖНО: в этом файле я использовал `setCreateForm / setEditForm` — если у тебя они сейчас не в области видимости (потому что формы управляются только через viewModel), тогда делаем это через `viewModel.updateCreateForm(...) / viewModel.updateEditForm(...)`. В текущем архиве формы живут в `useDataCards.ts`, поэтому в `DataCards.tsx` нужно добавить колбэки из viewModel (см. ниже блок 100% применимый).

Чтобы это было **строго применимо к текущей архитектуре** (без “магии”), добавляем в `useDataCards.ts` 2 метода и используем их в `DataCards.tsx`.

#### Дополнение — `src/features/Vault/components/DataCards/useDataCards.ts` (добавить методы)

```diff
--- before: src/features/Vault/components/DataCards/useDataCards.ts
+++ after:  src/features/Vault/components/DataCards/useDataCards.ts
@@
 export type DataCardsViewModel = {
@@
   removeCreateAttachment: (path: string) => void;
+  setCreateSeedPhrase: (phrase: string, words: number) => void;
+  setEditSeedPhrase: (phrase: string, words: number) => void;
 };
@@
   const removeCreateAttachment = useCallback((path: string) => {
     setCreateAttachments((prev) => prev.filter((file) => file.path !== path));
   }, []);
+
+  const setCreateSeedPhrase = useCallback((phrase: string, words: number) => {
+    setCreateForm((prev) => ({ ...prev, seedPhrase: phrase, seedPhraseWords: words }));
+  }, []);
+
+  const setEditSeedPhrase = useCallback((phrase: string, words: number) => {
+    setEditForm((prev) => (prev ? { ...prev, seedPhrase: phrase, seedPhraseWords: words } : prev));
+  }, []);
@@
   return {
@@
     createAttachments,
     removeCreateAttachment,
+    setCreateSeedPhrase,
+    setEditSeedPhrase,
   };
```

#### И тогда `DataCards.tsx` onSave становится 100% корректным:

```diff
--- before: src/features/Vault/components/DataCards/DataCards.tsx
+++ after:  src/features/Vault/components/DataCards/DataCards.tsx
@@
         onSave={(words, wordCount) => {
           const phrase = words.join(' ');
           if (dialogMode === 'create') {
-            setCreateForm((prev) => ({ ...prev, seedPhrase: phrase, seedPhraseWords: wordCount }));
+            viewModel.setCreateSeedPhrase(phrase, wordCount);
           } else {
-            setEditForm((prev) => (prev ? { ...prev, seedPhrase: phrase, seedPhraseWords: wordCount } : prev));
+            viewModel.setEditSeedPhrase(phrase, wordCount);
           }
           setIsSeedPhraseOpen(false);
         }}
       />
```

---

## 2) Fix: “Create data card растёт и нет возможности прокрутить”

Причина: `.dialog-body` **не растягивается как flex-child**, из-за чего overflow-scroll местами не включается, и контент уезжает вниз.

### File: `src/shared/styles/ui.css`

```diff
--- before: src/shared/styles/ui.css
+++ after:  src/shared/styles/ui.css
@@
 .dialog-body {
   padding: 16px 18px;
   display: flex;
   flex-direction: column;
   gap: 12px;
+  flex: 1 1 auto;
   /* Allow the body to shrink inside flex container and become scrollable. */
   min-height: 0;
   overflow-y: auto;
 }
```


