

## Technical Specification (EN): Show custom fields in Edit dialog + persist

### Goal

1. **Edit data card** dialog must **display existing custom fields** and allow editing their **values**.
2. On **Save**, custom fields must be **persisted** (sent to backend in `custom_fields` via existing Tauri command flow).
3. Custom fields must render **after Mobile phone** and **before Note** (same placement as requested for Create).

### Non-goals

* No DB migrations.
* No “rename custom field key” in Edit (name stays fixed; only value is editable).
* No remove/reorder actions in Edit (optional later).

---

## Current state (from your code)

* Edit form state does **not** include custom fields:
  `src/features/Vault/components/DataCards/useDataCards.ts` → `DataCardFormState` has only base fields.
* Edit modal UI does **not** render custom fields:
  `src/features/Vault/components/DataCards/DataCards.tsx` renders `mobilePhone` then immediately `note`.
* Backend mapper always sends `custom_fields: []` (so nothing persists):
  `src/features/Vault/types/mappers.ts` → `mapCreateCardToBackend(...)` hardcodes `custom_fields: []`.

---

## Required changes

### 1) Add `customFields` to Create/Update input types

**File:** `src/features/Vault/types/ui.ts`

**Change:** extend `CreateDataCardInput`:

```ts
import type { CustomField } from "./ui"; // only if needed, keep local style consistent

export type CreateDataCardInput = {
  folderId: string | null;
  title: string;
  url?: string | null;
  email?: string | null;
  username?: string | null;
  mobilePhone?: string | null;
  note?: string | null;
  tags?: string[];
  password?: string | null;

  // NEW
  customFields?: CustomField[];
};
```

`UpdateDataCardInput` already extends `CreateDataCardInput`, so it will inherit `customFields`.

---

### 2) Persist custom fields in backend mappers (Create + Update)

**File:** `src/features/Vault/types/mappers.ts`

**Change:** in `mapCreateCardToBackend(input: CreateDataCardInput)` replace:

```ts
custom_fields: [],
```

with:

```ts
custom_fields: (input.customFields ?? []).map((f) => ({
  key: f.key,
  value: f.value,
  type: f.type,
})),
```

`mapUpdateCardToBackend` already spreads `mapCreateCardToBackend`, so Update will persist automatically.

---

### 3) Extend Edit/Create form state to carry custom fields

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

#### 3.1 Add UI row type (stable `id` for React keys)

Add near the top (after imports):

```ts
import type { CustomFieldType } from "../../types/ui";

type CustomFieldFormRow = {
  id: string;          // UI-only stable id
  key: string;         // custom field name (fixed in Edit)
  value: string;       // editable in Edit
  type: CustomFieldType; // keep as-is (text/secret/...)
};
```

#### 3.2 Update `DataCardFormState`

Replace current type:

```ts
export type DataCardFormState = {
  title: string;
  folderId: string | null;
  folderName: string;
  url: string;
  email: string;
  username: string;
  password: string;
  mobilePhone: string;
  note: string;
  tagsText: string;
};
```

with:

```ts
export type DataCardFormState = {
  title: string;
  folderId: string | null;
  folderName: string;
  url: string;
  email: string;
  username: string;
  password: string;
  mobilePhone: string;
  note: string;
  tagsText: string;

  // NEW
  customFields: CustomFieldFormRow[];
};
```

#### 3.3 Update initial form builder

In `buildInitialForm(...)` include:

```ts
customFields: [],
```

#### 3.4 Add helper for stable ids

Add near helpers in this file:

```ts
const makeRowId = () =>
  globalThis.crypto?.randomUUID?.() ?? `cf_${Date.now()}_${Math.random().toString(16).slice(2)}`;
```

---

### 4) Load existing custom fields into Edit dialog

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

In `openEditModal(card: DataCard)` extend `setEditForm({ ... })` with:

```ts
customFields: (card.customFields ?? []).map((f) => ({
  id: makeRowId(),
  key: f.key,
  value: f.value,
  type: f.type,
})),
```

So the edit modal displays whatever is already stored on the card.

---

### 5) Allow editing custom field values in Edit form state

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

Add a dedicated method (do NOT try to reuse `updateEditField`, because `customFields` is not a string field).

Add:

```ts
const updateEditCustomFieldValue = useCallback((rowId: string, value: string) => {
  setEditForm((prev) => {
    if (!prev) return prev;
    return {
      ...prev,
      customFields: prev.customFields.map((r) => (r.id === rowId ? { ...r, value } : r)),
    };
  });
}, []);
```

Expose it from the hook return object (and add to the returned view model type):

```ts
updateEditCustomFieldValue,
```

---

### 6) Include custom fields in submit payload (Edit)

**File:** `src/features/Vault/components/DataCards/useDataCards.ts`

Update `buildCreateInput(form: DataCardFormState)` (it is used by `buildUpdateInput` too) by adding:

```ts
customFields: form.customFields.map((r) => ({
  key: r.key,
  value: r.value,
  type: r.type,
})),
```

Final:

```ts
const buildCreateInput = (form: DataCardFormState): CreateDataCardInput => ({
  folderId: form.folderId,
  title: form.title.trim(),
  url: normalizeOptional(form.url),
  email: normalizeOptional(form.email),
  username: normalizeOptional(form.username),
  password: normalizeOptional(form.password),
  mobilePhone: normalizeOptional(form.mobilePhone),
  note: normalizeOptional(form.note),
  tags: normalizeTags(form.tagsText),

  // NEW
  customFields: form.customFields.map((r) => ({
    key: r.key,
    value: r.value,
    type: r.type,
  })),
});
```

Now Update submit will persist custom fields because:

* `buildUpdateInput` spreads `buildCreateInput`
* mapper now maps `customFields` → `custom_fields`

---

### 7) Render custom fields in Edit dialog UI (after Mobile phone)

**File:** `src/features/Vault/components/DataCards/DataCards.tsx`

Locate Mobile phone block and Note block. Currently it is:

```tsx
<div className="form-field">
  ...
  value={form.mobilePhone}
  onChange={(e) => onFieldChange('mobilePhone', e.target.value)}
</div>

<div className="form-field">
  <label ...>{t('label.note')}</label>
  <textarea ...
```

**Insert between them**:

```tsx
{form.customFields.map((row) => (
  <div className="form-field" key={row.id}>
    <label className="form-label" htmlFor={`${dialogId}-cf-${row.id}`}>
      {row.key}
    </label>
    <input
      id={`${dialogId}-cf-${row.id}`}
      className="input"
      value={row.value}
      onChange={(e) => {
        // Edit dialog only: values editable, names fixed
        if (dialogId === 'datacard-edit-dialog') {
          viewModel.updateEditCustomFieldValue(row.id, e.target.value);
        }
      }}
      disabled={dialogId !== 'datacard-edit-dialog'}
    />
  </div>
))}
```

Notes:

* This TS focuses on Edit dialog. If you already implement Create custom fields, you can remove the `disabled` branch and wire create separately.
* Key point: **custom fields appear after Mobile phone** as requested.

---

## Acceptance criteria

1. Open an existing card that has `customFields` on it → Edit dialog shows those fields **after Mobile phone**.
2. User changes custom field value, clicks Save → value persists.
3. Reopen Edit dialog → changed values are still present.
4. No accidental wipe: editing title/url/etc does **not** clear custom fields.

---

## Manual QA checklist

* Create a card with custom fields (via your Create flow).
* Open Edit modal:

  * custom field rows exist, labels match keys
  * change values, Save
* Refresh app / reopen card:

  * Details panel (if implemented) shows updated values
  * Edit modal shows updated values


