

# TS (EN): Fix Windows clipboard wipe build + ensure auto-clear always wipes

## A) Fix build error: `windows_sys::Win32::Foundation::BOOL` unresolved

### Problem

Your build fails with:

```
unresolved import windows_sys::Win32::Foundation::BOOL
```

Because the `windows-sys` version actually used in your build (per Cargo.lock resolution) does not export `BOOL` in `Win32::Foundation` the way your code expects. This is a common mismatch across `windows-sys` versions and lockfile state. (WinAPI functions still return “BOOL” conceptually, but bindings may expose it as `i32`.) ([Microsoft Learn][2])

### Change 1: Remove BOOL import and explicit BOOL typing

**File:** `src-tauri/src/services/clipboard_service.rs`

**Before:**

```rust
use windows_sys::Win32::Foundation::{GetLastError, BOOL};
use windows_sys::Win32::System::DataExchange::{CloseClipboard, EmptyClipboard, OpenClipboard};
use windows_sys::Win32::UI::WindowsAndMessaging::GetForegroundWindow;

...
let hwnd = GetForegroundWindow();
let opened: BOOL = OpenClipboard(hwnd);
...
let emptied: BOOL = EmptyClipboard();
```

**After (exact):**

```rust
#[cfg(target_os = "windows")]
use std::time::Duration;

#[cfg(target_os = "windows")]
use windows_sys::Win32::Foundation::GetLastError;
#[cfg(target_os = "windows")]
use windows_sys::Win32::System::DataExchange::{CloseClipboard, EmptyClipboard, OpenClipboard};

/// Clears the entire Windows clipboard (all formats).
/// Uses OpenClipboard -> EmptyClipboard -> CloseClipboard.
/// Retries because clipboard may be temporarily locked by other processes.
#[cfg(target_os = "windows")]
pub fn clear_clipboard_all() -> Result<(), String> {
    const ATTEMPTS: usize = 10;
    const SLEEP_MS: u64 = 25;

    for attempt in 0..ATTEMPTS {
        unsafe {
            // Pass NULL owner handle (current task). This is allowed by WinAPI. :contentReference[oaicite:2]{index=2}
            let opened = OpenClipboard(0);

            if opened == 0 {
                if attempt + 1 < ATTEMPTS {
                    std::thread::sleep(Duration::from_millis(SLEEP_MS));
                    continue;
                }
                let err = GetLastError();
                return Err(format!("OPENCLIPBOARD_FAILED ({})", err));
            }

            let emptied = EmptyClipboard();
            CloseClipboard();

            if emptied == 0 {
                let err = GetLastError();
                return Err(format!("EMPTYCLIPBOARD_FAILED ({})", err));
            }

            return Ok(());
        }
    }

    Err("CLIPBOARD_BUSY".to_string())
}
```

**Why also removed `GetForegroundWindow`:**

* Not needed; WinAPI explicitly allows `OpenClipboard(NULL)` to associate with current task. ([Microsoft Learn][2])
* Less feature surface, меньше шансов на конфликт/неиспользуемые импорты.

### Change 2 (optional but recommended): ensure lockfile is consistent

**File:** `src-tauri/Cargo.lock`

Action:

* Regenerate lockfile by running on Windows:

  * `cargo update -p windows-sys` (or delete `Cargo.lock` and run `cargo build` once)
    This ensures the crate version matches `Cargo.toml` dependency intent. (No code snippet needed.)

---

## B) Ensure “auto-clear” actually wipes clipboard even if `readText()` fails

### Problem

In these files you do (pattern):

```ts
timeoutRef.current = window.setTimeout(async () => {
  try {
    const currentClipboard = await navigator.clipboard.readText();
    if (currentClipboard === lastCopiedValueRef.current) {
      await clipboardClearAll();
    }
  } catch (err) {
    console.error(err);
  }
  timeoutRef.current = null;
  lastCopiedValueRef.current = null;
}, timeoutMs);
```

If `navigator.clipboard.readText()` throws (permission / activation / focus), you catch and **do nothing**, meaning **wipe is skipped**. Reading from Clipboard API is known to be restricted and commonly gated. ([MDN Web Docs][1])

### Required behavior

* If we cannot read clipboard content in the timer callback, we still must **wipe clipboard** via backend WinAPI `EmptyClipboard` (your `clipboard_clear_all` command). `EmptyClipboard()` is explicitly designed to clear clipboard contents. ([Microsoft Learn][3])

### Implement: “wipe even on read failure”

Apply the same change in each location below.

#### Target files (exact)

1. `src/features/Vault/components/Details/useDetails.tsx`
2. `src/features/Vault/components/BankCards/useBankCardDetails.tsx`
3. `src/features/Vault/components/modals/PasswordHistoryDialog.tsx`
4. `src/features/Vault/components/DataCards/DataCards.tsx`

#### Change (exact code replacement inside the timer callback)

**Before:**

```ts
try {
  const currentClipboard = await navigator.clipboard.readText();
  if (currentClipboard === lastCopiedValueRef.current) {
    await clipboardClearAll();
  }
} catch (err) {
  console.error(err);
}
```

**After:**

```ts
try {
  const currentClipboard = await navigator.clipboard.readText();
  if (currentClipboard === lastCopiedValueRef.current) {
    await clipboardClearAll();
  }
} catch (err) {
  // If we cannot read (permission/activation/focus), still wipe as requested
  console.error(err);
  try {
    await clipboardClearAll();
  } catch (wipeErr) {
    console.error(wipeErr);
  }
}
```

This keeps your “do not wipe if user copied something else” logic when read works, but guarantees wipe when read is blocked (your requested “точно затирать”).

---

## C) Dead / unused code audit (from your current archive)

### Found unused frontend wrapper

**File:** `src/lib/tauri.ts`

Function is defined but never imported/used anywhere:

```ts
export async function autoLockCleanup(): Promise<boolean> {
  return invoke('auto_lock_cleanup');
}
```

Search result: only defined in `src/lib/tauri.ts`, no other usages in `src/`.
=> This is dead code.

#### Cleanup option (recommended)

1. **Remove** `autoLockCleanup()` from `src/lib/tauri.ts`.
2. **Remove** `auto_lock_cleanup` command from `src-tauri/src/main.rs` `generate_handler![ ... ]` list **if no frontend call exists**.
3. **Remove** command wrapper `auto_lock_cleanup` from `src-tauri/src/commands/security.rs` (keep service function `security_service::auto_lock_cleanup` because it’s called directly on window close in Rust: `main.rs` line ~67).

This keeps the real cleanup behavior (Rust side) but removes unused frontend wiring.

---

## D) Minor warning cleanup (non-blocking)

You have:

```
warning: variable does not need to be mutable
src-tauri/src/services/backup_service.rs:276:13
```

**File:** `src-tauri/src/services/backup_service.rs`
Change:

```rust
let mut backup = rusqlite::backup::Backup::new(&src_conn, &mut dest_conn)
```

to:

```rust
let backup = rusqlite::backup::Backup::new(&src_conn, &mut dest_conn)
```

---

## Acceptance criteria

1. Project builds on Windows without `BOOL` import error.
2. Clipboard wipe command clears clipboard contents using `EmptyClipboard()` (WinAPI). ([Microsoft Learn][3])
3. Auto-clear triggers wipe even if `navigator.clipboard.readText()` fails (timer context). ([MDN Web Docs][1])
4. Unused `autoLockCleanup()` frontend wrapper removed (and optionally unused command wrapper removed).

