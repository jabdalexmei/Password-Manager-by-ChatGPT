

## Technical Specification (EN, Windows-only) — Backup hardening & fixes

### Title

Backup/Restore hardening (Windows-only): profile validation, safer overwrite, restore preflight, and retryable file operations.

### Scope

Implement safety and reliability fixes for backup/export, restore/import, and auto-backup settings validation.

### Non-Goals

* Cross-platform support (explicitly Windows-only).
* Changing backup compression (keep ZIP with `Stored` / no compression).
* Redesigning UI/UX beyond minimal validation and error surfacing.

---

### 1) Restore “preflight” BEFORE locking the vault

**Problem**
`backup_restore()` locks the vault immediately, even if the selected archive is invalid.

**Required Change**

* Parse zip + read `manifest.json` + validate it **before** calling `security_service::lock_vault`.

**Files**

* `src-tauri/src/services/backup_service.rs`

**Implementation (exact edits)**

In `pub fn backup_restore(...)`:

1. Move this line **down** (after manifest validation succeeds):

```rust
security_service::lock_vault(state)?;
```

2. Add a “preflight” validation block immediately after manifest deserialization:

* verify `manifest.format_version == 1`
* verify `manifest.profile_id == profile_id`
* verify manifest contains `vault.db`
* verify no duplicate `path` entries

Add near:

```rust
let manifest: BackupManifest = serde_json::from_str(&manifest_contents)
    .map_err(|_| ErrorCodeString::new("BACKUP_MANIFEST_INVALID"))?;
```

Insert this code **right after**:

```rust
if manifest.format_version != 1 {
    return Err(ErrorCodeString::new("BACKUP_UNSUPPORTED_FORMAT"));
}

if manifest.profile_id != profile_id {
    return Err(ErrorCodeString::new("BACKUP_PROFILE_MISMATCH"));
}

use std::collections::HashSet;
let mut seen = HashSet::new();
let mut has_vault = false;

for f in &manifest.files {
    if !seen.insert(&f.path) {
        return Err(ErrorCodeString::new("BACKUP_MANIFEST_INVALID"));
    }
    if f.path == "vault.db" {
        has_vault = true;
    }
}

if !has_vault {
    return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
}
```

Then only after this block do:

```rust
security_service::lock_vault(state)?;
```

**Acceptance Criteria**

* Selecting an invalid backup archive does **not** log the user out.
* Restoring a backup from another profile fails fast with `BACKUP_PROFILE_MISMATCH`.
* Unsupported manifest versions fail with `BACKUP_UNSUPPORTED_FORMAT`.

---

### 2) Windows-safe overwrite when exporting backups

**Problem**
On Windows, `std::fs::rename(tmp, dest)` commonly fails if `dest` already exists. ([GitHub][1])

**Required Change**

* Replace the final move in `create_archive()` with an overwrite-capable Windows move (MoveFileExW with REPLACE_EXISTING + WRITE_THROUGH).
* Ensure tmp file is cleaned up on failure.

**Files**

* `src-tauri/Cargo.toml`
* `src-tauri/src/services/backup_service.rs`

#### 2.1 Cargo dependency

In `src-tauri/Cargo.toml`, add:

```toml
windows-sys = { version = "0.52", features = ["Win32_Storage_FileSystem", "Win32_Foundation"] }
```

#### 2.2 Implement Windows replace helper

In `src-tauri/src/services/backup_service.rs` (top-level, near other helpers), add:

```rust
#[cfg(windows)]
fn replace_file_windows(src: &Path, dst: &Path) -> std::io::Result<()> {
    use std::iter;
    use std::os::windows::ffi::OsStrExt;
    use windows_sys::Win32::Storage::FileSystem::{
        MoveFileExW, MOVEFILE_REPLACE_EXISTING, MOVEFILE_WRITE_THROUGH,
    };

    let src_w: Vec<u16> = src.as_os_str().encode_wide().chain(iter::once(0)).collect();
    let dst_w: Vec<u16> = dst.as_os_str().encode_wide().chain(iter::once(0)).collect();

    let ok = unsafe {
        MoveFileExW(
            src_w.as_ptr(),
            dst_w.as_ptr(),
            MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH,
        )
    };

    if ok == 0 {
        Err(std::io::Error::last_os_error())
    } else {
        Ok(())
    }
}
```

#### 2.3 Use it in create_archive()

In `fn create_archive(...)` replace:

```rust
fs::rename(&tmp_dest, destination).map_err(|_| ErrorCodeString::new("BACKUP_CREATE_FAILED"))?;
```

with:

```rust
#[cfg(windows)]
{
    replace_file_windows(&tmp_dest, destination)
        .map_err(|_| ErrorCodeString::new("BACKUP_CREATE_FAILED"))?;
}
#[cfg(not(windows))]
{
    fs::rename(&tmp_dest, destination)
        .map_err(|_| ErrorCodeString::new("BACKUP_CREATE_FAILED"))?;
}
```

Also, if `writer.finish()` succeeds but replace fails, tmp should not be left behind. Add right after the replace attempt:

```rust
if tmp_dest.exists() {
    let _ = fs::remove_file(&tmp_dest);
}
```

**Acceptance Criteria**

* Export works even if the user selects an existing destination file (overwrite confirmed in Save dialog).
* No leftover `.tmp` files when export fails.

---

### 3) Retry rename/copy on Windows to reduce AV/Indexer flakiness

**Problem**
On Windows, file operations can fail transiently (antivirus/indexer). ([reviews.llvm.org][2])

**Required Change**

* Wrap critical `fs::rename` steps during restore in a retry loop for `PermissionDenied` / `AccessDenied`.

**Files**

* `src-tauri/src/services/backup_service.rs`

**Implementation**

Add helper:

```rust
fn rename_with_retry(src: &Path, dst: &Path) -> std::io::Result<()> {
    use std::time::Duration;

    let mut last_err: Option<std::io::Error> = None;
    for _ in 0..25 {
        match fs::rename(src, dst) {
            Ok(()) => return Ok(()),
            Err(e) => {
                // Most common transient issue on Windows during AV scan
                if e.kind() == std::io::ErrorKind::PermissionDenied {
                    last_err = Some(e);
                    std::thread::sleep(Duration::from_millis(80));
                    continue;
                }
                return Err(e);
            }
        }
    }
    Err(last_err.unwrap_or_else(|| std::io::Error::new(std::io::ErrorKind::Other, "rename failed")))
}
```

Then in restore, replace key renames:

* `fs::rename(&vault_path, &vault_backup_path)` → `rename_with_retry(&vault_path, &vault_backup_path)`
* `fs::rename(&vault_tmp_path, &vault_path)` → `rename_with_retry(&vault_tmp_path, &vault_path)`
* `fs::rename(&attachments_path, &attachments_backup_path)` → retry wrapper
* `fs::rename(&extracted_attachments, &attachments_path)` → retry wrapper
* `fs::rename(&extracted_file, &target)` for config/settings → retry wrapper

Map any `std::io::Error` to `ErrorCodeString::new("BACKUP_RESTORE_FAILED")` exactly like сейчас.

**Acceptance Criteria**

* Restore becomes much less flaky on Windows machines with aggressive AV scanning.

---

### 4) Client-side validation for auto-backup settings inputs

**Problem**
`SettingsModal.tsx` sends `Number(intervalMinutes)` and `Number(retentionDays)` even when inputs are empty/invalid.

**Required Change**

* Prevent sending invalid values.
* Show a local validation message OR disable Save until inputs are valid.

**Files**

* `src/features/Vault/components/modals/SettingsModal.tsx`

**Implementation (exact)**
Before calling `onSave`, compute:

```ts
const interval = Number(intervalMinutes);
const retention = Number(retentionDays);

if (!Number.isFinite(interval) || interval < 5 || interval > 1440) return;
if (!Number.isFinite(retention) || retention < 1 || retention > 3650) return;
```

Then use:

```ts
auto_backup_interval_minutes: interval,
backup_retention_days: retention,
```

Also disable Save button:

```tsx
const canSave =
  Number.isFinite(Number(intervalMinutes)) &&
  Number(intervalMinutes) >= 5 &&
  Number(intervalMinutes) <= 1440 &&
  Number.isFinite(Number(retentionDays)) &&
  Number(retentionDays) >= 1 &&
  Number(retentionDays) <= 3650;
```

And:

```tsx
<button ... disabled={busy || !canSave}>...</button>
```

**Acceptance Criteria**

* No more backend validation errors from empty inputs.
* Save button is disabled when values are invalid.

---

### 5) Add/Expose new error codes

**New backend error codes**

* `BACKUP_PROFILE_MISMATCH`
* `BACKUP_UNSUPPORTED_FORMAT`

**Files**

* Wherever error messages are mapped/displayed on frontend:

  * `src/features/Vault/useVault.ts` (or a shared error mapper)
  * `src/i18n/English/Common.json` (or Vault.json if you prefer)

**Requirement**
Add user-friendly messages for these codes, otherwise user will see generic “operation failed”.

