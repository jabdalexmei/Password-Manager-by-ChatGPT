

# TS-001 (EN): Protected Vault Crypto (AEAD XChaCha20-Poly1305 + Argon2id fixed params + key_check + encrypted vault.db & attachments)

## 0. Scope

Implement the BACKEND canon crypto requirements for **protected profiles**:

* **Cipher:** AEAD XChaCha20-Poly1305
* **KDF:** Argon2id with **fixed** parameters (hardcoded constants in code)
* **key_check:** fast master password verification for protected profiles
* **Encrypted at rest:**

  * `vault.db` must be stored encrypted for protected profiles
  * `attachments/` must store encrypted files for protected profiles (even if attachment commands are not implemented yet)

This TS is based on the current project layout extracted from `1.zip`:

* Backend root: `src-tauri/src/...`
* Current crypto KDF file: `src-tauri/src/data/crypto/kdf.rs`
* Current DB init: `src-tauri/src/data/sqlite/init.rs`
* Current pool: `src-tauri/src/data/sqlite/pool.rs`
* Current login/lock: `src-tauri/src/services/security_service.rs`
* Current profile create: `src-tauri/src/services/profiles_service.rs`
* Current profile registry: `src-tauri/src/data/profiles/registry.rs`
* Current profile paths: `src-tauri/src/data/profiles/paths.rs`
* Current AppState: `src-tauri/src/app_state.rs`
* Modules declared inline in `src-tauri/src/main.rs`

## 1. Acceptance Criteria

### 1.1 Protected profile storage rules

A profile is **passwordless** iff `ProfileMeta.has_password == false` (i.e. `password_hash == None` in registry).
A profile is **protected** iff `ProfileMeta.has_password == true`.

For protected profiles:

1. `profiles/<id>/vault.db` exists and is **NOT** a valid SQLite file on disk (it is an encrypted blob).
2. `profiles/<id>/key_check.bin` exists and is an AEAD-encrypted blob.
3. `profiles/<id>/kdf_salt.bin` exists and contains the raw salt bytes.
4. On `login_vault` with correct password:

   * password is validated via `key_check` (fast check)
   * encrypted `vault.db` is decrypted into a named in-memory SQLite database (shared across pool connections) using rusqlite deserialize/serialize APIs. ([Docs.rs][1])
5. On `lock_vault`:

   * in-memory DB is serialized to bytes, encrypted and written back into `profiles/<id>/vault.db`
   * DB pool is cleared and the keeper connection is dropped
   * derived key is zeroized and removed from state

For passwordless profiles (unchanged behavior):

* `vault.db` is a normal SQLite file on disk.

### 1.2 Attachments encryption contract (backend-only)

Even if attachment commands are not implemented yet, the crypto layer must provide:

* `encrypt_attachment_bytes(...) -> Vec<u8>` and `decrypt_attachment_bytes(...) -> Vec<u8>`
* File format definition for encrypted attachments stored under `profiles/<id>/attachments/`
* A single place for “attachment encryption/decryption” so later `attachments_service` can use it without inventing a new format.

## 2. New Files to Add

### 2.1 `src-tauri/src/data/crypto/cipher.rs`

**Responsibility:** low-level AEAD encrypt/decrypt primitives + file format read/write for encrypted blobs.

**Dependencies to add (see section 6):**

* `chacha20poly1305` with XChaCha support
* `zeroize`
* `rand`

**Required public API (exact signatures):**

```rust
use crate::error::{ErrorCodeString, Result};

pub const PM_ENC_MAGIC: [u8; 6] = *b"PMENC1";
pub const PM_ENC_VERSION: u8 = 1;

pub const KEY_LEN: usize = 32;
pub const NONCE_LEN: usize = 24;

pub fn encrypt_bytes(
    key: &[u8; KEY_LEN],
    aad: &[u8],
    plaintext: &[u8],
) -> Result<Vec<u8>>;

pub fn decrypt_bytes(
    key: &[u8; KEY_LEN],
    aad: &[u8],
    blob: &[u8],
) -> Result<Vec<u8>>;

pub fn write_encrypted_file(path: &std::path::Path, blob: &[u8]) -> Result<()>;
pub fn read_encrypted_file(path: &std::path::Path) -> Result<Vec<u8>>;
```

**Encrypted blob format (for both vault.db and key_check.bin and encrypted attachments):**

Binary layout:

* `magic`   (6 bytes)  = `PMENC1`
* `version` (1 byte)   = `1`
* `nonce`   (24 bytes) = random XChaCha20 nonce
* `ciphertext` (N bytes) = AEAD ciphertext including tag (as produced by the crate)

**AAD policy:**

* For `vault.db`: `aad = b"vault_db:" + profile_id.as_bytes()`
* For `key_check.bin`: `aad = b"key_check:" + profile_id.as_bytes()`
* For attachments: `aad = b"attachment:" + profile_id.as_bytes() + b":" + attachment_id.as_bytes()`

**Error codes (use existing `ErrorCodeString` pattern):**

* `CRYPTO_ENCRYPT_FAILED`
* `CRYPTO_DECRYPT_FAILED`
* `CRYPTO_BAD_FORMAT`
* `FS_READ_FAILED`
* `FS_WRITE_FAILED`

### 2.2 `src-tauri/src/data/crypto/key_check.rs`

**Responsibility:** create and verify `key_check.bin`.

**Required public API:**

```rust
use crate::error::Result;

pub const KEY_CHECK_LEN: usize = 32;

pub fn create_key_check_file(
    profile_id: &str,
    key: &[u8; 32],
    path: &std::path::Path,
) -> Result<()>;

pub fn verify_key_check_file(
    profile_id: &str,
    key: &[u8; 32],
    path: &std::path::Path,
) -> Result<bool>;
```

Rules:

* `create_key_check_file` generates random 32 bytes and encrypts them (using `cipher::encrypt_bytes`) into the file format from `cipher.rs`.
* `verify_key_check_file` decrypts and returns `true` on success, `false` only for authentication failures; all IO/format errors should return `Err(ErrorCodeString)`.

### 2.3 Update existing `src-tauri/src/data/crypto/kdf.rs`

**Responsibility change:** it must provide:

* Argon2id **fixed** parameters (constants)
* Hash/verify password using the fixed parameters (for registry compatibility)
* Derive a fixed-length master key (32 bytes) using the fixed parameters + `kdf_salt.bin`

**Required constants (must be hardcoded):**

```rust
pub const KDF_SALT_LEN: usize = 16;
pub const KDF_KEY_LEN: usize = 32;

// Fixed Argon2id params (v1). DO NOT CHANGE without a migration.
pub const ARGON2_M_COST_KIB: u32 = 65536;  // 64 MiB
pub const ARGON2_T_COST: u32 = 3;
pub const ARGON2_P_COST: u32 = 1;
```

**Required public API additions:**

```rust
use crate::error::Result;

pub fn derive_master_key(password: &str, salt: &[u8; KDF_SALT_LEN]) -> Result<[u8; KDF_KEY_LEN]>;

pub fn generate_kdf_salt() -> [u8; KDF_SALT_LEN];
```

Notes:

* Use `argon2::Algorithm::Argon2id` and explicit Params; **do not** use `Argon2::default()`.
* Keep `hash_password` / `verify_password` but switch them to the same fixed params.

### 2.4 Update profile paths: `src-tauri/src/data/profiles/paths.rs`

Add new helpers:

```rust
pub fn kdf_salt_path(sp: &StoragePaths, profile_id: &str) -> PathBuf {
    profile_dir(sp, profile_id).join("kdf_salt.bin")
}

pub fn key_check_path(sp: &StoragePaths, profile_id: &str) -> PathBuf {
    profile_dir(sp, profile_id).join("key_check.bin")
}
```

## 3. Backend State Changes

### 3.1 Update `src-tauri/src/app_state.rs`

**Add vault session fields** (in addition to existing `active_profile` and `logged_in_profile`).

Required new fields:

```rust
use std::sync::Mutex;
use zeroize::Zeroizing;

pub struct AppState {
    pub active_profile: Mutex<Option<String>>,
    pub logged_in_profile: Mutex<Option<String>>,
    pub storage_paths: StoragePaths,

    // New:
    pub vault_keeper_conn: Mutex<Option<rusqlite::Connection>>,
    pub vault_db_uri: Mutex<Option<String>>,
    pub vault_key: Mutex<Option<Zeroizing<[u8; 32]>>>,
}
```

Initialization in `AppState::new(...)` must set all new fields to `Mutex::new(None)`.

Rationale:

* `vault_keeper_conn`: a “keeper” connection that holds the named in-memory DB alive and is used for serialize-on-lock. rusqlite exposes `serialize` and `deserialize_*`. ([Docs.rs][1])
* `vault_db_uri`: the URI that r2d2 connections use to attach to the same shared in-memory DB
* `vault_key`: derived master key, must be zeroized on lock/logout

## 4. Database Load/Save for Protected Profiles

### 4.1 In-memory DB approach

Use a **named in-memory database** via SQLite URI:

`file:pm_vault_<profile_id>?mode=memory&cache=shared`

Pool connections must open this URI with OpenFlags including URI + shared cache (see section 5). r2d2_sqlite supports `new_with_flags(...)`. ([ivanceras.github.io][2])

### 4.2 Update `src-tauri/src/data/sqlite/init.rs`

Split initialization into two flows:

#### Passwordless (existing behavior):

Keep existing `init_database(sp, profile_id)` but rename it to:

```rust
pub fn init_database_passwordless(sp: &StoragePaths, profile_id: &str) -> Result<()>;
```

It continues to:

* create `attachments/` and `backups/`
* open file `vault.db`
* run `migrations::migrate_to_latest(&conn)`

#### Protected (new behavior):

Add:

```rust
pub fn init_database_protected_encrypted(
    sp: &StoragePaths,
    profile_id: &str,
    key: &[u8; 32],
) -> Result<()>;
```

Implementation requirements:

1. Ensure profile dirs exist (`ensure_profile_dirs`)
2. Create an in-memory rusqlite connection (`Connection::open_in_memory()`)
3. Apply migrations on the in-memory connection (`migrations::migrate_to_latest(&conn)`)
4. Serialize DB bytes (`conn.serialize("main")`)
5. Encrypt bytes with `cipher::encrypt_bytes` using `aad = b"vault_db:" + profile_id`
6. Write encrypted blob to `profiles/<id>/vault.db` using `cipher::write_encrypted_file`

### 4.3 Create/open protected vault session

Add a new backend helper in `src-tauri/src/services/security_service.rs` (same file; do not create a new module in this TS) to open the session:

```rust
fn open_protected_vault_session(
    profile_id: &str,
    password: &str,
    state: &Arc<AppState>,
) -> Result<()>;
```

Steps (must be implemented exactly in this order):

1. Read `kdf_salt.bin` from `kdf_salt_path`.
2. Derive key: `kdf::derive_master_key(password, &salt)`.
3. Verify `key_check.bin` via `key_check::verify_key_check_file(...)`.

   * If returns `false` => `Err("INVALID_PASSWORD")`.
4. Read encrypted `vault.db` bytes and decrypt to plaintext serialized DB bytes via `cipher::decrypt_bytes(...)`.
5. Construct URI string: `file:pm_vault_<profile_id>?mode=memory&cache=shared`.
6. Open keeper connection:

   * `rusqlite::Connection::open_with_flags(uri, flags_with_URI_and_shared_cache)`
7. Deserialize DB bytes into keeper connection using `deserialize_bytes` / `deserialize` method (rusqlite provides these APIs). ([Docs.rs][1])
8. Store into AppState:

   * `vault_keeper_conn = Some(conn)`
   * `vault_db_uri = Some(uri)`
   * `vault_key = Some(Zeroizing::new(key))`

**Error codes:**

* Missing `kdf_salt.bin` => `KDF_SALT_MISSING`
* Missing `key_check.bin` => `KEY_CHECK_MISSING`
* Missing/invalid `vault.db` blob => `VAULT_CORRUPTED`
* Decrypt/auth failure => `INVALID_PASSWORD` (only for key_check failure) or `VAULT_DECRYPT_FAILED` (for vault.db failure)

### 4.4 Close protected vault session on lock

In `lock_vault(...)`:

1. Determine logged-in profile id (existing)
2. If profile is protected:

   * Take keeper connection out of state:

     * `let conn = state.vault_keeper_conn.lock()?.take();`
   * Serialize DB bytes: `conn.serialize("main")`
   * Encrypt bytes with `aad = b"vault_db:" + profile_id`
   * Write to `profiles/<id>/vault.db`
   * Drop the keeper connection
3. Clear pool: `clear_pool(&id)` (existing)
4. Clear:

   * `vault_db_uri = None`
   * `vault_key = None` (must drop Zeroizing)
5. Clear logged-in id (existing)

## 5. Connection Pool Changes

### 5.1 Update `src-tauri/src/data/sqlite/pool.rs`

Currently it always uses:

```rust
SqliteConnectionManager::file(vault_db_path(sp, profile_id));
```

This must change to support two backends:

* Passwordless: file path (`vault.db` is real SQLite)
* Protected: named in-memory URI from AppState (`vault.db` is encrypted blob, must not be opened as SQLite)

**Introduce enum:**

```rust
pub enum DbTarget {
    File(std::path::PathBuf),
    Uri(String),
}
```

**Update public API:**

Replace:

```rust
pub fn get_conn(sp: &StoragePaths, profile_id: &str) -> Result<PooledConnection<SqliteConnectionManager>>;
```

with:

```rust
pub fn get_conn(
    profile_id: &str,
    target: DbTarget,
) -> Result<PooledConnection<SqliteConnectionManager>>;
```

And update the internal pool map key to include target identity:

* Key should be `format!("{profile_id}::file")` or `format!("{profile_id}::uri::{uri}")`
* This prevents accidental reuse of an old pool when switching profile types.

**Manager creation rules:**

* For `DbTarget::File(path)`:

  * Keep existing pragmas including WAL.
* For `DbTarget::Uri(uri)`:

  * Use `SqliteConnectionManager::new_with_flags(&uri, flags)` (r2d2_sqlite supports this). ([ivanceras.github.io][2])
  * Flags must include:

    * `rusqlite::OpenFlags::SQLITE_OPEN_READ_WRITE`
    * `rusqlite::OpenFlags::SQLITE_OPEN_CREATE`
    * `rusqlite::OpenFlags::SQLITE_OPEN_URI`
    * `rusqlite::OpenFlags::SQLITE_OPEN_SHARED_CACHE` ([Docs.rs][3])
  * Pragmas must NOT set `journal_mode=WAL` for in-memory DB. Use:

    * `PRAGMA journal_mode = MEMORY;`
    * `PRAGMA synchronous = NORMAL;`
    * `PRAGMA foreign_keys = ON;`

## 6. Cargo.toml Changes

Edit: `src-tauri/Cargo.toml`

### 6.1 Add dependencies

Add:

```toml
chacha20poly1305 = { version = "0.10", features = ["xchacha20"] }
zeroize = "1.8"
```

Keep existing `rand = "0.8"`.

### 6.2 Update rusqlite features

To ensure serialize/deserialize APIs are available, update:

```toml
rusqlite = { version = "0.32", features = ["bundled"] }
```

to:

```toml
rusqlite = { version = "0.32", features = ["bundled", "serialize"] }
```

(If compilation reveals deserialize requires an extra feature, add it in the same line and document it in commit notes; rusqlite documents serialize/deserialize methods on Connection. ([Docs.rs][1]))

## 7. Profile Creation Flow Updates

### 7.1 Update `src-tauri/src/services/profiles_service.rs`

Currently:

* creates registry record
* ensures dirs
* calls `init_database(sp, profile.id)` unconditionally

Change logic:

1. Determine `is_passwordless`:

   * `password.is_none() || password.as_deref().unwrap_or("").is_empty()`
2. If passwordless:

   * call `init_database_passwordless(...)` (new)
3. If protected:

   * generate and store:

     * `kdf_salt.bin`
     * `key_check.bin`
     * encrypted `vault.db`

**Implementation detail:**

* After `registry::create_profile` returns `profile.id`, do:

```rust
use crate::data::crypto::kdf;
use crate::data::crypto::key_check;
use crate::data::profiles::paths::{kdf_salt_path, key_check_path};
use crate::data::sqlite::init::init_database_protected_encrypted;
```

Write `kdf_salt.bin` as raw bytes:

* `std::fs::write(kdf_salt_path(sp, &id), salt_bytes)`

Then:

* derive key from provided password and salt
* call `key_check::create_key_check_file(...)`
* call `init_database_protected_encrypted(sp, &id, &key)`

**Security:** key material must be held in `Zeroizing<[u8;32]>` during the function scope to avoid accidental reuse in logs/heap.

### 7.2 Update `src-tauri/src/data/profiles/registry.rs`

Keep `password_hash` in registry for now (compatibility / UI “has_password”), but:

* Update hashing to fixed Argon2id params by using the updated `kdf.rs`.
* Update `verify_profile_password(...)` for protected profiles to use `key_check` instead of (or in addition to) verifying the hash.

**New rule in `verify_profile_password`:**

* if `password_hash.is_none()` => return `Ok(true)`
* else:

  * read `kdf_salt.bin`
  * derive key via `derive_master_key`
  * call `verify_key_check_file`
  * return `Ok(true/false)` accordingly

## 8. Login / Lock Updates

### 8.1 Update `src-tauri/src/services/security_service.rs`

#### login_vault(id, password, state)

Current implementation:

* verify registry password hash
* init_database (file)
* set active/logged_in

New implementation:

1. Load profile record (reuse existing registry helpers):

   * If profile not found => `PROFILE_NOT_FOUND`
2. If passwordless:

   * initialize passwordless DB (`init_database_passwordless`), set `active_profile` and `logged_in_profile`
3. If protected:

   * call `open_protected_vault_session(id, &pwd, state)`
   * after session opened, create DB pool target from URI and allow services to query
   * set `active_profile` and `logged_in_profile`

#### lock_vault(state)

Must serialize+encrypt protected DB before clearing state as described in 4.4.

## 9. Attachments Encryption (backend contract)

Add in `src-tauri/src/data/crypto/cipher.rs` or a small helper module inside `cipher.rs`:

Required functions:

```rust
pub fn encrypt_attachment_blob(
    profile_id: &str,
    attachment_id: &str,
    key: &[u8; 32],
    plaintext: &[u8],
) -> Result<Vec<u8>>;

pub fn decrypt_attachment_blob(
    profile_id: &str,
    attachment_id: &str,
    key: &[u8; 32],
    blob: &[u8],
) -> Result<Vec<u8>>;
```

Storage convention (for when attachments commands arrive later):

* encrypted file path: `profiles/<id>/attachments/<attachment_id>.bin`
* no plaintext attachments are ever stored for protected profiles.

## 10. Files to Modify Summary (exact paths)

**Add:**

* `src-tauri/src/data/crypto/cipher.rs`
* `src-tauri/src/data/crypto/key_check.rs`

**Modify:**

* `src-tauri/src/main.rs`
  Add module declarations:

  * `pub mod crypto { pub mod kdf; pub mod cipher; pub mod key_check; }`
* `src-tauri/src/app_state.rs`
  Add keeper conn + uri + key fields
* `src-tauri/src/data/crypto/kdf.rs`
  Fixed Argon2id params + derive_master_key + generate_kdf_salt
* `src-tauri/src/data/profiles/paths.rs`
  Add `kdf_salt_path`, `key_check_path`
* `src-tauri/src/data/profiles/registry.rs`
  On protected: verify password via key_check + kdf_salt
* `src-tauri/src/data/sqlite/init.rs`
  Split into passwordless init + protected encrypted init (in-memory + serialize + encrypt)
* `src-tauri/src/data/sqlite/pool.rs`
  Add DbTarget (File/Uri), open URI with flags, adjust pragmas
* `src-tauri/src/services/profiles_service.rs`
  On protected profile creation: create kdf_salt, key_check, encrypted vault.db
* `src-tauri/src/services/security_service.rs`
  On login: open protected session (decrypt+deserialize) OR passwordless init
  On lock: serialize+encrypt vault and clear session

**Modify dependencies:**

* `src-tauri/Cargo.toml` (add `chacha20poly1305`, `zeroize`, enable `rusqlite` serialize feature)

SqliteConnectionManager - Rust"
[3]: https://docs.rs/rusqlite/latest/rusqlite/struct.OpenFlags.html?utm_source=chatgpt.com "OpenFlags in rusqlite - Rust"
