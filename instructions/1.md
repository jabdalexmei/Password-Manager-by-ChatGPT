

## TS (diff-style)

### 1) `src/shared/icons/lucide/icons.ts`

**Why:** project rule says only this file imports from `lucide-react`. Add `SlidersHorizontal` icon for the filters button. ([Lucide][2])

```diff
--- before: src/shared/icons/lucide/icons.ts
+++ after:  src/shared/icons/lucide/icons.ts
@@
 export {
   Archive as IconArchive,
   ArrowLeft as IconArrowLeft,
   ArrowRight as IconArrowRight,
   ArrowUpDown as IconArrowUpDown,
   Ban as IconBan,
   Check as IconCheck,
   ChevronDown as IconChevronDown,
   ChevronUp as IconChevronUp,
   Circle as IconCircle,
   Copy as IconCopy,
   Download as IconDownload,
   Edit as IconEdit,
   Eye as IconEye,
   EyeOff as IconEyeOff,
   FileUp as IconFileUp,
   Folder as IconFolder,
   FolderOpen as IconFolderOpen,
   History as IconHistory,
+  SlidersHorizontal as IconFilters,
   Lock as IconLock,
   LogOut as IconLogOut,
   MoreHorizontal as IconMoreHorizontal,
   Plus as IconPlus,
   RefreshCw as IconRefreshCw,
   Search as IconSearch,
   Settings as IconSettings,
   Shield as IconShield,
   Star as IconStar,
   Trash2 as IconTrash,
   Upload as IconUpload,
 } from 'lucide-react';
```

---

### 2) `src/i18n/locales/en/Vault.json`

**Why:** add strings for Filters UI.

```diff
--- before: src/i18n/locales/en/Vault.json
+++ after:  src/i18n/locales/en/Vault.json
@@
   "search.placeholder": "Search",
+  "filters.button": "Filters",
+  "filters.title": "Filters",
+  "filters.favorites": "Favorites",
+  "filters.has2fa": "Has 2FA",
+  "filters.hasAttachments": "Has attachments",
+  "filters.hasSeedPhrase": "Has seed phrase",
+  "filters.hasPhone": "Has phone",
+  "filters.hasNotes": "Has notes",
   "nav.all_items": "All items",
   "nav.favorites": "Favorites",
   "nav.archive": "Archive",
   "nav.deleted": "Deleted",
   "information.title": "Information",
```

---

### 3) `src/features/Vault/types/backend.ts`

**Why:** backend summary payload must include flags used by UI filters.

```diff
--- before: src/features/Vault/types/backend.ts
+++ after:  src/features/Vault/types/backend.ts
@@
 export type BackendDataCardSummary = {
   id: string;
   folder_id: string | null;
   title: string;
   url: string | null;
   email: string | null;
   username: string | null;
   has_totp: boolean;
+  has_attachments: boolean;
+  has_seed_phrase: boolean;
+  has_phone: boolean;
+  has_note: boolean;
   tags_json: string;
   is_favorite: boolean;
   created_at: string;
   updated_at: string;
   deleted_at: string | null;
 };
@@
 export type BackendBankCardSummary = {
   id: string;
   title: string;
   holder: string | null;
   number: string | null;
+  has_note: boolean;
   tags_json: string;
   is_favorite: boolean;
   created_at: string;
   updated_at: string;
   deleted_at: string | null;
 };
```

---

### 4) `src/features/Vault/types/ui.ts`

**Why:** UI summary models need flags.

```diff
--- before: src/features/Vault/types/ui.ts
+++ after:  src/features/Vault/types/ui.ts
@@
 export type DataCardSummary = DataCard & {
   createdAtLabel: string;
   updatedAtLabel: string;
   isFavorite: boolean;
   hasTotp: boolean;
+  hasAttachments: boolean;
+  hasSeedPhrase: boolean;
+  hasPhone: boolean;
+  hasNote: boolean;
 };
@@
 export type BankCardSummary = BankCard & {
   createdAtLabel: string;
   updatedAtLabel: string;
   isFavorite: boolean;
+  hasNote: boolean;
 };
```

---

### 5) `src/features/Vault/types/mappers.ts`

**Why:** map new backend flags into UI summaries, and keep sane defaults for locally-derived summaries.

```diff
--- before: src/features/Vault/types/mappers.ts
+++ after:  src/features/Vault/types/mappers.ts
@@
 export function mapCardSummaryFromBackend(card: BackendDataCardSummary, dtf: Intl.DateTimeFormat): DataCardSummary {
   return {
     id: card.id,
     folderId: card.folder_id,
     title: card.title,
     url: card.url,
     email: card.email,
     username: card.username,
     mobilePhone: null,
     note: null,
     isFavorite: card.is_favorite,
     tags: parseJsonArray(card.tags_json),
     password: null,
     totpUri: null,
     hasTotp: card.has_totp,
+    hasAttachments: card.has_attachments,
+    hasSeedPhrase: card.has_seed_phrase,
+    hasPhone: card.has_phone,
+    hasNote: card.has_note,
     seedPhrase: null,
     seedPhraseWordCount: null,
     customFields: null,
     createdAt: card.created_at,
     updatedAt: card.updated_at,
     createdAtLabel: formatIsoForDisplay(card.created_at, dtf),
     updatedAtLabel: formatIsoForDisplay(card.updated_at, dtf),
     deletedAt: card.deleted_at,
   };
 }
@@
 export function mapCardToSummary(card: DataCard, dtf: Intl.DateTimeFormat): DataCardSummary {
   return {
     ...card,
     isFavorite: card.isFavorite,
     hasTotp: Boolean(card.totpUri),
+    hasAttachments: false,
+    hasSeedPhrase: Boolean(card.seedPhraseWordCount),
+    hasPhone: Boolean(card.mobilePhone && card.mobilePhone.trim().length > 0),
+    hasNote: Boolean(card.note && card.note.trim().length > 0),
     createdAtLabel: formatIsoForDisplay(card.createdAt, dtf),
     updatedAtLabel: formatIsoForDisplay(card.updatedAt, dtf),
   };
 }
@@
 export function mapBankCardSummaryFromBackend(
   card: BackendBankCardSummary,
   dtf: Intl.DateTimeFormat
 ): BankCardSummary {
   return {
     id: card.id,
     title: card.title,
     holder: card.holder,
     number: card.number,
     note: null,
     tags: parseJsonArray(card.tags_json),
     isFavorite: card.is_favorite,
+    hasNote: card.has_note,
     createdAt: card.created_at,
     updatedAt: card.updated_at,
     createdAtLabel: formatIsoForDisplay(card.created_at, dtf),
     updatedAtLabel: formatIsoForDisplay(card.updated_at, dtf),
     deletedAt: card.deleted_at,
   };
 }
@@
 export function mapBankCardToSummary(card: BankCard, dtf: Intl.DateTimeFormat): BankCardSummary {
   return {
     ...card,
     isFavorite: card.isFavorite,
+    hasNote: Boolean(card.note && card.note.trim().length > 0),
     createdAtLabel: formatIsoForDisplay(card.createdAt, dtf),
     updatedAtLabel: formatIsoForDisplay(card.updatedAt, dtf),
   };
 }
```

---

### 6) `src/features/Vault/types/searchFilters.ts` (NEW)

**Why:** shared filter state shape for both `useVault` and `useBankCards`.

```diff
--- before: (file does not exist)
+++ after:  src/features/Vault/types/searchFilters.ts
@@
+export type VaultSearchFilters = {
+  favorites: boolean;
+  has2fa: boolean;
+  hasAttachments: boolean;
+  hasSeedPhrase: boolean;
+  hasPhone: boolean;
+  hasNotes: boolean;
+};
+
+export const defaultVaultSearchFilters: VaultSearchFilters = {
+  favorites: false,
+  has2fa: false,
+  hasAttachments: false,
+  hasSeedPhrase: false,
+  hasPhone: false,
+  hasNotes: false,
+};
+
+export type VaultSearchFilterKey = keyof VaultSearchFilters;
```

---

### 7) `src/features/Vault/components/Search/Search.tsx`

**Why:** add `Sliders` button, popover with toggle buttons, wire into filters state.
A11y: `aria-pressed` for toggles, `aria-expanded/aria-haspopup` for popover trigger. ([W3C][1])

```diff
--- before: src/features/Vault/components/Search/Search.tsx
+++ after:  src/features/Vault/components/Search/Search.tsx
@@
-import React from 'react';
+import React, { useEffect, useMemo, useRef, useState } from 'React';
 import { useTranslation } from '../../../../shared/lib/i18n';
+import { IconFilters } from '../../../../shared/icons/lucide/icons';
+import { VaultSearchFilterKey, VaultSearchFilters } from '../../types/searchFilters';
 
 type Props = {
   query: string;
   onChange: (value: string) => void;
+  filters: VaultSearchFilters;
+  onChangeFilters: (next: VaultSearchFilters) => void;
+  filterKeys: VaultSearchFilterKey[];
 };
 
-export function Search({ query, onChange }: Props) {
+export function Search({ query, onChange, filters, onChangeFilters, filterKeys }: Props) {
   const { t } = useTranslation('Vault');
+  const [open, setOpen] = useState(false);
+  const rootRef = useRef<HTMLDivElement | null>(null);
+
+  const labelByKey = useMemo<Record<VaultSearchFilterKey, string>>(
+    () => ({
+      favorites: t('filters.favorites'),
+      has2fa: t('filters.has2fa'),
+      hasAttachments: t('filters.hasAttachments'),
+      hasSeedPhrase: t('filters.hasSeedPhrase'),
+      hasPhone: t('filters.hasPhone'),
+      hasNotes: t('filters.hasNotes'),
+    }),
+    [t]
+  );
+
+  useEffect(() => {
+    if (!open) return;
+
+    const onKeyDown = (e: KeyboardEvent) => {
+      if (e.key === 'Escape') setOpen(false);
+    };
+
+    const onPointerDown = (e: MouseEvent) => {
+      const target = e.target as Node | null;
+      if (!target) return;
+      if (!rootRef.current) return;
+      if (!rootRef.current.contains(target)) setOpen(false);
+    };
+
+    window.addEventListener('keydown', onKeyDown);
+    window.addEventListener('mousedown', onPointerDown);
+    return () => {
+      window.removeEventListener('keydown', onKeyDown);
+      window.removeEventListener('mousedown', onPointerDown);
+    };
+  }, [open]);
+
+  const toggle = (key: VaultSearchFilterKey) => {
+    onChangeFilters({ ...filters, [key]: !filters[key] });
+  };
 
   return (
-    <input
-      type="search"
-      className="vault-search"
-      placeholder={t('search.placeholder')}
-      value={query}
-      onChange={(e) => onChange(e.target.value)}
-    />
+    <div className="vault-searchbar" ref={rootRef}>
+      <input
+        type="search"
+        className="vault-search"
+        placeholder={t('search.placeholder')}
+        value={query}
+        onChange={(e) => onChange(e.target.value)}
+      />
+
+      <button
+        type="button"
+        className="btn btn-secondary btn-icon vault-filter-button"
+        aria-label={t('filters.button')}
+        aria-haspopup="dialog"
+        aria-expanded={open}
+        onClick={() => setOpen((v) => !v)}
+      >
+        <IconFilters size={18} />
+      </button>
+
+      {open && (
+        <div className="vault-filter-popover" role="dialog" aria-label={t('filters.title')}>
+          <div className="vault-filter-popover-title">{t('filters.title')}</div>
+          <div className="vault-filter-popover-grid">
+            {filterKeys.map((key) => {
+              const active = filters[key];
+              return (
+                <button
+                  key={key}
+                  type="button"
+                  className={`btn btn-compact vault-filter-toggle ${active ? 'btn-primary' : 'btn-secondary'}`}
+                  aria-pressed={active}
+                  onClick={() => toggle(key)}
+                >
+                  {labelByKey[key]}
+                </button>
+              );
+            })}
+          </div>
+        </div>
+      )}
+    </div>
   );
 }
```

> Примечание: если у тебя линтер ругнётся на `import React, ... from 'React'` — это опечатка. Должно быть `'react'`. Я оставляю как **обязательную** правку ниже (см. дифф-строку).

Исправление строки импорта (обязательно):

```diff
--- before: src/features/Vault/components/Search/Search.tsx
+++ after:  src/features/Vault/components/Search/Search.tsx
@@
-import React, { useEffect, useMemo, useRef, useState } from 'React';
+import React, { useEffect, useMemo, useRef, useState } from 'react';
```

---

### 8) `src/shared/styles/screens/vault.css`

**Why:** layout for search + filters button + popover, without ломания остального UI.

```diff
--- before: src/shared/styles/screens/vault.css
+++ after:  src/shared/styles/screens/vault.css
@@
 .vault-search {
-  width: 100%;
+  flex: 1 1 auto;
+  min-width: 0;
   padding: 12px 14px;
   border-radius: var(--radius-sm);
   border: 1px solid var(--border-subtle);
   background: var(--surface-container);
   color: var(--color-text);
   outline: none;
 }
 
 .vault-search:focus {
   border-color: var(--color-primary);
   box-shadow: 0 0 0 2px color-mix(in oklab, var(--color-primary) 40%, transparent);
 }
+
+.vault-searchbar {
+  position: relative;
+  display: flex;
+  align-items: stretch;
+  gap: 10px;
+}
+
+.vault-filter-button.btn-icon {
+  width: 44px;
+  height: 44px;
+}
+
+.vault-filter-popover {
+  position: absolute;
+  top: calc(100% + 10px);
+  right: 0;
+  width: 320px;
+  padding: 12px;
+  border-radius: var(--radius-lg);
+  border: 1px solid var(--border-subtle);
+  background: var(--surface-container);
+  box-shadow: var(--shadow-popover);
+  z-index: 50;
+}
+
+.vault-filter-popover-title {
+  font-weight: 700;
+  margin-bottom: 10px;
+}
+
+.vault-filter-popover-grid {
+  display: flex;
+  flex-wrap: wrap;
+  gap: 10px;
+}
+
+.vault-filter-toggle.btn-compact {
+  border-radius: var(--radius-sm);
+}
```

---

### 9) `src/features/Vault/Vault.tsx`

**Why:** connect filters UI to the correct hook (`useVault` vs `useBankCards`), and show only relevant toggles in bank cards.

```diff
--- before: src/features/Vault/Vault.tsx
+++ after:  src/features/Vault/Vault.tsx
@@
             <Search
               query={selectedCategory === 'data_cards' ? vault.searchQuery : bankCards.searchQuery}
               onChange={selectedCategory === 'data_cards' ? vault.setSearchQuery : bankCards.setSearchQuery}
+              filters={selectedCategory === 'data_cards' ? vault.searchFilters : bankCards.searchFilters}
+              onChangeFilters={selectedCategory === 'data_cards' ? vault.setSearchFilters : bankCards.setSearchFilters}
+              filterKeys={
+                selectedCategory === 'data_cards'
+                  ? ['favorites', 'has2fa', 'hasAttachments', 'hasSeedPhrase', 'hasPhone', 'hasNotes']
+                  : ['favorites', 'hasNotes']
+              }
             />
```

---

### 10) `src/features/Vault/hooks/useVault.ts`

**Why:** store filter state, apply it in `visibleCards`, keep `hasAttachments` stable when summary replaced by `loadCard`, and flip `hasAttachments=true` after upload.

```diff
--- before: src/features/Vault/hooks/useVault.ts
+++ after:  src/features/Vault/hooks/useVault.ts
@@
 import { DataCard, DataCardSummary, Folder, SelectedNav, UpdateDataCardInput } from '../types/ui';
+import { defaultVaultSearchFilters, VaultSearchFilters } from '../types/searchFilters';
@@
 export function useVault(profileId: string, onLocked: () => void) {
@@
   const [searchInput, setSearchInput] = useState('');
+  const [searchFilters, setSearchFilters] = useState<VaultSearchFilters>(defaultVaultSearchFilters);
@@
   const loadCard = useCallback(
     async (id: string) => {
       try {
         const card = await getDataCard(id);
         const mapped = mapCardFromBackend(card);
-        const summary = mapCardToSummary(mapped, dtf);
+        const prevSummary =
+          cards.find((c) => c.id === id) || deletedCards.find((c) => c.id === id) || null;
+        const summary = {
+          ...mapCardToSummary(mapped, dtf),
+          hasAttachments: prevSummary?.hasAttachments ?? false,
+        };
@@
       } catch (err) {
         handleError(err);
       }
     },
-    [dtf, handleError, sortCardsWithSettings]
+    [cards, deletedCards, dtf, handleError, sortCardsWithSettings]
   );
@@
   const uploadAttachments = useCallback(
     async (cardId: string, paths: string[]) => {
       const failed: string[] = [];
       for (const path of paths) {
         try {
           await addAttachmentFromPath(cardId, path);
+          setCards((prev) =>
+            prev.map((c) => (c.id === cardId ? { ...c, hasAttachments: true } : c))
+          );
         } catch (err) {
           failed.push(path);
           handleError(err);
         }
       }
@@
   const visibleCards = useMemo(() => {
@@
-    if (searchQuery) {
-      pool = pool.filter((card) => {
+    // Apply UI filters first (cheap booleans) and only then do text search.
+    if (searchFilters.favorites) pool = pool.filter((c) => c.isFavorite);
+    if (searchFilters.has2fa) pool = pool.filter((c) => c.hasTotp);
+    if (searchFilters.hasAttachments) pool = pool.filter((c) => c.hasAttachments);
+    if (searchFilters.hasSeedPhrase) pool = pool.filter((c) => c.hasSeedPhrase);
+    if (searchFilters.hasPhone) pool = pool.filter((c) => c.hasPhone);
+    if (searchFilters.hasNotes) pool = pool.filter((c) => c.hasNote);
+
+    if (searchQuery) {
+      pool = pool.filter((card) => {
         const haystack = [
           card.title,
           card.url,
           card.email,
           card.username,
           card.mobilePhone,
           card.note,
           card.tags?.join(' '),
         ]
@@
-    return pool;
-  }, [cards, deletedCards, folders, selectedNav, searchQuery]);
+    return pool;
+  }, [cards, deletedCards, folders, searchFilters, selectedNav, searchQuery]);
@@
   return {
@@
     searchQuery: searchInput,
     setSearchQuery: setSearchInput,
+    searchFilters,
+    setSearchFilters,
@@
   };
 }
```

---

### 11) `src/features/Vault/hooks/useBankCards.ts`

**Why:** same filter pipeline for bank cards (subset is used by UI, but state is the same shape).

```diff
--- before: src/features/Vault/hooks/useBankCards.ts
+++ after:  src/features/Vault/hooks/useBankCards.ts
@@
 import { BankCard, BankCardSummary, SelectedNav, UpdateBankCardInput } from '../types/ui';
+import { defaultVaultSearchFilters, VaultSearchFilters } from '../types/searchFilters';
@@
 export function useBankCards(profileId: string, onLocked: () => void) {
@@
   const [searchInput, setSearchInput] = useState('');
+  const [searchFilters, setSearchFilters] = useState<VaultSearchFilters>(defaultVaultSearchFilters);
@@
   const visibleCards = useMemo(() => {
@@
-    if (searchQuery) {
-      pool = pool.filter((card) => {
+    if (searchFilters.favorites) pool = pool.filter((c) => c.isFavorite);
+    if (searchFilters.hasNotes) pool = pool.filter((c) => c.hasNote);
+
+    if (searchQuery) {
+      pool = pool.filter((card) => {
         const haystack = [card.title, card.holder, card.number, card.note, card.tags?.join(' ')]
           .filter(Boolean)
           .join(' ')
           .toLowerCase();
@@
-    return pool;
-  }, [cards, deletedCards, selectedNav, searchQuery]);
+    return pool;
+  }, [cards, deletedCards, searchFilters, selectedNav, searchQuery]);
@@
   return {
@@
     searchQuery: searchInput,
     setSearchQuery: setSearchInput,
+    searchFilters,
+    setSearchFilters,
@@
   };
 }
```

---

### 12) `src-tauri/src/types.rs`

**Why:** backend summary structs must expose the new flags (no secrets).

```diff
--- before: src-tauri/src/types.rs
+++ after:  src-tauri/src/types.rs
@@
 pub struct DataCardSummary {
     pub id: String,
     pub folder_id: Option<String>,
     pub title: String,
     pub url: Option<String>,
     pub email: Option<String>,
     pub username: Option<String>,
     pub has_totp: bool,
+    pub has_attachments: bool,
+    pub has_seed_phrase: bool,
+    pub has_phone: bool,
+    pub has_note: bool,
     pub tags_json: String,
     pub is_favorite: bool,
     pub created_at: String,
     pub updated_at: String,
     pub deleted_at: Option<String>,
 }
@@
 pub struct BankCardSummary {
     pub id: String,
     pub title: String,
     pub holder: Option<String>,
     pub number: Option<String>,
+    pub has_note: bool,
     pub tags_json: String,
     pub is_favorite: bool,
     pub created_at: String,
     pub updated_at: String,
     pub deleted_at: Option<String>,
 }
```

---

### 13) `src-tauri/src/data/sqlite/repo_impl.rs`

**Why:** compute summary flags in SQL (cheap), then map into Rust structs.

#### 13.1) `map_datacard_summary` and `map_bank_card_summary`

```diff
--- before: src-tauri/src/data/sqlite/repo_impl.rs
+++ after:  src-tauri/src/data/sqlite/repo_impl.rs
@@
 fn map_datacard_summary(row: &Row) -> rusqlite::Result<DataCardSummary> {
     let totp_uri: Option<String> = row.get("totp_uri")?;
     Ok(DataCardSummary {
         id: row.get("id")?,
         folder_id: row.get("folder_id")?,
         title: row.get("title")?,
         url: row.get("url")?,
         email: row.get("email")?,
         username: row.get("username")?,
         has_totp: totp_uri.is_some(),
+        has_attachments: row.get::<_, i64>("has_attachments")? != 0,
+        has_seed_phrase: row.get::<_, i64>("has_seed_phrase")? != 0,
+        has_phone: row.get::<_, i64>("has_phone")? != 0,
+        has_note: row.get::<_, i64>("has_note")? != 0,
         tags_json: row.get("tags_json")?,
         is_favorite: row.get("is_favorite")?,
         created_at: row.get("created_at")?,
         updated_at: row.get("updated_at")?,
         deleted_at: row.get("deleted_at")?,
     })
 }
@@
 fn map_bank_card_summary(row: &Row) -> rusqlite::Result<BankCardSummary> {
     Ok(BankCardSummary {
         id: row.get("id")?,
         title: row.get("title")?,
         holder: row.get("holder")?,
         number: row.get("number")?,
+        has_note: row.get::<_, i64>("has_note")? != 0,
         tags_json: row.get("tags_json")?,
         is_favorite: row.get("is_favorite")?,
         created_at: row.get("created_at")?,
         updated_at: row.get("updated_at")?,
         deleted_at: row.get("deleted_at")?,
     })
 }
```

#### 13.2) `list_datacards_summary` query

```diff
--- before: src-tauri/src/data/sqlite/repo_impl.rs
+++ after:  src-tauri/src/data/sqlite/repo_impl.rs
@@
         let clause = order_clause(sort_field, sort_dir)
             .ok_or_else(|| ErrorCodeString::new("DB_QUERY_FAILED"))?;
         let query = format!(
-            "SELECT id, folder_id, title, url, email, username, totp_uri, tags_json, is_favorite, created_at, updated_at, deleted_at FROM datacards WHERE deleted_at IS NULL {clause}"
+            "SELECT \
+              id, folder_id, title, url, email, username, totp_uri, tags_json, is_favorite, created_at, updated_at, deleted_at, \
+              EXISTS(SELECT 1 FROM attachments a WHERE a.datacard_id = datacards.id AND a.deleted_at IS NULL) AS has_attachments, \
+              CASE WHEN seed_phrase_word_count IS NULL THEN 0 ELSE 1 END AS has_seed_phrase, \
+              CASE WHEN mobile_phone IS NULL OR TRIM(mobile_phone) = '' THEN 0 ELSE 1 END AS has_phone, \
+              CASE WHEN note IS NULL OR TRIM(note) = '' THEN 0 ELSE 1 END AS has_note \
+            FROM datacards \
+            WHERE deleted_at IS NULL {clause}"
         );
```

#### 13.3) `list_deleted_datacards_summary` query

```diff
--- before: src-tauri/src/data/sqlite/repo_impl.rs
+++ after:  src-tauri/src/data/sqlite/repo_impl.rs
@@
         let mut stmt = conn
             .prepare(
-                "SELECT id, folder_id, title, url, email, username, totp_uri, tags_json, is_favorite, created_at, updated_at, deleted_at FROM datacards WHERE deleted_at IS NOT NULL ORDER BY deleted_at DESC",
+                "SELECT \
+                  id, folder_id, title, url, email, username, totp_uri, tags_json, is_favorite, created_at, updated_at, deleted_at, \
+                  EXISTS(SELECT 1 FROM attachments a WHERE a.datacard_id = datacards.id AND a.deleted_at IS NULL) AS has_attachments, \
+                  CASE WHEN seed_phrase_word_count IS NULL THEN 0 ELSE 1 END AS has_seed_phrase, \
+                  CASE WHEN mobile_phone IS NULL OR TRIM(mobile_phone) = '' THEN 0 ELSE 1 END AS has_phone, \
+                  CASE WHEN note IS NULL OR TRIM(note) = '' THEN 0 ELSE 1 END AS has_note \
+                FROM datacards \
+                WHERE deleted_at IS NOT NULL \
+                ORDER BY deleted_at DESC",
             )
             .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
```

#### 13.4) `list_bank_cards_summary` query

```diff
--- before: src-tauri/src/data/sqlite/repo_impl.rs
+++ after:  src-tauri/src/data/sqlite/repo_impl.rs
@@
         let query = format!(
-            "SELECT id, title, holder, number, tags_json, is_favorite, created_at, updated_at, deleted_at FROM bank_cards WHERE deleted_at IS NULL {clause}"
+            "SELECT \
+              id, title, holder, number, tags_json, is_favorite, created_at, updated_at, deleted_at, \
+              CASE WHEN note IS NULL OR TRIM(note) = '' THEN 0 ELSE 1 END AS has_note \
+            FROM bank_cards \
+            WHERE deleted_at IS NULL {clause}"
         );
```

#### 13.5) `list_deleted_bank_cards_summary` query

```diff
--- before: src-tauri/src/data/sqlite/repo_impl.rs
+++ after:  src-tauri/src/data/sqlite/repo_impl.rs
@@
-        let mut stmt = conn
-            .prepare(
-                "SELECT id, title, holder, number, tags_json, is_favorite, created_at, updated_at, deleted_at FROM bank_cards WHERE deleted_at IS NOT NULL ORDER BY deleted_at DESC",
-            )
+        let mut stmt = conn
+            .prepare(
+                "SELECT \
+                  id, title, holder, number, tags_json, is_favorite, created_at, updated_at, deleted_at, \
+                  CASE WHEN note IS NULL OR TRIM(note) = '' THEN 0 ELSE 1 END AS has_note \
+                FROM bank_cards \
+                WHERE deleted_at IS NOT NULL \
+                ORDER BY deleted_at DESC",
+            )
             .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
```

---

[1]: https://www.w3.org/WAI/ARIA/apg/patterns/button/?utm_source=chatgpt.com "Button Pattern | APG | WAI"
[2]: https://lucide.dev/icons/sliders-horizontal?utm_source=chatgpt.com "sliders-horizontal"
