## Technical Specification (TS) — English

### Title

Stabilize SQLite connection pool startup: reduce eager connections and improve BUSY handling (post-WAL fix)

### Background

We already moved `PRAGMA journal_mode=WAL` to DB init because WAL is a persistent **database-file** setting and should not be executed from pool `on_acquire` concurrently. ([SQLite][2])
Remaining stability issues can occur due to eager pool warm-up (`min_idle`) and short transient locks. r2d2 maintains at least `min_idle` idle connections when configured. ([Diesel Documentation][1])
SQLite/rusqlite supports waiting on locks via `busy_timeout`. ([Docs.rs][3])

### Goals

1. Avoid eager creation of multiple SQLite connections at startup.
2. Reduce chances of transient `SQLITE_BUSY` turning into user-facing failures.
3. Keep pool configuration aligned with desktop-app needs (low concurrency, portable drive friendly).

### Non-Goals

* No schema migrations.
* No changes to business logic or UI.

---

## Implementation

### A) Reduce eager pool warm-up and limit concurrency

#### File

`src-tauri/src/data/sqlite/pool.rs`

#### Change

In `get_or_create_pool(...)`, adjust pool builder configuration:

**Current (example, adapt to exact code you have):**

```rust
let pool = r2d2::Pool::builder()
    .max_size(8)
    .min_idle(Some(4))
    .build(manager)
    .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
```

**Replace with:**

```rust
let pool = r2d2::Pool::builder()
    .max_size(2)
    .min_idle(Some(0))
    .connection_timeout(std::time::Duration::from_secs(10))
    .build(manager)
    .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
```

**Rationale**

* `min_idle(Some(0))` instructs the pool to maintain **zero** idle connections proactively, preventing startup “connection stampede”. `min_idle` semantics: maintain at least N idle connections. ([Diesel Documentation][1])
* `max_size(2)` is sufficient for a desktop password manager (typically single-user UI thread + a background task). It reduces write contention on SQLite.
* `connection_timeout(...)` avoids instant failures when pool is briefly exhausted (Pool::get waits up to the configured timeout). ([Kvnallsn][4])

> Note: If you prefer even stricter serialization, set `max_size(1)`.

---

### B) Increase busy wait on each pooled connection (connection-scoped)

#### File

`src-tauri/src/data/sqlite/pool.rs`

#### Change

In `FilePragmas::on_acquire`:

**Current**

```rust
conn.busy_timeout(Duration::from_secs(5))?;
```

**Replace with**

```rust
conn.busy_timeout(Duration::from_secs(15))?;
```

Keep:

```rust
PRAGMA foreign_keys = ON;
PRAGMA synchronous = NORMAL;
```

**Rationale**

* `busy_timeout` is a standard approach to tolerate transient locks; `rusqlite` exposes it as `busy_timeout`. ([Docs.rs][3])
* `foreign_keys` enforcement must be enabled per connection (non-persistent). ([SQLite][5])

---

### C) Add busy timeout in file DB init (init connection)

#### File

`src-tauri/src/data/sqlite/init.rs`

#### Change

Inside `init_database_passwordless(...)`, right after `Connection::open(...)` and before migrations/WAL:

Add:

```rust
use std::time::Duration;

conn.busy_timeout(Duration::from_secs(15))
    .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
```

**Rationale**
Init performs PRAGMA/migrations and should also tolerate short-lived locks. `busy_timeout` is connection-scoped and must be set on that init connection too. ([Docs.rs][3])

---

## Acceptance Criteria

1. On fresh workspace/profile, app starts without `database is locked` and without user-facing “Operation failed” caused by transient BUSY.
2. Pool does not eagerly create multiple connections at startup (`min_idle(Some(0))`), verified by reduced pool logs / fewer immediate acquisitions.
3. Under transient locking conditions, operations wait up to the configured busy timeout instead of failing immediately. ([Docs.rs][6])

