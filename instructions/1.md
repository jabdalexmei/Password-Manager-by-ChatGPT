
## TECHNICAL SPECIFICATION (Windows-only)

### Scope

Fix 3 issues:

1. Backup **Import/Export icons/actions are swapped**.
2. **Lock button** does not work properly for password-protected profile (UI stays “inside vault”, backend is locked).
3. **Create Data Card hangs** in password-protected profile (likely due to synchronous vault persistence after every mutation).

Also: keep existing behavior for passwordless profiles; **no backward compatibility** required.

---

# 1) Fix swapped Import/Export actions (UI)

### Problem

User clicks “Export” icon but Import/Restore flow starts, and vice versa.

### Files

* `src/features/Vault/components/Header/VaultHeader.tsx`
* `src/features/Vault/Vault.tsx` (only if handlers are wired incorrectly here)

### Required Changes

## 1.1 Ensure correct onClick mapping in `VaultHeader.tsx`

**Target:** The icon that visually means “export/download” MUST call `onExportBackup`.
The icon that visually means “import/upload/restore” MUST call `onImportBackup`.

Find the buttons that render:

* `IconDownload` (export)
* `IconImport` (import)

**Must be:**

```tsx
<button
  type="button"
  className="vault-header__icon-button"
  onClick={onExportBackup}
  aria-label={tCommon('backup.export')}
  title={tCommon('backup.export')}
>
  <IconDownload />
</button>

<button
  type="button"
  className="vault-header__icon-button"
  onClick={onImportBackup}
  aria-label={tCommon('backup.import')}
  title={tCommon('backup.import')}
>
  <IconImport />
</button>
```

## 1.2 Verify handlers in `Vault.tsx` are not reversed

In:

```tsx
<VaultHeader
  onExportBackup={handleExportBackup}
  onImportBackup={handleImportBackup}
/>
```

**Must remain exactly like this** (export → export modal, import → restore flow).

### Acceptance Criteria

* Clicking Export icon opens Export backup modal / export flow.
* Clicking Import icon opens Choose file / restore flow.
* No other button affected.

---

# 2) Fix Lock button for password-protected profiles

### Problem

In password-protected profile, clicking the lock icon “does nothing” (UI doesn’t leave vault), and after that create/update operations may hang or behave incorrectly.

### Root Cause (current architecture)

Backend `lock_vault()` clears `vault_session`, but **does not clear `active_profile`**, so UI can remain in Vault screen while backend is locked.
On frontend, `useVault.lock()` clears local state but **does not call `onLocked()`**, so navigation may not happen.

### Files

Backend:

* `src-tauri/src/services/security_service.rs`

Frontend:

* `src/features/Vault/useVault.ts`

---

## 2.1 Backend: clear `active_profile` during lock

### Change in `src-tauri/src/services/security_service.rs`

Locate:

```rust
pub fn lock_vault(state: &Arc<AppState>) -> Result<bool> {
    if let Some(id) = persist_active_vault(state)? {
        attachments_service::clear_previews_for_profile(state, &id)?;

        {
            let mut session = state.vault_session.lock()
                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
            *session = None;
        }

        clear_pool(&id);
    }

    Ok(true)
}
```

**Replace with:**

```rust
pub fn lock_vault(state: &Arc<AppState>) -> Result<bool> {
    let persisted_id = persist_active_vault(state)?;

    // Always drop session (even if persist returned None).
    let active_id = {
        let active = state
            .active_profile
            .lock()
            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
            .clone();
        active
    };

    // Determine which profile to clean up: prefer persisted_id, fallback to active_id.
    let cleanup_id = persisted_id.clone().or(active_id.clone());

    if let Some(id) = cleanup_id.as_ref() {
        attachments_service::clear_previews_for_profile(state, id)?;
    }

    {
        let mut session = state
            .vault_session
            .lock()
            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
        *session = None;
    }

    // IMPORTANT: clear active_profile so frontend cannot stay in Vault screen while locked.
    {
        let mut active = state
            .active_profile
            .lock()
            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
        *active = None;
    }

    if let Some(id) = cleanup_id.as_ref() {
        clear_pool(id);
    }

    Ok(true)
}
```

### Notes

* This is Windows-only scope; no platform branching needed.
* This eliminates “half-logged-in” state.

---

## 2.2 Frontend: after successful lock, navigate out via `onLocked()`

### Change in `src/features/Vault/useVault.ts`

Locate `lock` function:

```ts
const lock = useCallback(async () => {
  try {
    setIsLocking(true);
    await lockVault();
    // clears local state...
  } finally {
    setIsLocking(false);
  }
}, [...]);
```

**Modify to call `onLocked()` after success**, and also treat `VAULT_LOCKED` as success (already locked).

Exact patch (keep your local state resets as-is; add the marked lines):

```ts
const lock = useCallback(async () => {
  try {
    setIsLocking(true);

    try {
      await lockVault();
    } catch (err) {
      // If backend already considers it locked, treat as success.
      if (isBackendError(err, 'VAULT_LOCKED')) {
        // continue
      } else {
        throw err;
      }
    }

    // existing local resets (folders/cards/etc) stay here...

    // NEW: force navigation out of vault screen
    onLocked();
  } finally {
    setIsLocking(false);
  }
}, [onLocked, /* keep existing deps */]);
```

### Acceptance Criteria

* In password-protected profile: click lock → immediately returns to profile/login screen.
* After lock: any vault commands requiring session should not be callable from UI.
* No “stuck in vault but locked” state.

---

# 3) Fix “Create Data Card hangs” in password-protected profile

### Problem

When saving a new card in password-protected profile, UI stays in “creating…” state for too long / indefinitely.

### High-confidence cause

Protected vault uses in-memory SQLite and after each write you call:

* `security_service::persist_active_vault(state)?;`

That does:

* serialize full DB → encrypt → write file
  This can be slow or blocked transiently on Windows filesystem/AV locks. When this happens inside the same invoke call, frontend waits and looks frozen.

### Strategy

Make persistence **asynchronous + coalesced**:

* DB mutation returns quickly to frontend.
* Persistence is scheduled in background (single in-flight worker).
* Lock/Backup/Restore can still force sync persistence when needed.

This avoids UI hangs while keeping safety.

### Files

Backend:

* `src-tauri/src/app_state.rs`
* `src-tauri/src/services/security_service.rs`
* Replace sync persist calls in:

  * `src-tauri/src/services/datacards_service.rs`
  * `src-tauri/src/services/folders_service.rs`
  * `src-tauri/src/services/bank_cards_service.rs`
  * `src-tauri/src/services/password_history_service.rs`
  * `src-tauri/src/services/attachments_service.rs` (if it persists)

---

## 3.1 Add coalescing flags to AppState

### Change in `src-tauri/src/app_state.rs`

Add imports:

```rust
use std::sync::atomic::AtomicBool;
use std::sync::atomic::Ordering;
```

In `pub struct AppState`, add:

```rust
pub vault_persist_requested: AtomicBool,
pub vault_persist_in_flight: AtomicBool,
```

In `AppState::new(...)` (or wherever AppState is constructed), initialize:

```rust
vault_persist_requested: AtomicBool::new(false),
vault_persist_in_flight: AtomicBool::new(false),
```

---

## 3.2 Add background persistence scheduler

### Change in `src-tauri/src/services/security_service.rs`

Add function (new):

```rust
use std::sync::atomic::Ordering;

pub fn request_persist_active_vault(state: Arc<AppState>) {
    // Mark that we want persistence.
    state.vault_persist_requested.store(true, Ordering::SeqCst);

    // If worker already running, do nothing.
    if state.vault_persist_in_flight.swap(true, Ordering::SeqCst) {
        return;
    }

    tauri::async_runtime::spawn_blocking(move || {
        loop {
            // Reset the requested flag for this cycle.
            state.vault_persist_requested.store(false, Ordering::SeqCst);

            // Best effort persist (log errors, do not crash).
            if let Err(e) = persist_active_vault(&state) {
                log::error!("[SECURITY][persist_active_vault] failed: {e:?}");
            }

            // If nothing new requested during persist, stop the worker.
            if !state.vault_persist_requested.load(Ordering::SeqCst) {
                break;
            }
        }

        state.vault_persist_in_flight.store(false, Ordering::SeqCst);

        // Edge case: request arrived right after we set in_flight=false.
        // If requested is true, schedule again.
        if state.vault_persist_requested.load(Ordering::SeqCst) {
            request_persist_active_vault(state);
        }
    });
}
```

**Important:** This uses Tauri runtime and works on Windows.

---

## 3.3 Replace synchronous persist calls in mutation services

### Required rule

For services that mutate DB state, **remove**:

```rust
security_service::persist_active_vault(state)?;
```

and **replace** with:

```rust
security_service::request_persist_active_vault(state.clone());
```

### Concrete files & functions

#### A) `src-tauri/src/services/datacards_service.rs`

In:

* `create_datacard`
* `update_datacard`
* `delete_datacard`
* `restore_datacard`

Replace sync persist with async request.

Example (exact style):

```rust
// OLD
security_service::persist_active_vault(state)?;

// NEW
security_service::request_persist_active_vault(state.clone());
```

#### B) `src-tauri/src/services/folders_service.rs`

In create/update/delete: same replacement.

#### C) `src-tauri/src/services/bank_cards_service.rs`

In create/update/delete/restore: same replacement.

#### D) `src-tauri/src/services/password_history_service.rs`

After writes: same replacement.

#### E) `src-tauri/src/services/attachments_service.rs`

Only if it persists vault after attachment operations: same replacement.

---

## 3.4 Keep synchronous persistence where correctness requires it

Do NOT change these:

* `security_service::lock_vault` should still call `persist_active_vault(state)?` first (it already does).
* `backup_service::backup_create` may call persist to ensure backup contains latest state.

(That’s the safety net.)

---

### Acceptance Criteria

1. Password-protected profile:

   * Create card completes quickly (UI does not hang indefinitely).
   * Card appears in list after creation.
   * Data survives app restart (background persist must complete; lock/exit persists anyway).

2. No regression for passwordless profiles.

3. Logs:

   * If Windows filesystem temporarily blocks writes, you see backend error logs but **UI does not freeze**.

---

# Notes on the tao warnings in your logs

These warnings:

* `NewEvents emitted without explicit RedrawEventsCleared`
* `RedrawEventsCleared emitted without explicit MainEventsCleared`

are known in the winit/tao ecosystem and often happen on focus/refresh and **do not necessarily indicate your app is broken**. You can treat them as noise unless they correlate with actual UI issues. ([GitHub][1])

---

# Invoke arguments convention (do not break)

Tauri converts **command argument names** from Rust snake_case to JS camelCase by default; keep frontend sending `backupPath`, `destinationPath`, `useDefaultPath` unless you explicitly set `#[tauri::command(rename_all="snake_case")]`. ([Tauri][2])

