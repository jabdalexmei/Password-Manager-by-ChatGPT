diff -ruN a/src-tauri/src/data/crypto/dpapi.rs b/src-tauri/src/data/crypto/dpapi.rs
--- a/src-tauri/src/data/crypto/dpapi.rs	2026-01-20 01:45:47.000000000 +0000
+++ b/src-tauri/src/data/crypto/dpapi.rs	2026-01-20 01:55:52.028339217 +0000
@@ -1,26 +1,32 @@
 use crate::error::{ErrorCodeString, Result};
 
-/// Windows DPAPI wrapper (CryptProtectData / CryptUnprotectData).
+/// Windows DPAPI wrapper (CryptUnprotectData).
 ///
 /// Always uses `CRYPTPROTECT_UI_FORBIDDEN` to prevent any UI prompt.
 ///
 /// The optional `entropy` is additional authenticated data for DPAPI. We use it
 /// (e.g., profile_id bytes) to make accidental file swaps fail early.
+///
+/// NOTE:
+/// We only keep the *unprotect* direction. New passwordless profiles are
+/// portable and store the master key in `vault_key.bin` (unwrapped), so we no
+/// longer need to *protect* data via DPAPI for newly created profiles.
+///
+/// We still use DPAPI unprotect for backwards-compatibility when restoring
+/// legacy passwordless profiles that used `dpapi_key.bin`.
 #[cfg(windows)]
 mod imp {
     use super::*;
-    use std::ptr;
     use core::ffi::c_void;
+    use std::mem::MaybeUninit;
+    use std::ptr;
 
     // windows-sys does not always expose the `DATA_BLOB` alias name.
     // In Win32 headers, `DATA_BLOB` is just an alias of `_CRYPTOAPI_BLOB` (aka
     // `CRYPT_INTEGER_BLOB`). We use `CRYPT_INTEGER_BLOB` to keep this compatible
     // across windows-sys versions.
-    //
-    // Ref: in Win32 headers `DATA_BLOB` is an alias of `_CRYPTOAPI_BLOB`.
-    // (see the `CRYPT_INTEGER_BLOB`/`_CRYPTOAPI_BLOB` family of aliases).
     use windows_sys::Win32::Security::Cryptography::{
-        CryptProtectData, CryptUnprotectData, CRYPTPROTECT_UI_FORBIDDEN, CRYPT_INTEGER_BLOB,
+        CryptUnprotectData, CRYPTPROTECT_UI_FORBIDDEN, CRYPT_INTEGER_BLOB,
     };
     // `LocalFree` is exposed from Win32 Foundation in windows-sys.
     use windows_sys::Win32::Foundation::LocalFree;
@@ -34,48 +40,6 @@
         }
     }
 
-    pub fn protect(plaintext: &[u8], entropy: Option<&[u8]>) -> Result<Vec<u8>> {
-        unsafe {
-            let mut in_blob = blob_from_slice(plaintext);
-            let mut out_blob = DataBlob {
-                cbData: 0,
-                pbData: ptr::null_mut(),
-            };
-
-            let mut ent_blob = DataBlob {
-                cbData: 0,
-                pbData: ptr::null_mut(),
-            };
-            let ent_ptr: *mut DataBlob = match entropy {
-                Some(e) if !e.is_empty() => {
-                    ent_blob = blob_from_slice(e);
-                    &mut ent_blob as *mut DataBlob
-                }
-                _ => ptr::null_mut(),
-            };
-
-            let ok = CryptProtectData(
-                &mut in_blob as *mut DataBlob,
-                ptr::null(),
-                ent_ptr,
-                ptr::null_mut(),
-                ptr::null_mut(),
-                CRYPTPROTECT_UI_FORBIDDEN,
-                &mut out_blob as *mut DataBlob,
-            );
-
-            if ok == 0 {
-                return Err(ErrorCodeString::new("DPAPI_PROTECT_FAILED"));
-            }
-
-            let out =
-                std::slice::from_raw_parts(out_blob.pbData as *const u8, out_blob.cbData as usize)
-                    .to_vec();
-            let _ = LocalFree(out_blob.pbData as *mut c_void);
-            Ok(out)
-        }
-    }
-
     pub fn unprotect(ciphertext: &[u8], entropy: Option<&[u8]>) -> Result<Vec<u8>> {
         unsafe {
             let mut in_blob = blob_from_slice(ciphertext);
@@ -84,14 +48,11 @@
                 pbData: ptr::null_mut(),
             };
 
-            let mut ent_blob = DataBlob {
-                cbData: 0,
-                pbData: ptr::null_mut(),
-            };
+            let mut ent_blob = MaybeUninit::<DataBlob>::uninit();
             let ent_ptr: *mut DataBlob = match entropy {
                 Some(e) if !e.is_empty() => {
-                    ent_blob = blob_from_slice(e);
-                    &mut ent_blob as *mut DataBlob
+                    ent_blob.write(blob_from_slice(e));
+                    ent_blob.as_mut_ptr()
                 }
                 _ => ptr::null_mut(),
             };
@@ -120,21 +81,11 @@
 }
 
 #[cfg(windows)]
-pub fn protect(plaintext: &[u8], entropy: Option<&[u8]>) -> Result<Vec<u8>> {
-    imp::protect(plaintext, entropy)
-}
-
-#[cfg(windows)]
 pub fn unprotect(ciphertext: &[u8], entropy: Option<&[u8]>) -> Result<Vec<u8>> {
     imp::unprotect(ciphertext, entropy)
 }
 
 #[cfg(not(windows))]
-pub fn protect(_plaintext: &[u8], _entropy: Option<&[u8]>) -> Result<Vec<u8>> {
-    Err(ErrorCodeString::new("WINDOWS_ONLY"))
-}
-
-#[cfg(not(windows))]
 pub fn unprotect(_ciphertext: &[u8], _entropy: Option<&[u8]>) -> Result<Vec<u8>> {
     Err(ErrorCodeString::new("WINDOWS_ONLY"))
 }
diff -ruN a/src-tauri/src/data/crypto/key_check.rs b/src-tauri/src/data/crypto/key_check.rs
--- a/src-tauri/src/data/crypto/key_check.rs	2026-01-20 01:45:47.000000000 +0000
+++ b/src-tauri/src/data/crypto/key_check.rs	2026-01-20 01:57:30.018170959 +0000
@@ -1,5 +1,3 @@
-use std::path::Path;
-
 use rand::rngs::OsRng;
 use rand::RngCore;
 
@@ -21,10 +19,6 @@
     encrypt_key_check(profile_id, key, &payload)
 }
 
-pub fn write_key_check_blob(path: &Path, blob: &[u8]) -> Result<()> {
-    write_encrypted_file(path, blob)
-}
-
 pub fn create_key_check_file(
     sp: &StoragePaths,
     profile_id: &str,
diff -ruN a/src-tauri/src/data/crypto/master_key.rs b/src-tauri/src/data/crypto/master_key.rs
--- a/src-tauri/src/data/crypto/master_key.rs	2026-01-20 01:45:47.000000000 +0000
+++ b/src-tauri/src/data/crypto/master_key.rs	2026-01-20 01:56:21.941514180 +0000
@@ -79,17 +79,6 @@
     parse_plaintext(profile_id, &plaintext)
 }
 
-pub fn write_master_key_wrapped_with_dpapi(
-    sp: &StoragePaths,
-    profile_id: &str,
-    master_key: &[u8; MASTER_KEY_LEN],
-) -> Result<()> {
-    let plaintext = build_plaintext(profile_id, master_key);
-    let protected = dpapi::protect(plaintext.as_slice(), Some(profile_id.as_bytes()))?;
-    write_atomic(&dpapi_key_path(sp, profile_id)?, &protected)
-        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
-}
-
 pub fn read_master_key_wrapped_with_dpapi(
     sp: &StoragePaths,
     profile_id: &str,
diff -ruN a/src-tauri/src/data/profiles/registry.rs b/src-tauri/src/data/profiles/registry.rs
--- a/src-tauri/src/data/profiles/registry.rs	2026-01-20 01:45:47.000000000 +0000
+++ b/src-tauri/src/data/profiles/registry.rs	2026-01-20 01:58:14.157630621 +0000
@@ -4,7 +4,6 @@
 use std::path::PathBuf;
 use uuid::Uuid;
 
-use crate::data::crypto::cipher::PM_ENC_MAGIC;
 use crate::data::fs::atomic_write::write_atomic;
 use crate::data::profiles::paths::{
     dpapi_key_path,
@@ -173,24 +172,6 @@
         .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
 }
 
-fn vault_looks_encrypted(sp: &StoragePaths, id: &str) -> bool {
-    let path = match vault_db_path(sp, id) {
-        Ok(p) => p,
-        Err(_) => return false,
-    };
-    if !path.exists() {
-        return false;
-    }
-    let mut f = match fs::File::open(path) {
-        Ok(f) => f,
-        Err(_) => return false,
-    };
-    let mut buf = [0u8; 6];
-    if f.read_exact(&mut buf).is_err() {
-        return false;
-    }
-    buf == PM_ENC_MAGIC
-}
 
 const SQLITE_HEADER_MAGIC: [u8; 16] = *b"SQLite format 3\0";
 
diff -ruN a/src-tauri/src/data/sqlite/init.rs b/src-tauri/src/data/sqlite/init.rs
--- a/src-tauri/src/data/sqlite/init.rs	2026-01-20 01:45:47.000000000 +0000
+++ b/src-tauri/src/data/sqlite/init.rs	2026-01-20 01:58:34.670864821 +0000
@@ -8,32 +8,6 @@
 
 use super::migrations;
 
-pub fn init_database_passwordless(sp: &StoragePaths, profile_id: &str) -> Result<()> {
-    ensure_profile_dirs(sp, profile_id)
-        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
-
-    let conn = Connection::open(vault_db_path(sp, profile_id)?)
-        .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
-
-    migrations::migrate_to_latest(&conn)?;
-
-    // Passwordless profiles are stored as plaintext SQLite files.
-    // Avoid WAL-mode for passwordless to prevent extra plaintext copies in *-wal/*-shm sidecar files.
-    // (Protected profiles are stored as encrypted blobs and do not use SQLite-on-disk.)
-    let current: String = conn
-        .query_row("PRAGMA journal_mode;", [], |row| row.get(0))
-        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
-
-    if current.to_uppercase() != "DELETE" {
-        // This PRAGMA changes the DB file state; run it only from init, not from r2d2 on_acquire.
-        let _: String = conn
-            .query_row("PRAGMA journal_mode=DELETE;", [], |row| row.get(0))
-            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
-    }
-
-    Ok(())
-}
-
 pub fn init_database_protected_encrypted(
     sp: &StoragePaths,
     profile_id: &str,
diff -ruN a/src-tauri/src/data/sqlite/pool.rs b/src-tauri/src/data/sqlite/pool.rs
--- a/src-tauri/src/data/sqlite/pool.rs	2026-01-20 01:45:47.000000000 +0000
+++ b/src-tauri/src/data/sqlite/pool.rs	2026-01-20 01:59:01.989158957 +0000
@@ -1,169 +1,27 @@
-use std::collections::{HashMap, HashSet};
+use std::collections::HashMap;
 use std::sync::Mutex;
-use std::time::{Duration, Instant};
 
 use once_cell::sync::Lazy;
-use r2d2::PooledConnection;
 use r2d2_sqlite::SqliteConnectionManager;
 
-use crate::error::{ErrorCodeString, Result};
-
-const DB_POOL_MAX_SIZE_FILE: u32 = 2;
-const DB_POOL_MIN_IDLE_FILE: u32 = 0;
-const DB_POOL_CONNECTION_TIMEOUT_SECS_FILE: u64 = 10;
-const DB_BUSY_TIMEOUT_SECS_FILE: u64 = 15;
-
-#[derive(Clone, Debug)]
-pub enum DbTarget {
-    File(std::path::PathBuf),
-}
+// NOTE:
+// This crate keeps the "pool" module because older versions used r2d2 to manage
+// file-backed SQLite connections. The current storage model keeps SQLite in
+// memory and persists an encrypted blob (`vault.db`), so there are no longer
+// on-disk SQLite connections to pool.
+//
+// We still keep a minimal pool registry so callers can invalidate any pooled
+// connections if this changes again in the future.
 
 static POOLS: Lazy<Mutex<HashMap<String, r2d2::Pool<SqliteConnectionManager>>>> =
     Lazy::new(|| Mutex::new(HashMap::new()));
 
-static MAINTENANCE: Lazy<Mutex<HashSet<String>>> =
-    Lazy::new(|| Mutex::new(HashSet::new()));
-
-#[derive(Debug)]
-struct FilePragmas;
-
-impl r2d2::CustomizeConnection<rusqlite::Connection, rusqlite::Error> for FilePragmas {
-    fn on_acquire(
-        &self,
-        conn: &mut rusqlite::Connection,
-    ) -> std::result::Result<(), rusqlite::Error> {
-        conn.busy_timeout(Duration::from_secs(DB_BUSY_TIMEOUT_SECS_FILE))?;
-        conn.execute_batch(
-            r#"
-            PRAGMA foreign_keys = ON;
-            -- Stronger durability: in WAL mode, FULL syncs the WAL on each commit.
-            -- This reduces the chance of losing the last transactions after sudden power loss/OS crash,
-            -- at the cost of slower writes.
-            PRAGMA synchronous = FULL;
-            "#,
-        )
-    }
-}
-
-fn get_or_create_pool(
-    profile_id: &str,
-    target: DbTarget,
-) -> Result<r2d2::Pool<SqliteConnectionManager>> {
-    let mut pools = POOLS
-        .lock()
-        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
-
-    let key = format!("{profile_id}::file");
-
-    log::info!("[DB][pool] profile_id={profile_id} target={target:?} key={key}");
-
-    if let Ok(m) = MAINTENANCE.lock() {
-        if m.contains(profile_id) {
-            log::warn!("[DB][pool] profile_id={profile_id} is in maintenance");
-            return Err(ErrorCodeString::new("DB_MAINTENANCE"));
-        }
-    }
-
-    if let Some(pool) = pools.get(&key) {
-        return Ok(pool.clone());
-    }
-
-    let pool = match target {
-        DbTarget::File(path) => {
-            let manager = SqliteConnectionManager::file(path);
-            r2d2::Pool::builder()
-                .max_size(DB_POOL_MAX_SIZE_FILE)
-                .min_idle(Some(DB_POOL_MIN_IDLE_FILE))
-                .connection_timeout(Duration::from_secs(DB_POOL_CONNECTION_TIMEOUT_SECS_FILE))
-                .connection_customizer(Box::new(FilePragmas))
-                .build(manager)
-                .map_err(|e| {
-                    log::error!("[DB][pool] build failed: {e:?}");
-                    ErrorCodeString::new("DB_OPEN_FAILED")
-                })?
-        }
-    };
-
-    pools.insert(key, pool.clone());
-    Ok(pool)
-}
-
-pub fn get_conn(
-    profile_id: &str,
-    target: DbTarget,
-) -> Result<PooledConnection<SqliteConnectionManager>> {
-    if let Ok(m) = MAINTENANCE.lock() {
-        if m.contains(profile_id) {
-            return Err(ErrorCodeString::new("DB_MAINTENANCE"));
-        }
-    }
-    let pool = get_or_create_pool(profile_id, target)?;
-    pool.get()
-        .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))
-}
-
-pub struct MaintenanceGuard {
-    profile_id: String,
-}
-
-impl MaintenanceGuard {
-    pub fn new(profile_id: &str) -> Result<Self> {
-        let mut m = MAINTENANCE
-            .lock()
-            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
-        m.insert(profile_id.to_string());
-        Ok(Self {
-            profile_id: profile_id.to_string(),
-        })
-    }
-}
-
-impl Drop for MaintenanceGuard {
-    fn drop(&mut self) {
-        if let Ok(mut m) = MAINTENANCE.lock() {
-            m.remove(&self.profile_id);
-        }
-    }
-}
-
 pub fn clear_pool(profile_id: &str) {
     if let Ok(mut pools) = POOLS.lock() {
         pools.retain(|key, _| !key.starts_with(&format!("{profile_id}::")));
     }
 }
 
-pub fn drain_and_drop_profile_pools(profile_id: &str, timeout: Duration) {
-    let deadline = Instant::now() + timeout;
-    loop {
-        let pools = match POOLS.lock() {
-            Ok(guard) => guard
-                .iter()
-                .filter_map(|(key, pool)| {
-                    if key.starts_with(&format!("{profile_id}::")) {
-                        Some(pool.clone())
-                    } else {
-                        None
-                    }
-                })
-                .collect::<Vec<_>>(),
-            Err(_) => return,
-        };
-
-        let all_idle = pools.iter().all(|pool| {
-            let state = pool.state();
-            state.connections == state.idle_connections
-        });
-
-        if all_idle || Instant::now() >= deadline {
-            break;
-        }
-
-        std::thread::sleep(Duration::from_millis(50));
-    }
-
-    clear_pool(profile_id);
-}
-
 pub fn clear_all_pools() {
     if let Ok(mut pools) = POOLS.lock() {
         pools.clear();
diff -ruN a/src-tauri/src/services/backup_service.rs b/src-tauri/src/services/backup_service.rs
--- a/src-tauri/src/services/backup_service.rs	2026-01-20 01:45:47.000000000 +0000
+++ b/src-tauri/src/services/backup_service.rs	2026-01-20 02:00:22.267155381 +0000
@@ -114,10 +114,6 @@
     kdf_salt_path: Option<PathBuf>,
     key_check_path: Option<PathBuf>,
     vault_key_path: Option<PathBuf>,
-
-    // Passwordless-mode file
-    dpapi_key_path: Option<PathBuf>,
-
     _temp_dir: Option<tempfile::TempDir>,
 }
 
@@ -338,7 +334,6 @@
         Some(p)
     };
 
-    let dpapi_key: Option<PathBuf> = None;
 
     let vault_path = vault_db_path(sp, profile_id)?;
 
@@ -351,7 +346,6 @@
             kdf_salt_path: salt_path,
             key_check_path: key_check,
             vault_key_path: vault_key,
-            dpapi_key_path: dpapi_key,
             _temp_dir: None,
         },
         vault_mode,
diff -ruN a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
--- a/src-tauri/src/services/security_service.rs	2026-01-20 01:45:47.000000000 +0000
+++ b/src-tauri/src/services/security_service.rs	2026-01-20 02:02:54.761936044 +0000
@@ -103,6 +103,7 @@
     }
 }
 
+#[allow(dead_code)]
 fn best_effort_checkpoint_and_set_journal_mode_delete_on_disk(
     vault_path: &Path,
     profile_id: &str,
@@ -429,6 +430,7 @@
     file_has_prefix(path, MAGIC)
 }
 
+#[allow(dead_code)]
 fn prepare_transition_backup_root(
     backup_root: &Path,
     storage_paths: &crate::data::storage_paths::StoragePaths,
@@ -449,6 +451,7 @@
 
 const REMOVE_PASSWORD_COMMIT_MARKER: &str = "remove_password.commit";
 
+#[allow(dead_code)]
 fn write_remove_password_commit_marker(backup_root: &Path) -> Result<()> {
     let marker_path = backup_root.join(REMOVE_PASSWORD_COMMIT_MARKER);
     write_atomic(&marker_path, b"1").map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
@@ -457,11 +460,13 @@
 const SET_PASSWORD_COMMIT_MARKER: &str = "set_password.commit";
 const CHANGE_PASSWORD_COMMIT_MARKER: &str = "change_password.commit";
 
+#[allow(dead_code)]
 fn write_set_password_commit_marker(backup_root: &Path) -> Result<()> {
     let marker_path = backup_root.join(SET_PASSWORD_COMMIT_MARKER);
     write_atomic(&marker_path, b"1").map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
 }
 
+#[allow(dead_code)]
 fn write_change_password_commit_marker(backup_root: &Path) -> Result<()> {
     let marker_path = backup_root.join(CHANGE_PASSWORD_COMMIT_MARKER);
     write_atomic(&marker_path, b"1").map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
@@ -1225,6 +1230,7 @@
     Ok(())
 }
 
+#[allow(dead_code)]
 fn recover_incomplete_profile_transitions(
     storage_paths: &crate::data::storage_paths::StoragePaths,
     profile_id: &str,
@@ -1379,6 +1385,7 @@
     }
 }
 
+#[allow(dead_code)]
 fn prepare_empty_dir(path: &Path) -> Result<()> {
     if path.exists() {
         remove_dir_all_retry(path, 40, Duration::from_millis(50))
@@ -1389,6 +1396,7 @@
     Ok(())
 }
 
+#[allow(dead_code)]
 fn list_attachment_files(dir: &Path) -> Result<Vec<PathBuf>> {
     if !dir.exists() {
         return Ok(Vec::new());
@@ -1412,6 +1420,7 @@
     Ok(stem.to_string())
 }
 
+#[allow(dead_code)]
 fn encrypt_attachments_plain_to_staging(
     profile_id: &str,
     key: &[u8; 32],
@@ -1440,6 +1449,7 @@
     Ok(())
 }
 
+#[allow(dead_code)]
 fn reencrypt_attachments_to_staging(
     profile_id: &str,
     old_key: &[u8; 32],
@@ -1605,6 +1615,7 @@
     Ok(true)
 }
 
+#[allow(dead_code)]
 pub fn drop_active_session_without_persist(state: &Arc<AppState>) -> Result<bool> {
     let storage_paths = state.get_storage_paths()?;
 

