diff -ruN /mnt/data/orig/Password-Manager-by-ChatGPT-codex-github-mention-handle-attachment-read-failures-during-plain/src-tauri/src/data/crypto/key_check.rs /mnt/data/work/Password-Manager-by-ChatGPT-codex-github-mention-handle-attachment-read-failures-during-plain/src-tauri/src/data/crypto/key_check.rs
--- /mnt/data/orig/Password-Manager-by-ChatGPT-codex-github-mention-handle-attachment-read-failures-during-plain/src-tauri/src/data/crypto/key_check.rs	2026-01-16 10:37:16.000000000 +0000
+++ /mnt/data/work/Password-Manager-by-ChatGPT-codex-github-mention-handle-attachment-read-failures-during-plain/src-tauri/src/data/crypto/key_check.rs	2026-01-16 10:46:33.756746947 +0000
@@ -1,3 +1,5 @@
+use std::path::Path;
+
 use rand::rngs::OsRng;
 use rand::RngCore;
 
@@ -10,17 +12,25 @@
 
 const KEY_CHECK_MAGIC: &[u8] = b"pm_key_check_v1";
 
-pub fn create_key_check_file(
-    sp: &StoragePaths,
-    profile_id: &str,
-    key: &[u8; KEY_LEN],
-) -> Result<()> {
+pub fn create_key_check_blob(profile_id: &str, key: &[u8; KEY_LEN]) -> Result<Vec<u8>> {
     let mut payload = Vec::from(KEY_CHECK_MAGIC);
     let mut random_bytes = [0u8; 16];
     OsRng.fill_bytes(&mut random_bytes);
     payload.extend_from_slice(&random_bytes);
 
-    let blob = encrypt_key_check(profile_id, key, &payload)?;
+    encrypt_key_check(profile_id, key, &payload)
+}
+
+pub fn write_key_check_blob(path: &Path, blob: &[u8]) -> Result<()> {
+    write_encrypted_file(path, blob)
+}
+
+pub fn create_key_check_file(
+    sp: &StoragePaths,
+    profile_id: &str,
+    key: &[u8; KEY_LEN],
+) -> Result<()> {
+    let blob = create_key_check_blob(profile_id, key)?;
     write_encrypted_file(&key_check_path(sp, profile_id)?, &blob)
 }
 
diff -ruN /mnt/data/orig/Password-Manager-by-ChatGPT-codex-github-mention-handle-attachment-read-failures-during-plain/src-tauri/src/services/security_service.rs /mnt/data/work/Password-Manager-by-ChatGPT-codex-github-mention-handle-attachment-read-failures-during-plain/src-tauri/src/services/security_service.rs
--- /mnt/data/orig/Password-Manager-by-ChatGPT-codex-github-mention-handle-attachment-read-failures-during-plain/src-tauri/src/services/security_service.rs	2026-01-16 10:37:16.000000000 +0000
+++ /mnt/data/work/Password-Manager-by-ChatGPT-codex-github-mention-handle-attachment-read-failures-during-plain/src-tauri/src/services/security_service.rs	2026-01-16 11:00:53.266306285 +0000
@@ -295,9 +295,11 @@
 
     let salt_path = kdf_salt_path(storage_paths, profile_id)?;
     let salt_backup_path = backup_root.join("kdf_salt.bin.bak");
+    let salt_new_path = backup_root.join("kdf_salt.bin.new");
 
     let key_path = key_check_path(storage_paths, profile_id)?;
     let key_backup_path = backup_root.join("key_check.bin.bak");
+    let key_new_path = backup_root.join("key_check.bin.new");
 
     let attachments_dir = profile_root.join("attachments");
     let attachments_plain_backup_dir = backup_root.join("attachments_plain");
@@ -306,9 +308,11 @@
     let vault_is_encrypted = vault_path.exists() && file_has_prefix(&vault_path, &cipher::PM_ENC_MAGIC);
     let has_salt = salt_path.exists();
     let has_key = key_path.exists();
+    let salt_ready = has_salt || salt_new_path.exists();
+    let key_ready = has_key || key_new_path.exists();
 
     // If core protected materials exist, prefer completing the transition.
-    if vault_is_encrypted && has_salt && has_key {
+    if vault_is_encrypted && salt_ready && key_ready {
         if attachments_staging_dir.exists() {
             // Complete attachments swap if needed.
             if attachments_dir.exists() {
@@ -354,6 +358,26 @@
             }
         }
 
+        // Commit staged key material if it was prepared but not moved into place.
+        if !has_salt && salt_new_path.exists() {
+            replace_file_retry(
+                &salt_new_path,
+                &salt_path,
+                20,
+                Duration::from_millis(50),
+            )
+            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+        }
+        if !has_key && key_new_path.exists() {
+            replace_file_retry(
+                &key_new_path,
+                &key_path,
+                20,
+                Duration::from_millis(50),
+            )
+            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+        }
+
         registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, true)?;
         clear_pool(profile_id);
         let _ = std::fs::remove_dir_all(backup_root);
@@ -384,6 +408,10 @@
         let _ = std::fs::remove_file(&salt_path);
     }
 
+    if salt_new_path.exists() {
+        let _ = std::fs::remove_file(&salt_new_path);
+    }
+
     if key_backup_path.exists() {
         if key_path.exists() {
             std::fs::remove_file(&key_path)
@@ -395,6 +423,10 @@
         let _ = std::fs::remove_file(&key_path);
     }
 
+    if key_new_path.exists() {
+        let _ = std::fs::remove_file(&key_new_path);
+    }
+
     if attachments_plain_backup_dir.exists() {
         if attachments_dir.exists() {
             std::fs::remove_dir_all(&attachments_dir)
@@ -439,9 +471,11 @@
 
     let salt_path = kdf_salt_path(storage_paths, profile_id)?;
     let salt_backup_path = backup_root.join("kdf_salt.bin.bak");
+    let salt_new_path = backup_root.join("kdf_salt.bin.new");
 
     let key_path = key_check_path(storage_paths, profile_id)?;
     let key_backup_path = backup_root.join("key_check.bin.bak");
+    let key_new_path = backup_root.join("key_check.bin.new");
 
     let attachments_dir = profile_root.join("attachments");
     let attachments_backup_dir = backup_root.join("attachments_old");
@@ -450,11 +484,13 @@
     let vault_ok = vault_path.exists() && file_has_prefix(&vault_path, &cipher::PM_ENC_MAGIC);
     let salt_ok = salt_path.exists();
     let key_ok = key_path.exists();
+    let salt_ready = salt_ok || salt_new_path.exists();
+    let key_ready = key_ok || key_new_path.exists();
 
     // If protected materials exist, prefer completing the transition.
     // change_profile_password writes new vault/key material first, then swaps attachments.
     // After a crash, we might have a new vault but attachments still old-key.
-    if vault_ok && salt_ok && key_ok {
+    if vault_ok && salt_ready && key_ready {
         if attachments_staging_dir.exists() {
             // Complete attachments swap if needed.
             if attachments_dir.exists() {
@@ -502,6 +538,26 @@
             }
         }
 
+        // Commit staged key material if it was prepared but not moved into place.
+        if !salt_ok && salt_new_path.exists() {
+            replace_file_retry(
+                &salt_new_path,
+                &salt_path,
+                20,
+                Duration::from_millis(50),
+            )
+            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+        }
+        if !key_ok && key_new_path.exists() {
+            replace_file_retry(
+                &key_new_path,
+                &key_path,
+                20,
+                Duration::from_millis(50),
+            )
+            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+        }
+
         registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, true)?;
         clear_pool(profile_id);
         let _ = std::fs::remove_dir_all(backup_root);
@@ -527,6 +583,10 @@
             .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
     }
 
+    if salt_new_path.exists() {
+        let _ = std::fs::remove_file(&salt_new_path);
+    }
+
     if key_backup_path.exists() {
         if key_path.exists() {
             std::fs::remove_file(&key_path)
@@ -536,6 +596,10 @@
             .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
     }
 
+    if key_new_path.exists() {
+        let _ = std::fs::remove_file(&key_new_path);
+    }
+
     if attachments_backup_dir.exists() {
         if attachments_dir.exists() {
             std::fs::remove_dir_all(&attachments_dir)
@@ -746,6 +810,31 @@
     }
 }
 
+fn remove_file_retry(path: &Path, attempts: u32, base_delay: Duration) -> io::Result<()> {
+    let mut i = 0;
+    loop {
+        match std::fs::remove_file(path) {
+            Ok(()) => return Ok(()),
+            Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(()),
+            Err(e) => {
+                i += 1;
+                if i >= attempts {
+                    return Err(e);
+                }
+                let backoff_ms = base_delay.as_millis() as u64 * i as u64;
+                std::thread::sleep(Duration::from_millis(backoff_ms.max(25).min(1500)));
+            }
+        }
+    }
+}
+
+fn replace_file_retry(from: &Path, to: &Path, attempts: u32, base_delay: Duration) -> io::Result<()> {
+    if to.exists() {
+        remove_file_retry(to, attempts, base_delay)?;
+    }
+    rename_retry(from, to, attempts, base_delay)
+}
+
 fn prepare_empty_dir(path: &Path) -> Result<()> {
     if path.exists() {
         std::fs::remove_dir_all(path)
@@ -1145,9 +1234,11 @@
 
         let salt_path = kdf_salt_path(&storage_paths, id)?;
         let salt_backup_path = backup_root.join("kdf_salt.bin.bak");
+        let salt_new_path = backup_root.join("kdf_salt.bin.new");
 
         let key_path = key_check_path(&storage_paths, id)?;
         let key_backup_path = backup_root.join("key_check.bin.bak");
+        let key_new_path = backup_root.join("key_check.bin.new");
 
         let attachments_dir = profile_root.join("attachments");
         let attachments_backup_dir = backup_root.join("attachments_plain");
@@ -1169,11 +1260,13 @@
 
             salt_path: PathBuf,
             salt_backup_path: PathBuf,
+            salt_new_path: PathBuf,
             salt_present_before: bool,
             salt_backed_up: bool,
 
             key_check_path: PathBuf,
             key_check_backup_path: PathBuf,
+            key_check_new_path: PathBuf,
             key_check_present_before: bool,
             key_check_backed_up: bool,
 
@@ -1193,6 +1286,9 @@
                 profile_id
             );
 
+            let _ = std::fs::remove_file(&rb.salt_new_path);
+            let _ = std::fs::remove_file(&rb.key_check_new_path);
+
             if rb.attachments_swapped {
                 let _ = std::fs::remove_dir_all(&rb.attachments_dir);
                 let _ = rename_retry(&rb.attachments_backup_dir, &rb.attachments_dir, 20, Duration::from_millis(50));
@@ -1228,11 +1324,13 @@
 
             salt_path: salt_path.clone(),
             salt_backup_path: salt_backup_path.clone(),
+            salt_new_path: salt_new_path.clone(),
             salt_present_before: salt_path.exists(),
             salt_backed_up: false,
 
             key_check_path: key_path.clone(),
             key_check_backup_path: key_backup_path.clone(),
+            key_check_new_path: key_new_path.clone(),
             key_check_present_before: key_path.exists(),
             key_check_backed_up: false,
 
@@ -1275,16 +1373,6 @@
             return Err(e);
         }
 
-        // Persist salt + key_check (must both exist for unlocking).
-        if write_atomic(&salt_path, &salt).is_err() {
-            rollback_set_profile_password(&storage_paths, id, &profile.name, &rb);
-            return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
-        }
-        if let Err(e) = key_check::create_key_check_file(&storage_paths, id, &*key) {
-            rollback_set_profile_password(&storage_paths, id, &profile.name, &rb);
-            return Err(e);
-        }
-
         // Swap attachments dir to encrypted form.
         if attachments_backup_dir.exists() {
             let _ = std::fs::remove_dir_all(&attachments_backup_dir);
@@ -1302,6 +1390,29 @@
                 ErrorCodeString::new("PROFILE_STORAGE_WRITE")
             })?;
 
+        // Two-phase commit for key material:
+        // 1) write to *.new under backup_root
+        // 2) atomically move into place after vault+attachments are committed
+        if write_atomic(&salt_new_path, &salt).is_err() {
+            rollback_set_profile_password(&storage_paths, id, &profile.name, &rb);
+            return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+        }
+        let key_blob = key_check::create_key_check_blob(id, &*key)?;
+        if let Err(e) = key_check::write_key_check_blob(&key_new_path, &key_blob) {
+            rollback_set_profile_password(&storage_paths, id, &profile.name, &rb);
+            return Err(e);
+        }
+        replace_file_retry(&salt_new_path, &salt_path, 20, Duration::from_millis(50))
+            .map_err(|_| {
+                rollback_set_profile_password(&storage_paths, id, &profile.name, &rb);
+                ErrorCodeString::new("PROFILE_STORAGE_WRITE")
+            })?;
+        replace_file_retry(&key_new_path, &key_path, 20, Duration::from_millis(50))
+            .map_err(|_| {
+                rollback_set_profile_password(&storage_paths, id, &profile.name, &rb);
+                ErrorCodeString::new("PROFILE_STORAGE_WRITE")
+            })?;
+
         // Switch runtime session to protected in-memory session so app stays unlocked.
         // (mem_conn already validated above)
 
@@ -1407,9 +1518,11 @@
 
     let salt_path = kdf_salt_path(&storage_paths, id)?;
     let salt_backup_path = backup_root.join("kdf_salt.bin.bak");
+    let salt_new_path = backup_root.join("kdf_salt.bin.new");
 
     let key_path = key_check_path(&storage_paths, id)?;
     let key_backup_path = backup_root.join("key_check.bin.bak");
+    let key_new_path = backup_root.join("key_check.bin.new");
 
     let attachments_dir = profile_root.join("attachments");
     let attachments_backup_dir = backup_root.join("attachments_old");
@@ -1429,10 +1542,12 @@
 
         salt_path: PathBuf,
         salt_backup_path: PathBuf,
+        salt_new_path: PathBuf,
         salt_backed_up: bool,
 
         key_check_path: PathBuf,
         key_check_backup_path: PathBuf,
+        key_check_new_path: PathBuf,
         key_check_backed_up: bool,
 
         attachments_dir: PathBuf,
@@ -1451,6 +1566,9 @@
             profile_id
         );
 
+        let _ = std::fs::remove_file(&rb.salt_new_path);
+        let _ = std::fs::remove_file(&rb.key_check_new_path);
+
         if rb.attachments_swapped {
             let _ = std::fs::remove_dir_all(&rb.attachments_dir);
             let _ = rename_retry(&rb.attachments_backup_dir, &rb.attachments_dir, 20, Duration::from_millis(50));
@@ -1482,10 +1600,12 @@
 
         salt_path: salt_path.clone(),
         salt_backup_path: salt_backup_path.clone(),
+        salt_new_path: salt_new_path.clone(),
         salt_backed_up: false,
 
         key_check_path: key_path.clone(),
         key_check_backup_path: key_backup_path.clone(),
+        key_check_new_path: key_new_path.clone(),
         key_check_backed_up: false,
 
         attachments_dir: attachments_dir.clone(),
@@ -1520,16 +1640,6 @@
         rb.key_check_backed_up = true;
     }
 
-    // Write new salt + key_check.
-    if write_atomic(&salt_path, &salt).is_err() {
-        rollback_change_profile_password(&storage_paths, id, &profile.name, &rb);
-        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
-    }
-    if let Err(e) = key_check::create_key_check_file(&storage_paths, id, &*new_key) {
-        rollback_change_profile_password(&storage_paths, id, &profile.name, &rb);
-        return Err(e);
-    }
-
     // Write new encrypted vault file.
     let encrypted = cipher::encrypt_vault_blob(id, &*new_key, &bytes)?;
     if let Err(e) = cipher::write_encrypted_file(&vault_path, &encrypted) {
@@ -1552,6 +1662,29 @@
         .map_err(|_| {
             rollback_change_profile_password(&storage_paths, id, &profile.name, &rb);
             ErrorCodeString::new("PROFILE_STORAGE_WRITE")
+        })?;
+
+    // Two-phase commit for key material:
+    // 1) write to *.new under backup_root
+    // 2) atomically move into place after vault+attachments are committed
+    if write_atomic(&salt_new_path, &salt).is_err() {
+        rollback_change_profile_password(&storage_paths, id, &profile.name, &rb);
+        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+    }
+    let key_blob = key_check::create_key_check_blob(id, &*new_key)?;
+    if let Err(e) = key_check::write_key_check_blob(&key_new_path, &key_blob) {
+        rollback_change_profile_password(&storage_paths, id, &profile.name, &rb);
+        return Err(e);
+    }
+    replace_file_retry(&salt_new_path, &salt_path, 20, Duration::from_millis(50))
+        .map_err(|_| {
+            rollback_change_profile_password(&storage_paths, id, &profile.name, &rb);
+            ErrorCodeString::new("PROFILE_STORAGE_WRITE")
+        })?;
+    replace_file_retry(&key_new_path, &key_path, 20, Duration::from_millis(50))
+        .map_err(|_| {
+            rollback_change_profile_password(&storage_paths, id, &profile.name, &rb);
+            ErrorCodeString::new("PROFILE_STORAGE_WRITE")
         })?;
 
     // Update in-memory session key to keep vault unlocked (only after commit).
