--- a/src-tauri/capabilities/default.json
+++ b/src-tauri/capabilities/default.json
@@ -1,11 +1,15 @@
 {
   "$schema": "../gen/schemas/desktop-schema.json",
   "identifier": "default",
-  "description": "Default permissions for main window (dialog open).",
-  "windows": ["main"],
+  "description": "Default permissions for main window.",
+  "windows": [
+    "main"
+  ],
   "permissions": [
-    "core:default",
-    "dialog:allow-open",
-    "dialog:allow-save"
+    "core:default"
   ]
 }
--- a/package.json
+++ b/package.json
@@ -1,27 +1,26 @@
 {
   "name": "Password-Manager",
   "version": "0.1.0",
   "private": true,
   "type": "module",
   "scripts": {
     "dev": "vite",
     "ci:install": "npm ci",
     "ci:build": "npm ci && npm run build",
     "zxing:guard": "node scripts/check-no-zxing-imports.mjs",
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "build": "npm run zxing:guard && npm run typecheck && vite build",
     "analyze": "npm run zxing:guard && npm run typecheck && vite build --mode analyze",
     "tauri:dev": "tauri dev",
     "tauri:build": "tauri build",
     "theme:check": "node scripts/check-theme-colors.mjs",
     "icons:check": "node scripts/check-no-inline-svg.mjs"
   },
   "dependencies": {
     "@zxing/browser": "0.1.5",
     "@tauri-apps/api": "2.0.0",
-    "@tauri-apps/plugin-dialog": "2.0.0",
     "lucide-react": "0.562.0",
     "otpauth": "9.4.1",
     "react": "18.3.1",
     "react-dom": "18.3.1"
   },
   "devDependencies": {
     "@tauri-apps/cli": "2.0.0",
     "@types/react": "18.3.3",
     "@types/react-dom": "18.3.0",
     "@vitejs/plugin-react": "4.3.3",
     "rollup-plugin-visualizer": "6.0.5",
     "typescript": "5.6.2",
     "vite": "5.4.0"
   }
 }
--- a/src/i18n/locales/en/Common.json
+++ b/src/i18n/locales/en/Common.json
@@ -1,12 +1,18 @@
 {
   "action.cancel": "Cancel",
   "action.close": "Close",
   "action.ok": "OK",
   "aria.dismissToast": "Dismiss toast",
   "error.backupProfileMismatch": "This backup belongs to a different profile and cannot be restored. ({code})",
   "error.backupUnsupportedFormat": "This backup format is not supported. ({code})",
+  "error.backupIntegrityFailed": "Backup integrity check failed.",
+  "error.backupInvalid": "Backup file is invalid or corrupted.",
+  "error.backupTooLarge": "Backup is too large to restore safely.",
+  "error.backupTooManyFiles": "Backup contains too many files to restore safely.",
+  "error.dialogUnsupported": "This operation is not supported on this platform.",
   "error.hookToaster": "Toaster hook not initialized",
+  "error.operationBlocked": "Operation blocked for security reasons.",
   "error.operationFailed": "Operation failed. Please try again.",
   "error.network": "Network error. Please check your connection. ({code})"
 }
--- a/src/features/Vault/hooks/useVault.ts
+++ b/src/features/Vault/hooks/useVault.ts
@@ -102,7 +102,23 @@
         case 'BACKUP_PROFILE_MISMATCH':
           return tCommon('error.backupProfileMismatch', { code });
         case 'BACKUP_UNSUPPORTED_FORMAT':
           return tCommon('error.backupUnsupportedFormat', { code });
-        case 'VALIDATION_ERROR':
+        case 'BACKUP_ARCHIVE_TOO_MANY_FILES':
+          return tCommon('error.backupTooManyFiles', { code });
+        case 'BACKUP_ARCHIVE_TOO_LARGE':
+          return tCommon('error.backupTooLarge', { code });
+        case 'BACKUP_ARCHIVE_INVALID':
+        case 'BACKUP_MANIFEST_INVALID':
+          return tCommon('error.backupInvalid', { code });
+        case 'BACKUP_INTEGRITY_FAILED':
+          return tCommon('error.backupIntegrityFailed', { code });
+        case 'DIALOG_UNSUPPORTED_FILE_URI':
+          return tCommon('error.dialogUnsupported', { code });
+        case 'WORKSPACE_CREATE_PATH_FORBIDDEN':
+        case 'BACKUP_DESTINATION_PATH_FORBIDDEN':
+        case 'BACKUP_RESTORE_PATH_FORBIDDEN':
+        case 'BACKUP_INSPECT_PATH_FORBIDDEN':
+          return tCommon('error.operationBlocked', { code });
+        case 'VALIDATION_ERROR':
           return fallback ?? tCommon('error.operationFailed', { code });
         default:
           return fallback ?? tCommon('error.operationFailed', { code });
       }
     },
     [tCommon]
--- a/src-tauri/src/services/backup_service.rs
+++ b/src-tauri/src/services/backup_service.rs
@@ -12,6 +12,12 @@
 use zip::{CompressionMethod, ZipArchive, ZipWriter};
 
 use crate::app_state::AppState;
+
+// Restore hard limits (anti zip-bomb / decompression bomb DoS)
+const MAX_RESTORE_FILES: usize = 4096;
+const MAX_RESTORE_ENTRY_BYTES: i64 = 64 * 1024 * 1024;
+const MAX_RESTORE_TOTAL_BYTES: i64 = 512 * 1024 * 1024;
+
 use crate::data::fs::atomic_write::write_atomic;
 use crate::data::profiles::paths::{
     attachments_dir, backups_dir, backup_registry_path, kdf_salt_path, key_check_path, profile_dir,
     profile_registry_path, profile_root_dir, vault_db_path,
 };
@@ -21862,6 +21868,30 @@ fn restore_archive_to_profile(
     if manifest.profile_id != target_profile_id {
         return Err(ErrorCodeString::new("BACKUP_PROFILE_MISMATCH"));
     }
+
+    if manifest.files.len() > MAX_RESTORE_FILES {
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_TOO_MANY_FILES"));
+    }
+
+    let mut total_declared: i64 = 0;
+    for f in &manifest.files {
+        if f.bytes < 0 {
+            return Err(ErrorCodeString::new("BACKUP_MANIFEST_INVALID"));
+        }
+        if f.bytes > MAX_RESTORE_ENTRY_BYTES {
+            return Err(ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"));
+        }
+        total_declared = total_declared
+            .checked_add(f.bytes)
+            .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
+        if total_declared > MAX_RESTORE_TOTAL_BYTES {
+            return Err(ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"));
+        }
+    }
 
     use std::collections::HashSet;
     let mut seen = HashSet::new();
     let mut has_vault = false;
     let mut has_kdf_salt = false;
@@ -21953,6 +21983,7 @@ fn restore_archive_to_profile(
         return Err(ErrorCodeString::new("BACKUP_MANIFEST_INVALID"));
     }
 
+    let mut total_written: i64 = 0;
     for entry in &manifest.files {
         let rel_path = Path::new(&entry.path);
         if !validate_zip_entry_rel_path_windows(rel_path) {
             return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
         }
@@ -21988,8 +22019,18 @@ fn restore_archive_to_profile(
             writer
                 .write_all(&buffer[..read])
                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-            hasher.update(&buffer[..read]);
-            bytes_written += read as i64;
+            bytes_written = bytes_written
+                .checked_add(read as i64)
+                .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
+            total_written = total_written
+                .checked_add(read as i64)
+                .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
+            if bytes_written > MAX_RESTORE_ENTRY_BYTES || total_written > MAX_RESTORE_TOTAL_BYTES {
+                return Err(ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"));
+            }
+            hasher.update(&buffer[..read]);
         }
         writer
             .flush()
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
         let sha256 = hex::encode(hasher.finalize());
