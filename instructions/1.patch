
## PATCH (часть 1/4)

```diff
diff --git a/src-tauri/src/bin/pm-native-host.rs b/src-tauri/src/bin/pm-native-host.rs
new file mode 100644
index 0000000..772a901
--- /dev/null
+++ b/src-tauri/src/bin/pm-native-host.rs
@@ -0,0 +1,180 @@
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+use std::io::{Read, Write};
+use std::net::TcpStream;
+use std::path::{Path, PathBuf};
+
+const MAX_FRAME_LEN: usize = 1024 * 1024; // 1MB
+
+#[derive(Debug, Deserialize)]
+struct NativeRequest {
+    pub id: String,
+    #[serde(rename = "type")]
+    pub kind: String,
+    pub payload: Value,
+}
+
+#[derive(Debug, Serialize)]
+struct NativeError {
+    pub code: String,
+}
+
+#[derive(Debug, Serialize)]
+struct NativeResponse {
+    pub id: String,
+    pub ok: bool,
+    pub result: Option<Value>,
+    pub error: Option<NativeError>,
+}
+
+#[derive(Debug, Deserialize)]
+struct IpcInfo {
+    pub schema_version: u8,
+    pub port: u16,
+    pub token: String,
+    pub created_at_ms: u128,
+}
+
+fn primary_ipc_info_path(app_dir: &Path) -> PathBuf {
+    app_dir.join("native-host.json")
+}
+
+fn fallback_ipc_info_path() -> Option<PathBuf> {
+    std::env::var_os("LOCALAPPDATA")
+        .map(PathBuf::from)
+        .map(|dir| dir.join("Password Manager").join("native-host.json"))
+}
+
+fn ipc_info_path_for_load(app_dir: &Path) -> PathBuf {
+    let primary = primary_ipc_info_path(app_dir);
+    if primary.exists() {
+        return primary;
+    }
+    if let Some(fallback) = fallback_ipc_info_path() {
+        if fallback.exists() {
+            return fallback;
+        }
+    }
+    primary
+}
+
+fn load_ipc_info(app_dir: &Path) -> Option<IpcInfo> {
+    let path = ipc_info_path_for_load(app_dir);
+    let content = std::fs::read_to_string(path).ok()?;
+    let info: IpcInfo = serde_json::from_str(&content).ok()?;
+    if info.schema_version != 1 {
+        return None;
+    }
+    Some(info)
+}
+
+fn read_frame<R: Read>(mut r: R) -> std::io::Result<Option<Vec<u8>>> {
+    let mut len_bytes = [0u8; 4];
+    match r.read_exact(&mut len_bytes) {
+        Ok(()) => {}
+        Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof => return Ok(None),
+        Err(err) => return Err(err),
+    }
+    let len = u32::from_ne_bytes(len_bytes) as usize;
+    if len == 0 || len > MAX_FRAME_LEN {
+        return Err(std::io::Error::new(
+            std::io::ErrorKind::InvalidData,
+            "invalid frame length",
+        ));
+    }
+    let mut buf = vec![0u8; len];
+    r.read_exact(&mut buf)?;
+    Ok(Some(buf))
+}
+
+fn write_frame<W: Write>(mut w: W, bytes: &[u8]) -> std::io::Result<()> {
+    if bytes.is_empty() || bytes.len() > MAX_FRAME_LEN {
+        return Err(std::io::Error::new(
+            std::io::ErrorKind::InvalidData,
+            "invalid frame length",
+        ));
+    }
+    let len = bytes.len() as u32;
+    w.write_all(&len.to_ne_bytes())?;
+    w.write_all(bytes)?;
+    w.flush()?;
+    Ok(())
+}
+
+fn error_response(id: String, code: &str) -> NativeResponse {
+    NativeResponse {
+        id,
+        ok: false,
+        result: None,
+        error: Some(NativeError {
+            code: code.to_string(),
+        }),
+    }
+}
+
+fn forward_to_app(req: NativeRequest) -> NativeResponse {
+    let app_dir = match std::env::current_exe()
+        .ok()
+        .and_then(|p| p.parent().map(|p| p.to_path_buf()))
+    {
+        Some(d) => d,
+        None => return error_response(req.id, "APP_DIR_UNAVAILABLE"),
+    };
+
+    let info = match load_ipc_info(&app_dir) {
+        Some(v) => v,
+        None => return error_response(req.id, "APP_NOT_RUNNING"),
+    };
+
+    let mut stream = match TcpStream::connect(("127.0.0.1", info.port)) {
+        Ok(s) => s,
+        Err(_) => return error_response(req.id, "APP_NOT_RUNNING"),
+    };
+
+    let bridge_req = serde_json::json!({
+        "id": req.id,
+        "token": info.token,
+        "type": req.kind,
+        "payload": req.payload,
+    });
+
+    let bytes = match serde_json::to_vec(&bridge_req) {
+        Ok(b) => b,
+        Err(_) => return error_response("unknown".to_string(), "SERIALIZE_FAILED"),
+    };
+
+    if write_frame(&mut stream, &bytes).is_err() {
+        return error_response("unknown".to_string(), "APP_NOT_RUNNING");
+    }
+    let frame = match read_frame(&mut stream) {
+        Ok(Some(b)) => b,
+        _ => return error_response("unknown".to_string(), "APP_NOT_RUNNING"),
+    };
+
+    match serde_json::from_slice::<NativeResponse>(&frame) {
+        Ok(resp) => resp,
+        Err(_) => error_response("unknown".to_string(), "APP_PROTOCOL_ERROR"),
+    }
+}
+
+fn main() {
+    let stdin = std::io::stdin();
+    let mut input = stdin.lock();
+    let stdout = std::io::stdout();
+    let mut output = stdout.lock();
+
+    while let Ok(Some(frame)) = read_frame(&mut input) {
+        let req: NativeRequest = match serde_json::from_slice(&frame) {
+            Ok(v) => v,
+            Err(_) => {
+                // Can't decode incoming request; ignore.
+                continue;
+            }
+        };
+
+        let resp = forward_to_app(req);
+        if let Ok(bytes) = serde_json::to_vec(&resp) {
+            let _ = write_frame(&mut output, &bytes);
+        }
+    }
+}
```

---

## PATCH (часть 2/4)

```diff
diff --git a/src-tauri/src/ipc/mod.rs b/src-tauri/src/ipc/mod.rs
new file mode 100644
index 0000000..1eb538b
--- /dev/null
+++ b/src-tauri/src/ipc/mod.rs
@@ -0,0 +1,2 @@
+pub mod registry;
+pub mod server;
diff --git a/src-tauri/src/ipc/registry.rs b/src-tauri/src/ipc/registry.rs
new file mode 100644
index 0000000..3bab63a
--- /dev/null
+++ b/src-tauri/src/ipc/registry.rs
@@ -0,0 +1,97 @@
+use serde::{Deserialize, Serialize};
+use std::path::{Path, PathBuf};
+
+use crate::data::fs::atomic_write::write_atomic;
+use crate::error::{ErrorCodeString, Result};
+
+const IPC_INFO_FILE: &str = "native-host.json";
+const IPC_INFO_SCHEMA_VERSION: u8 = 1;
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct NativeHostIpcInfo {
+    pub schema_version: u8,
+    pub port: u16,
+    pub token: String,
+    pub created_at_ms: u128,
+}
+
+fn primary_ipc_info_path(app_dir: &Path) -> PathBuf {
+    app_dir.join(IPC_INFO_FILE)
+}
+
+fn fallback_ipc_info_path() -> Option<PathBuf> {
+    std::env::var_os("LOCALAPPDATA")
+        .map(PathBuf::from)
+        .map(|dir| dir.join("Password Manager").join(IPC_INFO_FILE))
+}
+
+fn is_dir_writable(dir: &Path) -> bool {
+    if !dir.exists() {
+        return false;
+    }
+    let test_path = dir.join(format!(".pm-ipc-write-test-{}.tmp", uuid::Uuid::new_v4()));
+    if std::fs::write(&test_path, b"test").is_err() {
+        return false;
+    }
+    let _ = std::fs::remove_file(&test_path);
+    true
+}
+
+fn ipc_info_path_for_load(app_dir: &Path) -> PathBuf {
+    let primary = primary_ipc_info_path(app_dir);
+    if primary.exists() {
+        return primary;
+    }
+    if !is_dir_writable(app_dir) {
+        if let Some(fallback) = fallback_ipc_info_path() {
+            if fallback.exists() {
+                return fallback;
+            }
+        }
+    }
+    primary
+}
+
+fn ipc_info_path_for_write(app_dir: &Path) -> Result<PathBuf> {
+    if is_dir_writable(app_dir) {
+        return Ok(primary_ipc_info_path(app_dir));
+    }
+    let fallback = fallback_ipc_info_path().ok_or_else(|| ErrorCodeString::new("IPC_INFO_WRITE_FAILED"))?;
+    if let Some(parent) = fallback.parent() {
+        std::fs::create_dir_all(parent)
+            .map_err(|_| ErrorCodeString::new("IPC_INFO_WRITE_FAILED"))?;
+    }
+    Ok(fallback)
+}
+
+pub fn load_ipc_info(app_dir: &Path) -> Result<Option<NativeHostIpcInfo>> {
+    let path = ipc_info_path_for_load(app_dir);
+    if !path.exists() {
+        return Ok(None);
+    }
+    let content = std::fs::read_to_string(&path)
+        .map_err(|_| ErrorCodeString::new("IPC_INFO_READ_FAILED"))?;
+    let info: NativeHostIpcInfo = serde_json::from_str(&content)
+        .map_err(|_| ErrorCodeString::new("IPC_INFO_READ_FAILED"))?;
+    if info.schema_version != IPC_INFO_SCHEMA_VERSION {
+        return Err(ErrorCodeString::new("IPC_INFO_SCHEMA_MISMATCH"));
+    }
+    Ok(Some(info))
+}
+
+pub fn write_ipc_info(app_dir: &Path, info: &NativeHostIpcInfo) -> Result<PathBuf> {
+    let path = ipc_info_path_for_write(app_dir)?;
+    let serialized = serde_json::to_string_pretty(info)
+        .map_err(|_| ErrorCodeString::new("IPC_INFO_WRITE_FAILED"))?;
+    write_atomic(&path, serialized.as_bytes())
+        .map_err(|_| ErrorCodeString::new("IPC_INFO_WRITE_FAILED"))?;
+    Ok(path)
+}
+
+pub fn remove_ipc_info(app_dir: &Path) {
+    let primary = primary_ipc_info_path(app_dir);
+    let _ = std::fs::remove_file(primary);
+    if let Some(fallback) = fallback_ipc_info_path() {
+        let _ = std::fs::remove_file(fallback);
+    }
+}
```

---

## PATCH (часть 3/4)

```diff
diff --git a/src-tauri/src/ipc/server.rs b/src-tauri/src/ipc/server.rs
new file mode 100644
index 0000000..bd97a9e
--- /dev/null
+++ b/src-tauri/src/ipc/server.rs
@@ -0,0 +1,396 @@
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+use std::io::{Read, Write};
+use std::net::{TcpListener, TcpStream};
+use std::sync::Arc;
+use std::thread;
+use std::time::{SystemTime, UNIX_EPOCH};
+
+use uuid::Uuid;
+
+use crate::app_state::AppState;
+use crate::error::{ErrorCodeString, Result};
+use crate::services::{
+    datacards_service,
+    profiles_service,
+    security_service,
+};
+use crate::ipc::registry::{NativeHostIpcInfo, write_ipc_info, remove_ipc_info};
+
+const MAX_FRAME_LEN: usize = 1024 * 1024; // 1MB
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct BridgeRequest {
+    pub id: String,
+    pub token: String,
+    #[serde(rename = "type")]
+    pub kind: String,
+    pub payload: Value,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct BridgeError {
+    pub code: String,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct BridgeResponse {
+    pub id: String,
+    pub ok: bool,
+    pub result: Option<Value>,
+    pub error: Option<BridgeError>,
+}
+
+#[derive(Debug, Deserialize)]
+struct ProfileIdPayload {
+    #[serde(rename = "profileId")]
+    profile_id: String,
+}
+
+#[derive(Debug, Deserialize)]
+struct ListCredentialsPayload {
+    #[serde(rename = "profileId")]
+    profile_id: String,
+    origin: String,
+}
+
+#[derive(Debug, Deserialize)]
+struct GetCredentialPayload {
+    #[serde(rename = "profileId")]
+    profile_id: String,
+    origin: String,
+    #[serde(rename = "credentialId")]
+    credential_id: String,
+}
+
+#[derive(Debug, Serialize)]
+struct ListProfilesResult {
+    profiles: Vec<crate::types::ProfileMeta>,
+}
+
+#[derive(Debug, Serialize)]
+struct StatusResult {
+    locked: bool,
+}
+
+#[derive(Debug, Serialize)]
+struct CredentialListItem {
+    id: String,
+    username: String,
+    title: String,
+}
+
+#[derive(Debug, Serialize)]
+struct ListCredentialsResult {
+    items: Vec<CredentialListItem>,
+}
+
+#[derive(Debug, Serialize)]
+struct CredentialForFillResult {
+    username: String,
+    password: String,
+}
+
+fn now_ms() -> u128 {
+    SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .map(|d| d.as_millis())
+        .unwrap_or(0)
+}
+
+fn read_frame(mut stream: &TcpStream) -> Result<Option<Vec<u8>>> {
+    let mut len_bytes = [0u8; 4];
+    match stream.read_exact(&mut len_bytes) {
+        Ok(()) => {}
+        Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof => return Ok(None),
+        Err(_) => return Err(ErrorCodeString::new("IPC_STREAM_READ_FAILED")),
+    }
+
+    let len = u32::from_ne_bytes(len_bytes) as usize;
+    if len == 0 || len > MAX_FRAME_LEN {
+        return Err(ErrorCodeString::new("IPC_FRAME_INVALID"));
+    }
+    let mut buf = vec![0u8; len];
+    stream
+        .read_exact(&mut buf)
+        .map_err(|_| ErrorCodeString::new("IPC_STREAM_READ_FAILED"))?;
+    Ok(Some(buf))
+}
+
+fn write_frame(mut stream: &TcpStream, bytes: &[u8]) -> Result<()> {
+    if bytes.is_empty() || bytes.len() > MAX_FRAME_LEN {
+        return Err(ErrorCodeString::new("IPC_FRAME_INVALID"));
+    }
+    let len = bytes.len() as u32;
+    stream
+        .write_all(&len.to_ne_bytes())
+        .map_err(|_| ErrorCodeString::new("IPC_STREAM_WRITE_FAILED"))?;
+    stream
+        .write_all(bytes)
+        .map_err(|_| ErrorCodeString::new("IPC_STREAM_WRITE_FAILED"))?;
+    stream.flush().ok();
+    Ok(())
+}
+
+fn parse_origin(input: &str) -> Result<String> {
+    // Accept either a pure origin (https://example.com) or a full URL (https://example.com/path).
+    let trimmed = input.trim();
+    let scheme_split = trimmed
+        .find("://")
+        .ok_or_else(|| ErrorCodeString::new("INVALID_ORIGIN"))?;
+
+    let scheme = trimmed[..scheme_split].to_ascii_lowercase();
+    if scheme != "http" && scheme != "https" {
+        return Err(ErrorCodeString::new("INVALID_ORIGIN"));
+    }
+
+    let rest = &trimmed[(scheme_split + 3)..];
+    let host_port = rest
+        .split(|c| c == '/' || c == '?' || c == '#')
+        .next()
+        .unwrap_or("")
+        .trim();
+
+    if host_port.is_empty() {
+        return Err(ErrorCodeString::new("INVALID_ORIGIN"));
+    }
+
+    let (host, port_opt) = match host_port.rsplit_once(':') {
+        Some((h, p)) if !h.is_empty() && p.chars().all(|c| c.is_ascii_digit()) => {
+            let port: u16 = p.parse().map_err(|_| ErrorCodeString::new("INVALID_ORIGIN"))?;
+            (h, Some(port))
+        }
+        _ => (host_port, None),
+    };
+
+    let host = host.to_ascii_lowercase();
+    let default_port = if scheme == "http" { 80 } else { 443 };
+
+    match port_opt {
+        Some(port) if port != default_port => Ok(format!("{scheme}://{host}:{port}")),
+        _ => Ok(format!("{scheme}://{host}")),
+    }
+}
+
+fn datacard_origin(url: &str) -> Option<String> {
+    parse_origin(url).ok()
+}
+
+fn error_response(id: String, code: &str) -> BridgeResponse {
+    BridgeResponse {
+        id,
+        ok: false,
+        result: None,
+        error: Some(BridgeError {
+            code: code.to_string(),
+        }),
+    }
+}
+
+fn ok_response(id: String, value: Value) -> BridgeResponse {
+    BridgeResponse {
+        id,
+        ok: true,
+        result: Some(value),
+        error: None,
+    }
+}
+
+fn handle_request(state: &Arc<AppState>, shared_token: &str, req: BridgeRequest) -> BridgeResponse {
+    if req.token != shared_token {
+        return error_response(req.id, "UNAUTHORIZED");
+    }
+
+    let result: Result<Value> = (|| {
+        match req.kind.as_str() {
+            "ping" => Ok(serde_json::json!({"ok": true})),
+            "list_profiles" => {
+                let sp = state.get_storage_paths()?;
+                let list = profiles_service::list_profiles(&sp)?;
+                Ok(serde_json::to_value(ListProfilesResult {
+                    profiles: list.profiles,
+                })
+                .map_err(|_| ErrorCodeString::new("IPC_SERIALIZE_FAILED"))?)
+            }
+            "get_status" => {
+                let payload: ProfileIdPayload = serde_json::from_value(req.payload)
+                    .map_err(|_| ErrorCodeString::new("IPC_BAD_PAYLOAD"))?;
+
+                let active = state
+                    .active_profile
+                    .lock()
+                    .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
+                    .clone();
+
+                let locked = match active {
+                    Some(id) if id == payload.profile_id => !security_service::is_logged_in(state)?,
+                    _ => true,
+                };
+
+                Ok(serde_json::to_value(StatusResult { locked })
+                    .map_err(|_| ErrorCodeString::new("IPC_SERIALIZE_FAILED"))?)
+            }
+            "list_credentials" => {
+                let payload: ListCredentialsPayload = serde_json::from_value(req.payload)
+                    .map_err(|_| ErrorCodeString::new("IPC_BAD_PAYLOAD"))?;
+
+                let origin = parse_origin(&payload.origin)?;
+
+                let active = security_service::require_unlocked_active_profile(state)
+                    .map_err(|_| ErrorCodeString::new("LOCKED"))?;
+                if active.profile_id != payload.profile_id {
+                    return Err(ErrorCodeString::new("LOCKED"));
+                }
+
+                let rows = datacards_service::list_datacards_summary(state)?;
+
+                let mut items: Vec<CredentialListItem> = Vec::new();
+                for row in rows {
+                    let Some(url) = row.url.as_deref() else { continue };
+                    let Some(card_origin) = datacard_origin(url) else { continue };
+                    if card_origin != origin {
+                        continue;
+                    }
+                    let username = row
+                        .email
+                        .clone()
+                        .or(row.username.clone())
+                        .unwrap_or_default();
+                    if username.trim().is_empty() {
+                        continue;
+                    }
+                    items.push(CredentialListItem {
+                        id: row.id,
+                        username,
+                        title: row.title,
+                    });
+                }
+
+                Ok(serde_json::to_value(ListCredentialsResult { items })
+                    .map_err(|_| ErrorCodeString::new("IPC_SERIALIZE_FAILED"))?)
+            }
+            "get_credential_for_fill" => {
+                let payload: GetCredentialPayload = serde_json::from_value(req.payload)
+                    .map_err(|_| ErrorCodeString::new("IPC_BAD_PAYLOAD"))?;
+
+                let origin = parse_origin(&payload.origin)?;
+
+                let active = security_service::require_unlocked_active_profile(state)
+                    .map_err(|_| ErrorCodeString::new("LOCKED"))?;
+                if active.profile_id != payload.profile_id {
+                    return Err(ErrorCodeString::new("LOCKED"));
+                }
+
+                let card = datacards_service::get_datacard(payload.credential_id, state)?;
+                let Some(url) = card.url.as_deref() else {
+                    return Err(ErrorCodeString::new("CREDENTIAL_URL_MISSING"));
+                };
+                let Some(card_origin) = datacard_origin(url) else {
+                    return Err(ErrorCodeString::new("CREDENTIAL_URL_INVALID"));
+                };
+                if card_origin != origin {
+                    return Err(ErrorCodeString::new("ORIGIN_MISMATCH"));
+                }
+
+                let username = card
+                    .email
+                    .clone()
+                    .or(card.username.clone())
+                    .unwrap_or_default();
+                let password = card.password.clone().unwrap_or_default();
+
+                if username.trim().is_empty() {
+                    return Err(ErrorCodeString::new("USERNAME_MISSING"));
+                }
+                if password.trim().is_empty() {
+                    return Err(ErrorCodeString::new("PASSWORD_MISSING"));
+                }
+
+                Ok(serde_json::to_value(CredentialForFillResult { username, password })
+                    .map_err(|_| ErrorCodeString::new("IPC_SERIALIZE_FAILED"))?)
+            }
+            _ => Err(ErrorCodeString::new("IPC_UNKNOWN_REQUEST")),
+        }
+    })();
+
+    match result {
+        Ok(val) => ok_response(req.id, val),
+        Err(err) => error_response(req.id, &err.code),
+    }
+}
+
+fn handle_client(mut stream: TcpStream, state: Arc<AppState>, token: String) {
+    loop {
+        let frame = match read_frame(&stream) {
+            Ok(Some(bytes)) => bytes,
+            Ok(None) => break,
+            Err(_) => break,
+        };
+        let req: BridgeRequest = match serde_json::from_slice(&frame) {
+            Ok(v) => v,
+            Err(_) => {
+                // Can't decode, give up silently.
+                break;
+            }
+        };
+
+        let resp = handle_request(&state, &token, req);
+        if let Ok(bytes) = serde_json::to_vec(&resp) {
+            let _ = write_frame(&stream, &bytes);
+        } else {
+            break;
+        }
+    }
+}
+
+pub fn start_native_bridge(state: Arc<AppState>) -> Result<()> {
+    // Ensure we clean up any stale file from prior crashes.
+    {
+        let sp = state
+            .storage_paths
+            .lock()
+            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
+            .clone();
+        remove_ipc_info(sp.app_dir());
+    }
+
+    let listener = TcpListener::bind(("127.0.0.1", 0)).map_err(|_| ErrorCodeString::new("IPC_BIND_FAILED"))?;
+    let port = listener
+        .local_addr()
+        .map_err(|_| ErrorCodeString::new("IPC_BIND_FAILED"))?
+        .port();
+
+    let token = Uuid::new_v4().to_string();
+
+    let app_dir = {
+        let sp = state
+            .storage_paths
+            .lock()
+            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?
+            .clone();
+        sp.app_dir().to_path_buf()
+    };
+
+    let info = NativeHostIpcInfo {
+        schema_version: 1,
+        port,
+        token: token.clone(),
+        created_at_ms: now_ms(),
+    };
+    let _written_to = write_ipc_info(&app_dir, &info)?;
+
+    thread::spawn(move || {
+        for incoming in listener.incoming() {
+            match incoming {
+                Ok(stream) => {
+                    let st = state.clone();
+                    let t = token.clone();
+                    thread::spawn(move || handle_client(stream, st, t));
+                }
+                Err(_) => break,
+            }
+        }
+    });
+
+    Ok(())
+}
```

---

## PATCH (часть 4/4)

```diff
diff --git a/src-tauri/src/main.rs b/src-tauri/src/main.rs
index 76bf6b2..73082ed 100644
--- a/src-tauri/src/main.rs
+++ b/src-tauri/src/main.rs
@@ -31,6 +31,7 @@ mod data {
     }
 }
 mod error;
+mod ipc;
 mod services {
     pub mod attachments_service;
     pub mod backup_service;
@@ -53,6 +54,7 @@ use commands::{
     password_history::*, profiles::*, security::*, settings::*, workspace::*,
 };
 use data::storage_paths::StoragePaths;
+use data::workspaces::registry::{load_registry, resolve_workspace_path};
 use services::security_service;
 use tauri::{Manager, WindowEvent};
 use tauri_plugin_dialog::{DialogExt, MessageDialogKind};
@@ -87,7 +89,28 @@ fn main() {
                 }
             };
 
-            app.manage(Arc::new(AppState::new(storage_paths)));
+            let app_state = Arc::new(AppState::new(storage_paths.clone()));
+
+            // Best-effort auto-select active workspace (if any) so backend services are usable
+            // without a frontend "select workspace" call.
+            let app_dir = storage_paths.app_dir().to_path_buf();
+            if let Ok(registry) = load_registry(&app_dir) {
+                if let Some(active_id) = registry.active_workspace_id.as_deref() {
+                    if let Some(record) = registry.workspaces.iter().find(|r| r.id == active_id) {
+                        let root = resolve_workspace_path(&app_dir, record);
+                        // Marker file used by workspace validation.
+                        if root.join(".pm-workspace.json").exists() {
+                            let _ = app_state.set_workspace_root(root);
+                        }
+                    }
+                }
+            }
+
+            if let Err(err) = ipc::server::start_native_bridge(app_state.clone()) {
+                log::error!("[IPC] failed to start native bridge: {err:?}");
+            }
+
+            app.manage(app_state);
             Ok(())
         })
         .invoke_handler(tauri::generate_handler![
```

