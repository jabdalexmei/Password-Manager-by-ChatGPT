diff --git a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
index 8cead45..e0c1c4b 100644
--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -289,19 +289,18 @@ pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) ->
     if !vault_path.exists() {
         return Err(ErrorCodeString::new("VAULT_CORRUPTED"));
     }
 
-    // Serialize passwordless sqlite file to bytes.
-    let conn = rusqlite::Connection::open(&vault_path)
-        .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
-    migrations::migrate_to_latest(&conn)?;
-    let serialized = conn
-        .serialize(DatabaseName::Main)
-        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
-    drop(conn);
-
-    let bytes = serialized.to_vec();
+    // Serialize passwordless sqlite file to bytes.
+    // NOTE: `serialize()` returns `Data<'_>` which may borrow `conn` (Shared variant),
+    // so we must materialize bytes while `conn` is still alive.
+    let bytes: Vec<u8> = {
+        let conn = rusqlite::Connection::open(&vault_path)
+            .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
+        migrations::migrate_to_latest(&conn)?;
+        let serialized = conn
+            .serialize(DatabaseName::Main)
+            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+        serialized.to_vec()
+    };
 
     // Create new salt + key.
     let salt = kdf::generate_kdf_salt();
     let salt_path = kdf_salt_path(&storage_paths, id)?;
     write_atomic(&salt_path, &salt).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
