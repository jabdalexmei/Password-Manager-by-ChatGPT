diff --git a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
index 0b8d9ef..d3f6d42 100644
--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -331,21 +331,45 @@ pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) ->
 
         // Snapshot the file DB into memory using SQLite online backup, then serialize the in-memory DB.
         let bytes: Vec<u8> = {
             // Open read-only to avoid taking write locks / WAL side-effects during snapshot.
             let src = rusqlite::Connection::open_with_flags(
                 &vault_path,
                 OpenFlags::SQLITE_OPEN_READ_ONLY,
             )
-                .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
-            src.busy_timeout(Duration::from_secs(15))
-                .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
+            .map_err(|e| {
+                log::error!(
+                    "[SECURITY][set_profile_password] profile_id={} step=open_src vault={:?} err={}",
+                    id,
+                    vault_path,
+                    format_rusqlite_error(&e)
+                );
+                ErrorCodeString::new("DB_OPEN_FAILED")
+            })?;
+            src.busy_timeout(Duration::from_secs(15)).map_err(|e| {
+                log::error!(
+                    "[SECURITY][set_profile_password] profile_id={} step=busy_timeout_src vault={:?} err={}",
+                    id,
+                    vault_path,
+                    format_rusqlite_error(&e)
+                );
+                ErrorCodeString::new("DB_OPEN_FAILED")
+            })?;
 
             let mut mem = rusqlite::Connection::open_in_memory()
-                .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
+            .map_err(|e| {
+                log::error!(
+                    "[SECURITY][set_profile_password] profile_id={} step=open_mem err={}",
+                    id,
+                    format_rusqlite_error(&e)
+                );
+                ErrorCodeString::new("DB_OPEN_FAILED")
+            })?;
 
             {
                 let backup = Backup::new(&src, &mut mem).map_err(|e| {
                     log::error!(
                         "[SECURITY][set_profile_password] profile_id={} step=backup_init vault={:?} err={}",
@@ -363,16 +387,41 @@ pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) ->
             serialized.to_vec()
         };
 
         // Validate we can open this snapshot in-memory BEFORE writing any encrypted files.
         let mut mem_conn = rusqlite::Connection::open_in_memory()
-            .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
+        .map_err(|e| {
+            log::error!(
+                "[SECURITY][set_profile_password] profile_id={} step=open_mem_validate err={}",
+                id,
+                format_rusqlite_error(&e)
+            );
+            ErrorCodeString::new("DB_OPEN_FAILED")
+        })?;
         let owned = owned_data_from_bytes(bytes.clone())?;
         mem_conn
             .deserialize(DatabaseName::Main, owned, false)
-            .map_err(|_| ErrorCodeString::new("VAULT_CORRUPTED"))?;
+        .map_err(|e| {
+            log::error!(
+                "[SECURITY][set_profile_password] profile_id={} step=deserialize_mem err={}",
+                id,
+                format_rusqlite_error(&e)
+            );
+            ErrorCodeString::new("VAULT_CORRUPTED")
+        })?;
         migrations::migrate_to_latest(&mem_conn)?;
         migrations::validate_core_schema(&mem_conn)
             .map_err(|_| ErrorCodeString::new("VAULT_CORRUPTED"))?;
diff --git a/src-tauri/src/data/sqlite/migrations.rs b/src-tauri/src/data/sqlite/migrations.rs
index 4e79d0a..f0f1d5e 100644
--- a/src-tauri/src/data/sqlite/migrations.rs
+++ b/src-tauri/src/data/sqlite/migrations.rs
@@ -1,5 +1,6 @@
 use rusqlite::Connection;
 use rusqlite::OptionalExtension;
+use rusqlite::Error as RusqliteError;
 
 use crate::error::{ErrorCodeString, Result};
 
 const CURRENT_SCHEMA_VERSION: i32 = 8;
 
+fn log_sqlite_err(ctx: &str, err: &RusqliteError) {
+    match err {
+        RusqliteError::SqliteFailure(e, msg) => {
+            log::error!(
+                "[DB][sqlite_error] ctx={} code={:?} extended_code={} msg={}",
+                ctx,
+                e.code,
+                e.extended_code,
+                msg.as_deref().unwrap_or("")
+            );
+        }
+        other => {
+            log::error!("[DB][sqlite_error] ctx={} err={other:?}", ctx);
+        }
+    }
+}
+
 fn ensure_ui_preferences_table(conn: &Connection) -> Result<()> {
     // Dev-mode friendly: create idempotently so existing schema DBs also get it.
     conn.execute_batch(
@@ -12,7 +27,10 @@ CREATE TABLE IF NOT EXISTS ui_preferences (
 "#,
     )
-    .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+    .map_err(|e| {
+        log_sqlite_err("ensure_ui_preferences_table.execute_batch", &e);
+        ErrorCodeString::new("DB_MIGRATION_FAILED")
+    })?;
     Ok(())
 }
 
 fn has_table(conn: &Connection, name: &str) -> Result<bool> {
     let sql = "SELECT 1 FROM sqlite_master WHERE type='table' AND name=?1 LIMIT 1";
     let exists: Option<i32> = conn
         .query_row(sql, [name], |row| row.get(0))
         .optional()
-        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+        .map_err(|e| {
+            log_sqlite_err(&format!("has_table.query_row name={name} sql={sql}"), &e);
+            ErrorCodeString::new("DB_QUERY_FAILED")
+        })?;
     Ok(exists.is_some())
 }
 
 fn has_column(conn: &Connection, table: &str, column: &str) -> Result<bool> {
     let sql = format!("PRAGMA table_info({table});");
     let mut stmt = conn
         .prepare(&sql)
-        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+        .map_err(|e| {
+            log_sqlite_err(&format!("has_column.prepare table={table} column={column} sql={sql}"), &e);
+            ErrorCodeString::new("DB_QUERY_FAILED")
+        })?;
 
     let mut rows = stmt
         .query([])
-        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+        .map_err(|e| {
+            log_sqlite_err(&format!("has_column.query table={table} column={column} sql={sql}"), &e);
+            ErrorCodeString::new("DB_QUERY_FAILED")
+        })?;
 
     while let Some(row) = rows
         .next()
-        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?
+        .map_err(|e| {
+            log_sqlite_err(&format!("has_column.next table={table} column={column} sql={sql}"), &e);
+            ErrorCodeString::new("DB_QUERY_FAILED")
+        })?
     {
-        let name: String = row.get(1).map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+        let name: String = row.get(1).map_err(|e| {
+            log_sqlite_err(&format!("has_column.row_get table={table} column={column} sql={sql}"), &e);
+            ErrorCodeString::new("DB_QUERY_FAILED")
+        })?;
         if name == column {
             return Ok(true);
         }
     }
     Ok(false)
 }
@@ -247,13 +305,20 @@ pub fn migrate_to_latest(conn: &Connection) -> Result<()> {
     conn.execute_batch("PRAGMA foreign_keys = ON;")
-        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+    .map_err(|e| {
+        log_sqlite_err("migrate_to_latest.execute_batch PRAGMA foreign_keys=ON", &e);
+        ErrorCodeString::new("DB_QUERY_FAILED")
+    })?;
 
     let version: i32 = conn
         .query_row("PRAGMA user_version;", [], |row| row.get(0))
-        .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+    .map_err(|e| {
+        log_sqlite_err("migrate_to_latest.query_row PRAGMA user_version", &e);
+        ErrorCodeString::new("DB_QUERY_FAILED")
+    })?;
 
     log::info!(
         "[DB][migrate] user_version={version}, current={CURRENT_SCHEMA_VERSION}"
     );
