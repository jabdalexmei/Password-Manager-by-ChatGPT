--- a/src-tauri/src/services/backup_service.rs
+++ b/src-tauri/src/services/backup_service.rs
@@ -241,86 +241,6 @@
     }))
 }
 
-fn copy_dir_recursive(src: &Path, dst: &Path) -> std::io::Result<()> {
-    // We can't rely on rename() between temp_dir and profile_root: temp_dir may live on another
-    // filesystem/mount (EXDEV). Copy into a staging dir under profile_root, then swap in place.
-    fs::create_dir_all(dst)?;
-
-    for entry in WalkDir::new(src) {
-        let entry = entry?;
-        let p = entry.path();
-        let rel = match p.strip_prefix(src) {
-            Ok(r) => r,
-            Err(_) => continue,
-        };
-
-        // Skip the root itself.
-        if rel.as_os_str().is_empty() {
-            continue;
-        }
-
-        let target = dst.join(rel);
-        if entry.file_type().is_dir() {
-            fs::create_dir_all(&target)?;
-            continue;
-        }
-
-        if entry.file_type().is_file() {
-            if let Some(parent) = target.parent() {
-                fs::create_dir_all(parent)?;
-            }
-            fs::copy(p, &target)?;
-            // Best-effort: ensure bytes reach disk before we swap directories.
-            if let Ok(f) = fs::File::open(&target) {
-                let _ = f.sync_all();
-            }
-        }
-    }
-
-    best_effort_fsync_dir(dst);
-    Ok(())
-}
-
-fn copy_dir_recursive(src: &Path, dst: &Path) -> std::io::Result<()> {
-    // We can't rely on rename() between temp_dir and profile_root: temp_dir may live on another
-    // filesystem/mount (EXDEV). Copy into a staging dir under profile_root, then swap in place.
-    fs::create_dir_all(dst)?;
-
-    for entry in WalkDir::new(src) {
-        let entry = entry?;
-        let p = entry.path();
-        let rel = match p.strip_prefix(src) {
-            Ok(r) => r,
-            Err(_) => continue,
-        };
-
-        // Skip the root itself.
-        if rel.as_os_str().is_empty() {
-            continue;
-        }
-
-        let target = dst.join(rel);
-        if entry.file_type().is_dir() {
-            fs::create_dir_all(&target)?;
-            continue;
-        }
-
-        if entry.file_type().is_file() {
-            if let Some(parent) = target.parent() {
-                fs::create_dir_all(parent)?;
-            }
-            fs::copy(p, &target)?;
-            // Best-effort: ensure bytes reach disk before we swap directories.
-            if let Ok(f) = fs::File::open(&target) {
-                let _ = f.sync_all();
-            }
-        }
-    }
-
-    best_effort_fsync_dir(dst);
-    Ok(())
-}
-
 fn ensure_backup_guard(state: &Arc<AppState>) -> Result<std::sync::MutexGuard<'_, ()>> {
     state
         .backup_guard
@@ -905,39 +825,26 @@
     for entry in &manifest.files {
         let rel_path = Path::new(&entry.path);
         if !validate_zip_entry_rel_path_windows(rel_path) {
-    let mut attachments_tmp_path: Option<PathBuf> = None;
-            // Prefer rename (fast) when temp_dir is on the same filesystem. Fall back to copy when it isn't.
-            match rename_with_retry(&extracted_attachments, &attachments_path) {
-                Ok(()) => {
-                    restored_attachments_created = true;
-                }
-                Err(e) if e.kind() == std::io::ErrorKind::CrossDeviceLink => {
-                    let staging =
-                        profile_root.join(format!("attachments.restore.{}", Uuid::new_v4()));
-                    attachments_tmp_path = Some(staging.clone());
-                    copy_dir_recursive(&extracted_attachments, &staging)
-                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-                    rename_with_retry(&staging, &attachments_path)
-                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-                    restored_attachments_created = true;
-                }
-                Err(_) => {
-                    return Err(ErrorCodeString::new("BACKUP_RESTORE_FAILED"));
-                }
-            }
+            return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+        }
+
+        let mut zipped_file = archive
             .by_name(&entry.path)
             .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+
         let target_path = temp_dir.path().join(rel_path);
         if let Some(parent) = target_path.parent() {
             fs::create_dir_all(parent)
                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
         }
+
         let file = fs::File::create(&target_path)
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
         let mut writer = BufWriter::new(file);
         let mut buffer = [0u8; 64 * 1024];
         let mut hasher = Sha256::new();
         let mut bytes_written = 0i64;
+
         loop {
             let read = zipped_file
                 .read(&mut buffer)
@@ -948,17 +855,21 @@
             writer
                 .write_all(&buffer[..read])
                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+
             bytes_written = bytes_written
                 .checked_add(read as i64)
                 .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
             total_written = total_written
                 .checked_add(read as i64)
                 .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
+
             if bytes_written > MAX_RESTORE_ENTRY_BYTES || total_written > MAX_RESTORE_TOTAL_BYTES {
                 return Err(ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"));
             }
+
             hasher.update(&buffer[..read]);
         }
+
         writer
             .flush()
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
@@ -966,6 +877,7 @@
             .get_ref()
             .sync_all()
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+
         let sha256 = hex::encode(hasher.finalize());
         if sha256 != entry.sha256 || bytes_written != entry.bytes {
             return Err(ErrorCodeString::new("BACKUP_INTEGRITY_FAILED"));
@@ -984,12 +896,14 @@
 
     let vault_backup_path = vault_path.with_extension(format!("old.{}", Uuid::new_v4()));
     let attachments_backup_path = profile_root.join(format!("attachments.old.{}", Uuid::new_v4()));
+
     let mut moved_vault = false;
     let mut vault_replaced = false;
     let mut vault_tmp_path: Option<PathBuf> = None;
-    let mut attachments_tmp_path: Option<PathBuf> = None;
+
     let mut moved_attachments = false;
     let mut restored_attachments_created = false;
+
     let restore_result: Result<()> = (|| {
         if vault_path.exists() {
             rename_with_retry(&vault_path, &vault_backup_path)
@@ -1001,46 +915,26 @@
         vault_tmp_path = Some(tmp.clone());
         fs::copy(&extracted_vault, &tmp)
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-        // Ensure the copied vault bytes reach disk before we swap it into place.
         fs::File::open(&tmp)
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?
             .sync_all()
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+
         rename_with_retry(&tmp, &vault_path)
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
         vault_replaced = true;
 
-        if let Some(tmp) = attachments_tmp_path.as_ref() {
-            if tmp.exists() {
-                let _ = fs::remove_dir_all(tmp);
-            }
-        }
-                let _ = rename_with_retry(&vault_backup_path, &vault_path);
+        if attachments_path.exists() {
             rename_with_retry(&attachments_path, &attachments_backup_path)
                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
             moved_attachments = true;
         }
 
         if extracted_attachments.exists() {
-            // Prefer rename (fast) when temp_dir is on the same filesystem. Fall back to copy when it isn't.
-            match rename_with_retry(&extracted_attachments, &attachments_path) {
-                Ok(()) => {
-                    restored_attachments_created = true;
-                }
-                Err(e) if e.kind() == std::io::ErrorKind::CrossDeviceLink => {
-                    let staging =
-                        profile_root.join(format!("attachments.restore.{}", Uuid::new_v4()));
-                    attachments_tmp_path = Some(staging.clone());
-                    copy_dir_recursive(&extracted_attachments, &staging)
-                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-                    rename_with_retry(&staging, &attachments_path)
-                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-                    restored_attachments_created = true;
-                }
-                Err(_) => {
-                    return Err(ErrorCodeString::new("BACKUP_RESTORE_FAILED"));
-                }
-            }
+            rename_with_retry(&extracted_attachments, &attachments_path)
+                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+            restored_attachments_created = true;
+
         } else {
             if !attachments_path.exists() {
                 fs::create_dir_all(&attachments_path)
@@ -1054,8 +948,6 @@
             if extracted_file.exists() {
                 let target = profile_root.join(file_name);
 
-                // Copy into the profile directory first, so we can swap atomically even if temp_dir
-                // lives on a different filesystem/mount.
                 let tmp = profile_root.join(format!("{}.restore.{}", file_name, Uuid::new_v4()));
                 fs::copy(&extracted_file, &tmp)
                     .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
@@ -1096,13 +988,7 @@
                 let _ = fs::remove_file(tmp);
             }
         }
-        if let Some(tmp) = attachments_tmp_path.as_ref() {
-            if tmp.exists() {
-                let _ = fs::remove_dir_all(tmp);
-            }
-        }
-        // Roll back to the pre-restore state as safely as we can.
-        // IMPORTANT: never delete the last known-good vault before we have restored it.
+
         if moved_vault && vault_backup_path.exists() {
             #[cfg(windows)]
             {
@@ -1114,20 +1000,18 @@
                 let _ = rename_with_retry(&vault_backup_path, &vault_path);
             }
         } else if !moved_vault && vault_replaced && vault_path.exists() {
-            // No prior vault existed; remove the partially restored file.
             let _ = fs::remove_file(&vault_path);
         }
+
         if moved_attachments && attachments_backup_path.exists() {
             if attachments_path.exists() {
                 let _ = fs::remove_dir_all(&attachments_path);
             }
             let _ = rename_with_retry(&attachments_backup_path, &attachments_path);
-        } else if !attachments_existed_before
-            && restored_attachments_created
-            && attachments_path.exists()
-        {
+        } else if !attachments_existed_before && restored_attachments_created && attachments_path.exists() {
             let _ = fs::remove_dir_all(&attachments_path);
         }
+
         return Err(ErrorCodeString::new("BACKUP_RESTORE_FAILED"));
     }
 
