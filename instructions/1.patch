

## 1) `registry.rs`: убираем mutable borrow перед `save_registry`

```diff
diff --git a/src-tauri/src/data/profiles/registry.rs b/src-tauri/src/data/profiles/registry.rs
index c3d7d9a..e60c45a 100644
--- a/src-tauri/src/data/profiles/registry.rs
+++ b/src-tauri/src/data/profiles/registry.rs
@@ -252,28 +252,30 @@ pub fn get_profile(sp: &StoragePaths, id: &str) -> Result<Option<ProfileRecord>>
-    let mut registry = load_registry(sp)?;
-    let mut dirty = false;
-
-    if let Some(rec) = registry.profiles.iter_mut().find(|p| p.id == id) {
-        let inferred = infer_has_password(sp, &rec.id, rec.has_password);
-        if inferred != rec.has_password {
-            rec.has_password = inferred;
-            dirty = true;
-        }
-
-        if dirty {
-            let _ = save_registry(sp, &registry);
-        }
-
-        return Ok(Some(rec.clone()));
-    }
-
-    Ok(None)
+    let mut registry = load_registry(sp)?;
+    let idx = match registry.profiles.iter().position(|p| p.id == id) {
+        Some(i) => i,
+        None => return Ok(None),
+    };
+
+    let mut dirty = false;
+    let inferred = infer_has_password(sp, &registry.profiles[idx].id, registry.profiles[idx].has_password);
+    if inferred != registry.profiles[idx].has_password {
+        registry.profiles[idx].has_password = inferred;
+        dirty = true;
+    }
+
+    let out = registry.profiles[idx].clone();
+
+    if dirty {
+        let _ = save_registry(sp, &registry);
+    }
+
+    Ok(Some(out))
 }
```

---

## 2) `security_service.rs`: дропаем `Backup` до `serialize()`

```diff
diff --git a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
index 4c6cbd9..1e9c6db 100644
--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -294,18 +294,22 @@ pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) -> Result<ProfileMeta> {
         let src_conn = rusqlite::Connection::open(&vault_path)
             .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
         migrations::migrate_to_latest(&src_conn)?;
 
         let mut mem_conn = rusqlite::Connection::open_in_memory()
             .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
 
-        let backup = Backup::new(&src_conn, &mut mem_conn)
-            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
-        backup
-            .run_to_completion(5, std::time::Duration::from_millis(250), None)
-            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+        {
+            let mut backup = Backup::new(&src_conn, &mut mem_conn)
+                .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+            backup
+                .run_to_completion(5, std::time::Duration::from_millis(250), None)
+                .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+            // `backup` dropped here, releasing the mutable borrow of `mem_conn`.
+        }
 
         let serialized = mem_conn
             .serialize(DatabaseName::Main)
             .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
         serialized.to_vec()
     };
