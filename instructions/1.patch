diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/capabilities/default.json b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/capabilities/default.json
index 3e11a8b..4c2b5a9 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/capabilities/default.json
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/capabilities/default.json
@@ -1,12 +1,13 @@
 {
   "$schema": "../gen/schemas/desktop-schema.json",
   "identifier": "default",
   "description": "Default permissions for main window.",
   "windows": [
     "main"
   ],
   "permissions": [
-    "core:default"
+    "core:default",
+    "app-default"
   ]
 }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/permissions/app-default.toml b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/permissions/app-default.toml
new file mode 100644
index 0000000..d0f5f0c
--- /dev/null
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/permissions/app-default.toml
@@ -0,0 +1,90 @@
+[[permission]]
+identifier = "app-default"
+description = """
+Allowlist for app-defined commands used by the UI.
+This reduces accidental exposure if new commands are added later.
+"""
+
+commands.allow = [
+  "profiles_list",
+  "profile_create",
+  "profile_delete",
+  "get_active_profile",
+  "set_active_profile",
+  "login_vault",
+  "lock_vault",
+  "is_logged_in",
+  "health_check",
+
+  "list_attachments",
+  "attachments_pick_files",
+  "attachments_discard_pick",
+  "add_attachments_from_pick",
+  "add_attachments_via_dialog",
+  "remove_attachment",
+  "purge_attachment",
+  "get_attachment_bytes_base64",
+  "get_attachment_preview",
+  "save_attachment_via_dialog",
+
+  "backup_create",
+  "backup_create_via_dialog",
+  "backup_pick_file",
+  "backup_discard_pick",
+  "backup_restore_workflow_from_pick",
+  "backup_list",
+  "backup_create_if_due_auto",
+
+  "list_folders",
+  "create_folder",
+  "rename_folder",
+  "move_folder",
+  "delete_folder_only",
+  "delete_folder_and_cards",
+
+  "list_bank_cards_summary_command",
+  "list_deleted_bank_cards_summary_command",
+  "get_bank_card",
+  "create_bank_card",
+  "update_bank_card",
+  "set_bank_card_favorite",
+  "delete_bank_card",
+  "restore_bank_card",
+  "purge_bank_card",
+  "restore_all_deleted_bank_cards",
+  "purge_all_deleted_bank_cards",
+
+  "list_datacards_summary_command",
+  "list_deleted_datacards_summary_command",
+  "get_datacard",
+  "create_datacard",
+  "update_datacard",
+  "set_datacard_favorite",
+  "move_datacard_to_folder",
+  "delete_datacard",
+  "restore_datacard",
+  "purge_datacard",
+  "restore_all_deleted_datacards",
+  "purge_all_deleted_datacards",
+  "clear_datacard_password_history",
+
+  "get_settings",
+  "update_settings",
+
+  "workspace_list",
+  "workspace_select",
+  "workspace_create_via_dialog",
+  "workspace_create_default",
+  "workspace_remove",
+  "workspace_open_in_explorer",
+
+  "clipboard_clear_all",
+]
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/app_state.rs b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/app_state.rs
index 40fe8ab..a43b8a2 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/app_state.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/app_state.rs
@@ -24,6 +24,14 @@ pub struct PendingAttachmentPick {
     pub files: Vec<PendingPickedFile>,
 }
 
+#[derive(Clone)]
+pub struct PendingBackupPick {
+    pub created_at_ms: u128,
+    pub path: PathBuf,
+    pub file_name: String,
+    pub byte_size: u64,
+}
+
 pub struct AppState {
@@ -40,6 +48,7 @@ pub struct AppState {
     // One-time picks created by backend-native dialogs.
     // Frontend only receives opaque ids (token + file ids), never filesystem paths.
     pub pending_attachment_picks: Mutex<HashMap<String, PendingAttachmentPick>>,
+    pub pending_backup_picks: Mutex<HashMap<String, PendingBackupPick>>,
 }
 
 impl AppState {
@@ -56,6 +65,7 @@ impl AppState {
             backup_guard: Mutex::new(()),
 
             pending_attachment_picks: Mutex::new(HashMap::new()),
+            pending_backup_picks: Mutex::new(HashMap::new()),
         }
     }
 }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/types.rs b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/types.rs
index 7fa0bd4..4fb6a48 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/types.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/types.rs
@@ -1,6 +1,8 @@
 use serde::{Deserialize, Serialize};
 
+use crate::services::backup_service::BackupInspectResult;
+
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct WorkspaceItem {
@@ -44,6 +46,14 @@ pub struct AttachmentPickPayload {
     pub token: String,
     pub files: Vec<AttachmentPickFile>,
 }
 
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct BackupPickPayload {
+    pub token: String,
+    pub file_name: String,
+    pub byte_size: i64,
+    pub inspect: BackupInspectResult,
+}
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/commands/workspace.rs b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/commands/workspace.rs
index 6e1b7c4..c49b3f1 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/commands/workspace.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/commands/workspace.rs
@@ -4,7 +4,9 @@ use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
+use tauri::AppHandle;
 use tauri::State;
+use tauri_plugin_dialog::{DialogExt, FilePath};
 use uuid::Uuid;
 
 use crate::app_state::AppState;
@@ -24,6 +26,14 @@ const WORKSPACE_MARKER_FILE: &str = ".pm-workspace.json";
 
 fn app_dir_from_state(state: &Arc<AppState>) -> Result<PathBuf> {
@@ -169,6 +179,30 @@ fn workspace_status(root: &Path) -> Result<(bool, bool)> {
     Ok((true, is_dir_writable(root)))
 }
 
+fn file_path_to_pathbuf(fp: FilePath) -> Result<PathBuf> {
+    match fp {
+        FilePath::Path(p) => Ok(p),
+        _ => Err(ErrorCodeString::new("DIALOG_UNSUPPORTED_FILE_URI")),
+    }
+}
+
+fn workspace_create_impl(app_state: Arc<AppState>, root: PathBuf) -> Result<bool> {
+    let app_dir = app_dir_from_state(&app_state)?;
+    ensure_workspace_root(&root)?;
+
+    let mut registry = load_registry(&app_dir)?;
+    let record = upsert_workspace(&mut registry.workspaces, &app_dir, &root);
+    app_state.logout_and_cleanup()?;
+    app_state.set_workspace_root(root)?;
+    registry.active_workspace_id = Some(record.id.clone());
+    if let Err(err) = save_registry(&app_dir, &registry) {
+        let _ = app_state.clear_workspace_root();
+        return Err(err);
+    }
+    Ok(true)
+}
+
 #[tauri::command]
 pub async fn workspace_list(state: State<'_, Arc<AppState>>) -> Result<Vec<WorkspaceItem>> {
@@ -236,29 +270,31 @@ pub async fn workspace_select(
 }
 
 #[tauri::command]
 pub async fn workspace_create(path: String, state: State<'_, Arc<AppState>>) -> Result<bool> {
-    let app_state = state.inner().clone();
-    tauri::async_runtime::spawn_blocking(move || {
-        let app_dir = app_dir_from_state(&app_state)?;
-        let root = PathBuf::from(path);
-        ensure_workspace_root(&root)?;
-
-        let mut registry = load_registry(&app_dir)?;
-        let record = upsert_workspace(&mut registry.workspaces, &app_dir, &root);
-        app_state.logout_and_cleanup()?;
-        app_state.set_workspace_root(root)?;
-        registry.active_workspace_id = Some(record.id.clone());
-        if let Err(err) = save_registry(&app_dir, &registry) {
-            let _ = app_state.clear_workspace_root();
-            return Err(err);
-        }
-        Ok(true)
-    })
-    .await
-    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+    let _ = path;
+    let _ = state;
+    Err(ErrorCodeString::new("WORKSPACE_CREATE_PATH_FORBIDDEN"))
+}
+
+#[tauri::command]
+pub async fn workspace_create_via_dialog(app: AppHandle, state: State<'_, Arc<AppState>>) -> Result<bool> {
+    let app_state = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || {
+        let selection = app.dialog().file().blocking_pick_folder();
+        let Some(fp) = selection else {
+            return Ok(false);
+        };
+        let root = file_path_to_pathbuf(fp)?;
+        workspace_create_impl(app_state, root)
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
 
 #[tauri::command]
 pub async fn workspace_create_default(state: State<'_, Arc<AppState>>) -> Result<bool> {
@@ -266,23 +302,9 @@ pub async fn workspace_create_default(state: State<'_, Arc<AppState>>) -> Result<bool> {
     tauri::async_runtime::spawn_blocking(move || {
         let app_dir = app_dir_from_state(&app_state)?;
         let root = app_dir.join("Password Manager Vault");
-        ensure_workspace_root(&root)?;
-
-        let mut registry = load_registry(&app_dir)?;
-        let record = upsert_workspace(&mut registry.workspaces, &app_dir, &root);
-        app_state.logout_and_cleanup()?;
-        app_state.set_workspace_root(root)?;
-        registry.active_workspace_id = Some(record.id.clone());
-        if let Err(err) = save_registry(&app_dir, &registry) {
-            let _ = app_state.clear_workspace_root();
-            return Err(err);
-        }
-        Ok(true)
+        workspace_create_impl(app_state, root)
     })
     .await
     .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/commands/backup.rs b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/commands/backup.rs
index 41a1f5c..4a0a0f5 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/commands/backup.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/commands/backup.rs
@@ -1,11 +1,24 @@
+use std::path::PathBuf;
 use std::sync::Arc;
+use std::time::{SystemTime, UNIX_EPOCH};
 
-use tauri::State;
+use tauri::{AppHandle, State};
+use tauri_plugin_dialog::{DialogExt, FilePath};
+use uuid::Uuid;
 
 use crate::app_state::AppState;
 use crate::error::{ErrorCodeString, Result};
 use crate::services::backup_service::{
     backup_create as backup_create_service, backup_create_if_due_auto as backup_create_if_due_auto_service,
     backup_inspect as backup_inspect_service, backup_list as backup_list_service,
     backup_restore as backup_restore_service, backup_restore_workflow as backup_restore_workflow_service,
     BackupInspectResult, BackupListItem,
 };
+use crate::types::BackupPickPayload;
+
+fn now_ms() -> Result<u128> {
+    SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .map(|d| d.as_millis())
+        .map_err(|_| ErrorCodeString::new("TIME_UNAVAILABLE"))
+}
+
+fn file_path_to_pathbuf(fp: FilePath) -> Result<PathBuf> {
+    match fp {
+        FilePath::Path(p) => Ok(p),
+        _ => Err(ErrorCodeString::new("DIALOG_UNSUPPORTED_FILE_URI")),
+    }
+}
+
+fn cleanup_stale_backup_picks(state: &AppState, now: u128) -> Result<()> {
+    const MAX_AGE_MS: u128 = 10 * 60 * 1000;
+    const MAX_ENTRIES: usize = 16;
+    let mut map = state
+        .pending_backup_picks
+        .lock()
+        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+    map.retain(|_, v| now.saturating_sub(v.created_at_ms) <= MAX_AGE_MS);
+    while map.len() > MAX_ENTRIES {
+        if let Some(key) = map.keys().next().cloned() {
+            map.remove(&key);
+        } else {
+            break;
+        }
+    }
+    Ok(())
+}
 
 #[tauri::command]
 pub async fn backup_create(
     destination_path: Option<String>,
     use_default_path: bool,
     state: State<'_, Arc<AppState>>,
 ) -> Result<String> {
+    // Do not accept filesystem paths from the frontend.
+    if destination_path.is_some() {
+        return Err(ErrorCodeString::new("BACKUP_DESTINATION_PATH_FORBIDDEN"));
+    }
     let app = state.inner().clone();
     tauri::async_runtime::spawn_blocking(move || {
         backup_create_service(&app, destination_path, use_default_path)
     })
     .await
     .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
 
+#[tauri::command]
+pub async fn backup_create_via_dialog(
+    app: AppHandle,
+    suggested_file_name: Option<String>,
+    state: State<'_, Arc<AppState>>,
+) -> Result<Option<String>> {
+    let st = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || {
+        let mut builder = app.dialog().file();
+        if let Some(name) = suggested_file_name {
+            builder = builder.set_file_name(name);
+        }
+        let selection = builder.blocking_save_file();
+        let Some(fp) = selection else {
+            return Ok(None);
+        };
+        let path = file_path_to_pathbuf(fp)?;
+        let destination = path.to_string_lossy().to_string();
+        let created = backup_create_service(&st, Some(destination), false)?;
+        Ok(Some(created))
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
 #[tauri::command]
 pub async fn backup_list(state: State<'_, Arc<AppState>>) -> Result<Vec<BackupListItem>> {
@@ -25,28 +138,83 @@ pub async fn backup_list(state: State<'_, Arc<AppState>>) -> Result<Vec<BackupListItem>> {
 }
 
 #[tauri::command]
 pub async fn backup_restore(backup_path: String, state: State<'_, Arc<AppState>>) -> Result<bool> {
-    let app = state.inner().clone();
-    tauri::async_runtime::spawn_blocking(move || backup_restore_service(&app, backup_path))
-        .await
-        .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+    let _ = backup_path;
+    let _ = state;
+    Err(ErrorCodeString::new("BACKUP_RESTORE_PATH_FORBIDDEN"))
 }
 
 #[tauri::command]
 pub async fn backup_inspect(
     backup_path: String,
     state: State<'_, Arc<AppState>>,
 ) -> Result<BackupInspectResult> {
-    let app = state.inner().clone();
-    tauri::async_runtime::spawn_blocking(move || backup_inspect_service(&app, backup_path))
-        .await
-        .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+    let _ = backup_path;
+    let _ = state;
+    Err(ErrorCodeString::new("BACKUP_INSPECT_PATH_FORBIDDEN"))
 }
 
 #[tauri::command]
 pub async fn backup_restore_workflow(
     backup_path: String,
     state: State<'_, Arc<AppState>>,
 ) -> Result<bool> {
-    let app = state.inner().clone();
-    tauri::async_runtime::spawn_blocking(move || backup_restore_workflow_service(&app, backup_path))
-        .await
-        .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+    let _ = backup_path;
+    let _ = state;
+    Err(ErrorCodeString::new("BACKUP_RESTORE_PATH_FORBIDDEN"))
 }
 
+#[tauri::command]
+pub async fn backup_pick_file(app: AppHandle, state: State<'_, Arc<AppState>>) -> Result<Option<BackupPickPayload>> {
+    tauri::async_runtime::spawn_blocking(move || {
+        let st = state.inner().clone();
+        let now = now_ms()?;
+        cleanup_stale_backup_picks(&st, now)?;
+
+        let selection = app
+            .dialog()
+            .file()
+            .add_filter("Backup", &["pmbackup", "zip"])
+            .blocking_pick_file();
+
+        let Some(fp) = selection else {
+            return Ok(None);
+        };
+
+        let path = file_path_to_pathbuf(fp)?;
+        let file_name = path
+            .file_name()
+            .and_then(|s| s.to_str())
+            .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?
+            .to_string();
+
+        let byte_size = std::fs::metadata(&path)
+            .map(|m| m.len())
+            .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+
+        let inspect = backup_inspect_service(&st, path.to_string_lossy().to_string())?;
+
+        let token = Uuid::new_v4().to_string();
+        {
+            let mut map = st
+                .pending_backup_picks
+                .lock()
+                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+            map.insert(
+                token.clone(),
+                crate::app_state::PendingBackupPick {
+                    created_at_ms: now,
+                    path: path.clone(),
+                    file_name: file_name.clone(),
+                    byte_size,
+                },
+            );
+        }
+
+        Ok(Some(BackupPickPayload {
+            token,
+            file_name,
+            byte_size: byte_size as i64,
+            inspect,
+        }))
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
+#[tauri::command]
+pub async fn backup_discard_pick(state: State<'_, Arc<AppState>>, token: String) -> Result<()> {
+    let st = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || {
+        let mut map = st
+            .pending_backup_picks
+            .lock()
+            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+        map.remove(&token);
+        Ok(())
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
+#[tauri::command]
+pub async fn backup_restore_workflow_from_pick(state: State<'_, Arc<AppState>>, token: String) -> Result<bool> {
+    let st = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || {
+        let pick = {
+            let mut map = st
+                .pending_backup_picks
+                .lock()
+                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+            map.remove(&token)
+                .ok_or_else(|| ErrorCodeString::new("BACKUP_PICK_NOT_FOUND"))?
+        };
+        backup_restore_workflow_service(&st, pick.path.to_string_lossy().to_string())
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
 #[tauri::command]
 pub async fn backup_create_if_due_auto(state: State<'_, Arc<AppState>>) -> Result<Option<String>> {
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/main.rs b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/main.rs
index df0e901..9eaf82b 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/main.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src-tauri/src/main.rs
@@ -114,6 +114,10 @@ fn main() {
             get_attachment_preview,
             save_attachment_via_dialog,
             backup_create,
+            backup_create_via_dialog,
+            backup_pick_file,
+            backup_discard_pick,
+            backup_restore_workflow_from_pick,
             backup_restore,
             backup_inspect,
             backup_restore_workflow,
@@ -148,6 +152,7 @@ fn main() {
             workspace_list,
             workspace_select,
             workspace_create,
+            workspace_create_via_dialog,
             workspace_create_default,
             workspace_remove,
             workspace_open_in_explorer,
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/shared/lib/tauri.ts b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/shared/lib/tauri.ts
index 2c7a1a0..a72cdb6 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/shared/lib/tauri.ts
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/shared/lib/tauri.ts
@@ -63,8 +63,8 @@ export function workspaceSelect(id: string): Promise<boolean> {
   return invoke('workspace_select', { id });
 }
 
-export function workspaceCreate(path: string): Promise<boolean> {
-  return invoke('workspace_create', { path });
+export function workspaceCreateViaDialog(): Promise<boolean> {
+  return invoke('workspace_create_via_dialog');
 }
 
 export function workspaceCreateDefault(): Promise<boolean> {
   return invoke('workspace_create_default');
 }
@@ -83,14 +83,22 @@ export type BackupInspectResult = {
   vault_mode: string;
   will_overwrite: boolean;
 };
 
-export function backupInspect(backupPath: string): Promise<BackupInspectResult> {
-  return invoke('backup_inspect', { backup_path: backupPath });
-}
-
-export function backupRestoreWorkflow(backupPath: string): Promise<boolean> {
-  return invoke('backup_restore_workflow', { backup_path: backupPath });
-}
+export type BackupPickPayload = {
+  token: string;
+  file_name: string;
+  byte_size: number;
+  inspect: BackupInspectResult;
+};
+
+export function backupPickFile(): Promise<BackupPickPayload | null> {
+  return invoke('backup_pick_file');
+}
+
+export function backupDiscardPick(token: string): Promise<void> {
+  return invoke('backup_discard_pick', { token });
+}
+
+export function backupRestoreWorkflowFromPick(token: string): Promise<boolean> {
+  return invoke('backup_restore_workflow_from_pick', { token });
+}
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Workspace/Workspace.tsx b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Workspace/Workspace.tsx
index 4b43e91..7c62c11 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Workspace/Workspace.tsx
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Workspace/Workspace.tsx
@@ -4,9 +4,10 @@ import { useTranslation } from '../../shared/lib/i18n';
 import {
-  backupInspect,
-  backupRestoreWorkflow,
-  workspaceCreate,
+  backupPickFile,
+  backupDiscardPick,
+  backupRestoreWorkflowFromPick,
+  workspaceCreateViaDialog,
   workspaceCreateDefault,
   workspaceOpenInExplorer,
   workspaceSelect,
 } from '../../shared/lib/tauri';
@@ -31,7 +32,7 @@ const Workspace: React.FC<WorkspaceProps> = ({ onWorkspaceReady }) => {
   const [actionsMenu, setActionsMenu] = useState<ActionsMenuState | null>(null);
   const [confirmOpen, setConfirmOpen] = useState(false);
-  const [pendingBackupPath, setPendingBackupPath] = useState<string | null>(null);
+  const [pendingBackupToken, setPendingBackupToken] = useState<string | null>(null);
   const [pendingProfileName, setPendingProfileName] = useState<string>('');
 
@@ -95,15 +96,10 @@ const Workspace: React.FC<WorkspaceProps> = ({ onWorkspaceReady }) => {
   const handleCreate = useCallback(async () => {
     setBusy(true);
     try {
-      const { open } = await import('@tauri-apps/plugin-dialog');
-      const selected = await open({
-        directory: true,
-        multiple: false,
-        title: t('chooseFolder'),
-      });
-      if (typeof selected !== 'string') return;
-      await workspaceCreate(selected);
+      const ok = await workspaceCreateViaDialog();
+      if (!ok) return;
       await refresh();
       onWorkspaceReady();
     } finally {
       setBusy(false);
@@ -123,38 +119,32 @@ const Workspace: React.FC<WorkspaceProps> = ({ onWorkspaceReady }) => {
   const handleRestoreFromBackup = useCallback(async () => {
     setBusy(true);
     try {
-      const { open } = await import('@tauri-apps/plugin-dialog');
-      const backup = await open({
-        directory: false,
-        multiple: false,
-        title: t('chooseBackupFile'),
-        filters: [{ name: 'Backup', extensions: ['zip'] }],
-      });
-      if (typeof backup !== 'string') return;
-
-      const targetFolder = await open({
-        directory: true,
-        multiple: false,
-        title: t('chooseFolder'),
-      });
-      if (typeof targetFolder !== 'string') return;
-
-      await workspaceCreate(targetFolder);
+      const ok = await workspaceCreateViaDialog();
+      if (!ok) return;
       await refresh();
 
-      const info = await backupInspect(backup);
-      setPendingBackupPath(backup);
-      setPendingProfileName(info.profile_name);
+      const picked = await backupPickFile();
+      if (!picked) return;
+      setPendingBackupToken(picked.token);
+      setPendingProfileName(picked.inspect.profile_name);
 
-      if (info.will_overwrite) {
+      if (picked.inspect.will_overwrite) {
         setConfirmOpen(true);
         return;
       }
 
-      showToast(t('restoreInfoCreate', { name: info.profile_name }), 'success');
-      await backupRestoreWorkflow(backup);
+      showToast(t('restoreInfoCreate', { name: picked.inspect.profile_name }), 'success');
+      await backupRestoreWorkflowFromPick(picked.token);
+      await backupDiscardPick(picked.token);
+      setPendingBackupToken(null);
       showToast(t('restoreSuccess'), 'success');
       onWorkspaceReady();
     } finally {
       setBusy(false);
@@ -171,33 +161,22 @@ const Workspace: React.FC<WorkspaceProps> = ({ onWorkspaceReady }) => {
   const handleOpenDataFolder = useCallback(async () => {
     setBusy(true);
     try {
-      const { open } = await import('@tauri-apps/plugin-dialog');
-      // Always open directory picker first (acts as "Browseâ€¦")
-      const selected = await open({
-        directory: true,
-        multiple: false,
-        title: t('chooseFolder'),
-      });
-
-      if (typeof selected !== 'string') {
-        return; // cancelled
-      }
-
-      // If user picked the currently active valid workspace -> just reveal it in Explorer
-      if (
-        activeWorkspace &&
-        activeWorkspace.exists &&
-        activeWorkspace.valid &&
-        activeWorkspace.path === selected
-      ) {
-        await workspaceOpenInExplorer(activeWorkspace.id);
-        return;
-      }
-
-      // Otherwise initialize/add this folder as a workspace
-      await workspaceCreate(selected);
+      // In this UX, we always ask for a folder, then initialize it.
+      // If user wants to open the current active one, use the tile actions.
+      const ok = await workspaceCreateViaDialog();
+      if (!ok) return;
 
       await refresh();
       onWorkspaceReady();
     } finally {
       setBusy(false);
     }
-  }, [activeWorkspace, onWorkspaceReady, refresh, t]);
+  }, [onWorkspaceReady, refresh]);
@@ -422,20 +401,29 @@ const Workspace: React.FC<WorkspaceProps> = ({ onWorkspaceReady }) => {
             confirmLabel={t('restoreFromBackup')}
             cancelLabel={t('cancel')}
             onCancel={() => {
               setConfirmOpen(false);
-              setPendingBackupPath(null);
+              if (pendingBackupToken) void backupDiscardPick(pendingBackupToken);
+              setPendingBackupToken(null);
             }}
             onConfirm={async () => {
-              const path = pendingBackupPath;
+              const token = pendingBackupToken;
               setConfirmOpen(false);
-              setPendingBackupPath(null);
-              if (!path) return;
+              setPendingBackupToken(null);
+              if (!token) return;
               setBusy(true);
               try {
-                await backupRestoreWorkflow(path);
+                await backupRestoreWorkflowFromPick(token);
+                await backupDiscardPick(token);
                 showToast(t('restoreSuccess'), 'success');
                 onWorkspaceReady();
               } finally {
                 setBusy(false);
               }
             }}
           />
         </Suspense>
       )}
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/api/vaultApi.ts b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/api/vaultApi.ts
index 45b0d28..e6b1f0d 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/api/vaultApi.ts
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/api/vaultApi.ts
@@ -139,15 +139,33 @@ export async function updateSettings(settings: BackendUserSettings): Promise<bool
   return invoke('update_settings', { settings });
 }
 
 export async function createBackup(
-  destinationPath: string | null,
-  useDefaultPath: boolean
-): Promise<string> {
-  return invoke('backup_create', { destinationPath, useDefaultPath });
+  useDefaultPath: boolean,
+  suggestedFileName?: string
+): Promise<string | null> {
+  if (useDefaultPath) {
+    return invoke('backup_create', { destinationPath: null, useDefaultPath: true });
+  }
+  return invoke('backup_create_via_dialog', { suggestedFileName: suggestedFileName ?? null });
 }
 
-export async function restoreBackup(backupPath: string): Promise<boolean> {
-  return invoke('backup_restore', { backupPath });
+export type BackupPickPayloadDto = {
+  token: string;
+  fileName: string;
+  byteSize: number;
+  inspect: { profile_id: string; profile_name: string; created_at_utc: string; vault_mode: string; will_overwrite: boolean };
+};
+
+type BackendBackupPickPayload = { token: string; file_name: string; byte_size: number; inspect: BackupPickPayloadDto['inspect'] };
+
+export async function backupPickFile(): Promise<BackupPickPayloadDto | null> {
+  const payload = await invoke<BackendBackupPickPayload | null>('backup_pick_file');
+  if (!payload) return null;
+  return { token: payload.token, fileName: payload.file_name, byteSize: payload.byte_size, inspect: payload.inspect };
+}
+
+export async function backupDiscardPick(token: string): Promise<void> {
+  await invoke('backup_discard_pick', { token });
+}
+
+export async function restoreBackupWorkflowFromPick(token: string): Promise<boolean> {
+  return invoke('backup_restore_workflow_from_pick', { token });
 }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/components/modals/ExportBackupModal.tsx b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/components/modals/ExportBackupModal.tsx
index 0b3c0b1..f4f1c57 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/components/modals/ExportBackupModal.tsx
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/components/modals/ExportBackupModal.tsx
@@ -1,5 +1,4 @@
 import React, { useEffect, useState } from 'react';
-import { save } from '@tauri-apps/plugin-dialog';
 import { useTranslation } from '../../../../shared/lib/i18n';
 import { useToaster } from '../../../../shared/components/Toaster';
 import { createBackup } from '../../api/vaultApi';
@@ -38,8 +37,7 @@ export function ExportBackupModal({ open, profileId, onClose }: ExportBackupModal
   const { t: tCommon } = useTranslation('Common');
   const { show: showToast } = useToaster();
   const [useDefaultPath, setUseDefaultPath] = useState(true);
-  const [destinationPath, setDestinationPath] = useState<string | null>(null);
   const [isSaving, setIsSaving] = useState(false);
   const [suggestedFileName, setSuggestedFileName] = useState('');
 
@@ -47,7 +45,6 @@ export function ExportBackupModal({ open, profileId, onClose }: ExportBackupModal
   useEffect(() => {
     if (!open) return;
     setUseDefaultPath(true);
-    setDestinationPath(null);
     setIsSaving(false);
     const timestamp = formatTimestamp();
     setSuggestedFileName(`backup_${timestamp}_${profileId}.pmbackup.zip`);
@@ -56,23 +53,9 @@ export function ExportBackupModal({ open, profileId, onClose }: ExportBackupModal
   if (!open) return null;
-
-  const handleChoosePath = async () => {
-    const selection = await save({
-      defaultPath: suggestedFileName,
-      filters: [{ name: 'Password Manager Backup', extensions: ['pmbackup', 'zip'] }],
-    });
-
-    if (typeof selection === 'string') {
-      setDestinationPath(selection);
-    }
-  };
 
   const handleCreate = async () => {
-    if (!useDefaultPath && !destinationPath) return;
     setIsSaving(true);
 
     try {
-      await createBackup(useDefaultPath ? null : destinationPath, useDefaultPath);
+      const path = await createBackup(useDefaultPath, suggestedFileName);
+      if (!path) return;
       showToast(t('backup.export.success'), 'success');
       onClose();
     } catch (err: any) {
@@ -141,16 +124,12 @@ export function ExportBackupModal({ open, profileId, onClose }: ExportBackupModal
           {!useDefaultPath && (
             <div className="form-field">
-              <label className="form-label" htmlFor="export-backup-path">
-                {t('backup.export.choosePath')}
-              </label>
-              <button className="btn btn-secondary" type="button" onClick={handleChoosePath} disabled={isSaving}>
-                {t('backup.export.choosePath')}
-              </button>
-              <p id="export-backup-path" className="dialog-description">
-                {destinationPath ?? suggestedFileName}
-              </p>
+              <p className="dialog-description">
+                {t('backup.export.choosePath')}: {suggestedFileName}
+              </p>
+              <p className="dialog-description">
+                {tCommon('action.create')}: {t('backup.export.create')}
+              </p>
             </div>
           )}
@@ -174,7 +153,7 @@ export function ExportBackupModal({ open, profileId, onClose }: ExportBackupModal
             <button
               className="btn btn-primary"
               type="button"
               onClick={handleCreate}
-              disabled={isSaving || (!useDefaultPath && !destinationPath)}
+              disabled={isSaving}
             >
               {t('backup.export.create')}
             </button>
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/Vault.tsx b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/Vault.tsx
index 7a88cdb..3f31f6b 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/Vault.tsx
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-add-reproducible-install-scripts-and-documen/src/features/Vault/Vault.tsx
@@ -16,7 +16,7 @@ import { useTranslation } from '../../shared/lib/i18n';
 import { useToaster } from '../../shared/components/Toaster';
-import { createBackupIfDueAuto, restoreBackup } from './api/vaultApi';
+import { backupPickFile, backupDiscardPick, createBackupIfDueAuto, restoreBackupWorkflowFromPick } from './api/vaultApi';
 import { BackendUserSettings } from './types/backend';
@@ -65,7 +65,8 @@ export function Vault(/* ... */) {
   const [exportModalOpen, setExportModalOpen] = useState(false);
   const [isRestoringBackup, setIsRestoringBackup] = useState(false);
-  const [pendingImportPath, setPendingImportPath] = useState<string | null>(null);
+  const [pendingImportToken, setPendingImportToken] = useState<string | null>(null);
+  const [pendingImportLabel, setPendingImportLabel] = useState<string | null>(null);
 
@@ -124,14 +125,12 @@ export function Vault(/* ... */) {
   const handleExportBackup = () => setExportModalOpen(true);
 
   const handleImportBackup = async () => {
-    const { open } = await import('@tauri-apps/plugin-dialog');
-    const selection = await open({
-      multiple: false,
-      filters: [{ name: 'Password Manager Backup', extensions: ['pmbackup', 'zip'] }],
-    });
-    const selectedPath = Array.isArray(selection) ? selection[0] : selection;
-    if (typeof selectedPath !== 'string') return;
-    setPendingImportPath(selectedPath);
+    const picked = await backupPickFile();
+    if (!picked) return;
+    setPendingImportToken(picked.token);
+    setPendingImportLabel(picked.fileName);
   };
 
   const handleConfirmImport = async () => {
-    if (!pendingImportPath) return;
+    if (!pendingImportToken) return;
     setIsRestoringBackup(true);
     try {
-      await restoreBackup(pendingImportPath);
+      await restoreBackupWorkflowFromPick(pendingImportToken);
+      await backupDiscardPick(pendingImportToken);
       showToast(tVault('backup.import.success'), 'success');
-      setPendingImportPath(null);
+      setPendingImportToken(null);
+      setPendingImportLabel(null);
       onLocked();
     } catch (err) {
       handleBackupError(err);
@@ -144,9 +143,14 @@ export function Vault(/* ... */) {
   };
 
   const handleCloseImport = () => {
     if (isRestoringBackup) return;
-    setPendingImportPath(null);
+    if (pendingImportToken) void backupDiscardPick(pendingImportToken);
+    setPendingImportToken(null);
+    setPendingImportLabel(null);
   };
@@ -345,14 +349,14 @@ export function Vault(/* ... */) {
-      {pendingImportPath !== null && (
+      {pendingImportToken !== null && (
         <Suspense fallback={null}>
           <LazyImportBackupModal
-            open={pendingImportPath !== null}
-            backupPath={pendingImportPath}
+            open={pendingImportToken !== null}
+            backupPath={pendingImportLabel}
             isSubmitting={isRestoringBackup}
             onCancel={handleCloseImport}
             onConfirm={handleConfirmImport}
           />
         </Suspense>
       )}
