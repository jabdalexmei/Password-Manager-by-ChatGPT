diff --git a/src-tauri/Cargo.toml b/src-tauri/Cargo.toml
index 7634224..de9dfd2 100644
--- a/src-tauri/Cargo.toml
+++ b/src-tauri/Cargo.toml
@@ -39,6 +39,7 @@ windows = "0.61"
 chacha20poly1305 = "0.10.1"
 zeroize = "1.8"
 base64 = "0.22"
+fs2 = "0.4"
 
 [build-dependencies]
 tauri-build = { version = "2.4.0", features = [] }
diff --git a/src-tauri/src/app_state.rs b/src-tauri/src/app_state.rs
index 1f6250c..33d6c26 100644
--- a/src-tauri/src/app_state.rs
+++ b/src-tauri/src/app_state.rs
@@ -1,4 +1,5 @@
 use std::collections::HashMap;
+use std::fs::OpenOptions;
 use std::path::PathBuf;
 use std::sync::atomic::AtomicBool;
 use std::sync::{Arc, Mutex};
@@ -6,6 +7,8 @@ use std::sync::{Arc, Mutex};
 use crate::data::storage_paths::StoragePaths;
 use crate::error::{ErrorCodeString, Result};
 
+use fs2::FileExt;
+
 use zeroize::Zeroizing;
 
 pub struct VaultSession {
@@ -37,6 +40,8 @@ pub struct AppState {
     pub active_profile: Mutex<Option<String>>,
     pub storage_paths: Mutex<StoragePaths>,
 
+    pub workspace_lock: Mutex<Option<std::fs::File>>,
+
     pub vault_session: Mutex<Option<VaultSession>>,
     pub vault_persist_guard: Mutex<()>,
     pub vault_persist_requested: AtomicBool,
@@ -57,6 +62,8 @@ impl AppState {
             active_profile: Mutex::new(None),
             storage_paths: Mutex::new(storage_paths),
 
+            workspace_lock: Mutex::new(None),
+
             vault_session: Mutex::new(None),
             vault_persist_guard: Mutex::new(()),
             vault_persist_requested: AtomicBool::new(false),
@@ -68,7 +75,31 @@ impl AppState {
         }
     }
 
+    fn acquire_workspace_lock(workspace_root: &PathBuf) -> Result<std::fs::File> {
+        let lock_path = workspace_root.join(".pm-workspace.lock");
+        let file = OpenOptions::new()
+            .read(true)
+            .write(true)
+            .create(true)
+            .open(&lock_path)
+            .map_err(|_| ErrorCodeString::new("WORKSPACE_LOCK_FAILED"))?;
+
+        file.try_lock_exclusive()
+            .map_err(|_| ErrorCodeString::new("WORKSPACE_ALREADY_IN_USE"))?;
+
+        Ok(file)
+    }
+
     pub fn set_workspace_root(&self, workspace_root: std::path::PathBuf) -> Result<()> {
+        // Preflight create to ensure workspace_root exists before we attempt to lock.
+        // This is safe even if locking fails (no user data is modified here).
+        let profiles_dir = workspace_root.join("Profiles");
+        std::fs::create_dir_all(&profiles_dir)
+            .map_err(|_| ErrorCodeString::new("WORKSPACE_PROFILES_CREATE_FAILED"))?;
+
+        // Acquire a cross-process lock to prevent multi-instance corruption.
+        let lock_file = Self::acquire_workspace_lock(&workspace_root)?;
+
         {
             let mut storage_paths = self
                 .storage_paths
@@ -76,11 +107,27 @@ impl AppState {
                 .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
             storage_paths.configure_workspace(workspace_root)?;
         }
+
+        {
+            let mut ws_lock = self
+                .workspace_lock
+                .lock()
+                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+            *ws_lock = Some(lock_file);
+        }
+
         self.clear_security_state()?;
         Ok(())
     }
 
     pub fn clear_workspace_root(&self) -> Result<()> {
+        {
+            let mut ws_lock = self
+                .workspace_lock
+                .lock()
+                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+            *ws_lock = None;
+        }
         {
             let mut storage_paths = self
                 .storage_paths
diff --git a/src-tauri/src/data/fs/atomic_write.rs b/src-tauri/src/data/fs/atomic_write.rs
index 59e6ec8..615d99f 100644
--- a/src-tauri/src/data/fs/atomic_write.rs
+++ b/src-tauri/src/data/fs/atomic_write.rs
@@ -6,6 +6,36 @@ use std::path::Path;
 use std::time::Duration;
 use uuid::Uuid;
 
+#[cfg(windows)]
+fn rename_platform(from: &Path, to: &Path) -> io::Result<()> {
+    use std::iter;
+    use std::os::windows::ffi::OsStrExt;
+    use windows_sys::Win32::Storage::FileSystem::{MoveFileExW, MOVEFILE_WRITE_THROUGH};
+
+    let from_w: Vec<u16> = from
+        .as_os_str()
+        .encode_wide()
+        .chain(iter::once(0))
+        .collect();
+    let to_w: Vec<u16> = to
+        .as_os_str()
+        .encode_wide()
+        .chain(iter::once(0))
+        .collect();
+
+    let ok = unsafe { MoveFileExW(from_w.as_ptr(), to_w.as_ptr(), MOVEFILE_WRITE_THROUGH) };
+    if ok == 0 {
+        Err(io::Error::last_os_error())
+    } else {
+        Ok(())
+    }
+}
+
+#[cfg(not(windows))]
+fn rename_platform(from: &Path, to: &Path) -> io::Result<()> {
+    fs::rename(from, to)
+}
+
 #[cfg(unix)]
 fn best_effort_fsync_dir(dir: &Path) {
     if let Ok(f) = fs::File::open(dir) {
@@ -34,7 +64,7 @@ pub fn write_atomic(path: &Path, bytes: &[u8]) -> io::Result<()> {
         // Windows часто даёт PermissionDenied если файл ещё открыт (SQLite/AV/indexer).
         // Делаем короткие ретраи.
         for _ in 0..25 {
-            match fs::rename(from, to) {
+            match rename_platform(from, to) {
                 Ok(()) => return Ok(()),
                 Err(e) => {
                     last = Some(e);
diff --git a/src-tauri/src/services/backup_service.rs b/src-tauri/src/services/backup_service.rs
index b894408..31d93bd 100644
--- a/src-tauri/src/services/backup_service.rs
+++ b/src-tauri/src/services/backup_service.rs
@@ -196,6 +196,23 @@ fn best_effort_fsync_rename_dirs(_src: &Path, _dst: &Path) {
     }
 }
 
+#[cfg(windows)]
+fn rename_platform(src: &Path, dst: &Path) -> std::io::Result<()> {
+    use std::iter;
+    use std::os::windows::ffi::OsStrExt;
+    use windows_sys::Win32::Storage::FileSystem::{MoveFileExW, MOVEFILE_WRITE_THROUGH};
+
+    let src_w: Vec<u16> = src.as_os_str().encode_wide().chain(iter::once(0)).collect();
+    let dst_w: Vec<u16> = dst.as_os_str().encode_wide().chain(iter::once(0)).collect();
+    let ok = unsafe { MoveFileExW(src_w.as_ptr(), dst_w.as_ptr(), MOVEFILE_WRITE_THROUGH) };
+    if ok == 0 { Err(std::io::Error::last_os_error()) } else { Ok(()) }
+}
+
+#[cfg(not(windows))]
+fn rename_platform(src: &Path, dst: &Path) -> std::io::Result<()> {
+    fs::rename(src, dst)
+}
+
 fn rename_with_retry(src: &Path, dst: &Path) -> std::io::Result<()> {
     use std::time::Duration;
 
@@ -204,7 +221,7 @@ fn rename_with_retry(src: &Path, dst: &Path) -> std::io::Result<()> {
 
     let mut last_err: Option<std::io::Error> = None;
     for _ in 0..ATTEMPTS {
-        match fs::rename(src, dst) {
+        match rename_platform(src, dst) {
             Ok(()) => {
                 best_effort_fsync_rename_dirs(src, dst);
                 return Ok(());
@@ -848,6 +865,10 @@ fn restore_archive_to_profile(
         writer
             .flush()
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+        writer
+            .get_ref()
+            .sync_all()
+            .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
         let sha256 = hex::encode(hasher.finalize());
         if sha256 != entry.sha256 || bytes_written != entry.bytes {
             return Err(ErrorCodeString::new("BACKUP_INTEGRITY_FAILED"));
@@ -882,6 +903,11 @@ fn restore_archive_to_profile(
         vault_tmp_path = Some(tmp.clone());
         fs::copy(&extracted_vault, &tmp)
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+        // Ensure the copied vault bytes reach disk before we swap it into place.
+        fs::File::open(&tmp)
+            .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?
+            .sync_all()
+            .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
         rename_with_retry(&tmp, &vault_path)
             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
         vault_replaced = true;
diff --git a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
index 81b7a7c..56776d4 100644
--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -959,10 +959,32 @@ fn best_effort_fsync_rename_dirs(_from: &Path, _to: &Path) {
     }
 }
 
+#[cfg(windows)]
+fn rename_platform(from: &Path, to: &Path) -> io::Result<()> {
+    use std::iter;
+    use std::os::windows::ffi::OsStrExt;
+    use windows_sys::Win32::Storage::FileSystem::{MoveFileExW, MOVEFILE_WRITE_THROUGH};
+
+    let from_w: Vec<u16> = from.as_os_str().encode_wide().chain(iter::once(0)).collect();
+    let to_w: Vec<u16> = to.as_os_str().encode_wide().chain(iter::once(0)).collect();
+
+    let ok = unsafe { MoveFileExW(from_w.as_ptr(), to_w.as_ptr(), MOVEFILE_WRITE_THROUGH) };
+    if ok == 0 {
+        Err(io::Error::last_os_error())
+    } else {
+        Ok(())
+    }
+}
+
+#[cfg(not(windows))]
+fn rename_platform(from: &Path, to: &Path) -> io::Result<()> {
+    std::fs::rename(from, to)
+}
+
 fn rename_retry(from: &Path, to: &Path, attempts: u32, base_delay: Duration) -> io::Result<()> {
     let mut i = 0;
     loop {
-        match std::fs::rename(from, to) {
+        match rename_platform(from, to) {
             Ok(()) => {
                 best_effort_fsync_rename_dirs(from, to);
                 return Ok(());
