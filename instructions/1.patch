diff -ruN /mnt/data/work/orig/src-tauri/src/data/sqlite/migrations.rs /mnt/data/work/src/Password-Manager-by-ChatGPT-Passwordless-encrypted/src-tauri/src/data/sqlite/migrations.rs
--- /mnt/data/work/orig/src-tauri/src/data/sqlite/migrations.rs	2026-01-20 07:15:33.000000000 +0000
+++ /mnt/data/work/src/Password-Manager-by-ChatGPT-Passwordless-encrypted/src-tauri/src/data/sqlite/migrations.rs	2026-01-20 09:45:13.252874013 +0000
@@ -294,12 +294,14 @@
             ErrorCodeString::new("DB_QUERY_FAILED")
         })?;
 
-    log::info!(
-        "[DB][migrate] user_version={version}, current={CURRENT_SCHEMA_VERSION}"
-    );
+    if version == CURRENT_SCHEMA_VERSION {
+        log::debug!("[DB][migrate] up_to_date version={version}");
+        return Ok(());
+    }
 
     // Fresh DB: create schema and stamp it with the current version.
     if version == 0 {
+        log::info!("[DB][migrate] init schema version={CURRENT_SCHEMA_VERSION}");
         conn.execute_batch(include_str!("schema.sql"))
             .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
         ensure_ui_preferences_table(conn)?;
@@ -308,6 +310,8 @@
         return Ok(());
     }
 
+    log::info!("[DB][migrate] migrate from={version} to={CURRENT_SCHEMA_VERSION}");
+
     match version {
         1 => {
             migrate_1_to_2(conn)?;
diff -ruN /mnt/data/work/orig/src-tauri/src/services/security_service.rs /mnt/data/work/src/Password-Manager-by-ChatGPT-Passwordless-encrypted/src-tauri/src/services/security_service.rs
--- /mnt/data/work/orig/src-tauri/src/services/security_service.rs	2026-01-20 07:15:33.000000000 +0000
+++ /mnt/data/work/src/Password-Manager-by-ChatGPT-Passwordless-encrypted/src-tauri/src/services/security_service.rs	2026-01-20 09:46:24.658415261 +0000
@@ -1432,6 +1432,25 @@
 }
 
 pub fn login_vault(id: &str, password: Option<&str>, state: &Arc<AppState>) -> Result<bool> {
+    // No-op if the vault is already unlocked for this profile.
+    // In dev builds the UI can accidentally invoke login multiple times (e.g. React StrictMode).
+    {
+        let session_guard = state
+            .vault_session
+            .lock()
+            .map_err(|_| ErrorCodeString::new("STATE_LOCK_POISONED"))?;
+
+        if let Some(session) = session_guard.as_ref() {
+            if session.profile_id == id {
+                log::debug!("[SECURITY][login] no-op already_unlocked profile_id={}", id);
+                if let Ok(mut active) = state.active_profile.lock() {
+                    *active = Some(id.to_string());
+                }
+                return Ok(true);
+            }
+        }
+    }
+
     let storage_paths = state.get_storage_paths()?;
     let mut profile = registry::get_profile(&storage_paths, id)?
         .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
