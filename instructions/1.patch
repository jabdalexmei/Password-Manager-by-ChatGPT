diff --git a/src-tauri/src/data/profiles/registry.rs b/src-tauri/src/data/profiles/registry.rs
index 5759509..b3b8d6e 100644
--- a/src-tauri/src/data/profiles/registry.rs
+++ b/src-tauri/src/data/profiles/registry.rs
@@ -1,8 +1,11 @@
 use serde::{Deserialize, Serialize};
 use std::fs;
+use std::io::Read;
 use std::path::PathBuf;
 use uuid::Uuid;
 
+use crate::data::crypto::cipher::PM_ENC_MAGIC;
 use crate::data::fs::atomic_write::write_atomic;
-use crate::data::profiles::paths::{ensure_profiles_dir, profile_config_path, registry_path};
+use crate::data::profiles::paths::{
+    ensure_profiles_dir, key_check_path, kdf_salt_path, profile_config_path, registry_path,
+    vault_db_path,
+};
 use crate::data::storage_paths::StoragePaths;
 use crate::error::{ErrorCodeString, Result};
 use crate::types::ProfileMeta;
@@ -38,6 +41,44 @@ fn save_registry(sp: &StoragePaths, registry: &ProfileRegistry) -> Result<()> {
     write_atomic(&path, serialized.as_bytes())
         .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
 }
 
+fn vault_looks_encrypted(sp: &StoragePaths, id: &str) -> bool {
+    let path = match vault_db_path(sp, id) {
+        Ok(p) => p,
+        Err(_) => return false,
+    };
+    if !path.exists() {
+        return false;
+    }
+    let mut f = match fs::File::open(path) {
+        Ok(f) => f,
+        Err(_) => return false,
+    };
+    let mut buf = [0u8; 6];
+    if f.read_exact(&mut buf).is_err() {
+        return false;
+    }
+    buf == PM_ENC_MAGIC
+}
+
+fn infer_has_password(sp: &StoragePaths, id: &str, current: bool) -> bool {
+    if current {
+        return true;
+    }
+    let salt_ok = kdf_salt_path(sp, id).ok().is_some_and(|p| p.exists());
+    let key_ok = key_check_path(sp, id).ok().is_some_and(|p| p.exists());
+    if salt_ok && key_ok {
+        return true;
+    }
+    vault_looks_encrypted(sp, id)
+}
+
 pub fn list_profiles(sp: &StoragePaths) -> Result<Vec<ProfileMeta>> {
-    let registry = load_registry(sp)?;
-    Ok(registry
-        .profiles
-        .into_iter()
-        .map(ProfileMeta::from)
-        .collect())
+    let mut registry = load_registry(sp)?;
+    let mut dirty = false;
+
+    for rec in registry.profiles.iter_mut() {
+        let inferred = infer_has_password(sp, &rec.id, rec.has_password);
+        if inferred != rec.has_password {
+            rec.has_password = inferred;
+            dirty = true;
+        }
+    }
+
+    if dirty {
+        let _ = save_registry(sp, &registry);
+    }
+
+    Ok(registry.profiles.into_iter().map(ProfileMeta::from).collect())
 }
@@ -173,6 +214,9 @@ pub fn rename_profile(sp: &StoragePaths, id: &str, name: &str) -> Result<Profile
     let meta = ProfileMeta {
         id: registry.profiles[idx].id.clone(),
         name: registry.profiles[idx].name.clone(),
-        has_password: registry.profiles[idx].has_password,
+        has_password: infer_has_password(
+            sp,
+            &registry.profiles[idx].id,
+            registry.profiles[idx].has_password,
+        ),
     };
@@ -231,7 +275,22 @@ pub fn get_profile(sp: &StoragePaths, id: &str) -> Result<Option<ProfileRecord>>
-    let registry = load_registry(sp)?;
-    Ok(registry.profiles.into_iter().find(|p| p.id == id))
+    let mut registry = load_registry(sp)?;
+    let idx = match registry.profiles.iter().position(|p| p.id == id) {
+        Some(i) => i,
+        None => return Ok(None),
+    };
+
+    let inferred = infer_has_password(sp, &registry.profiles[idx].id, registry.profiles[idx].has_password);
+    let mut dirty = false;
+    if inferred != registry.profiles[idx].has_password {
+        registry.profiles[idx].has_password = inferred;
+        dirty = true;
+    }
+
+    let out = registry.profiles[idx].clone();
+    if dirty {
+        let _ = save_registry(sp, &registry);
+    }
+    Ok(Some(out))
 }
