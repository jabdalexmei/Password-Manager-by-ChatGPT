diff --git a/instructions/1.patch b/instructions/1.patch
deleted file mode 100644
index 7419166..0000000
--- a/instructions/1.patch
+++ /dev/null
@@ -1,283 +0,0 @@
---- a/src-tauri/src/services/backup_service.rs
-+++ b/src-tauri/src/services/backup_service.rs
-@@ -241,86 +241,6 @@
-     }))
- }
- 
--fn copy_dir_recursive(src: &Path, dst: &Path) -> std::io::Result<()> {
--    // We can't rely on rename() between temp_dir and profile_root: temp_dir may live on another
--    // filesystem/mount (EXDEV). Copy into a staging dir under profile_root, then swap in place.
--    fs::create_dir_all(dst)?;
--
--    for entry in WalkDir::new(src) {
--        let entry = entry?;
--        let p = entry.path();
--        let rel = match p.strip_prefix(src) {
--            Ok(r) => r,
--            Err(_) => continue,
--        };
--
--        // Skip the root itself.
--        if rel.as_os_str().is_empty() {
--            continue;
--        }
--
--        let target = dst.join(rel);
--        if entry.file_type().is_dir() {
--            fs::create_dir_all(&target)?;
--            continue;
--        }
--
--        if entry.file_type().is_file() {
--            if let Some(parent) = target.parent() {
--                fs::create_dir_all(parent)?;
--            }
--            fs::copy(p, &target)?;
--            // Best-effort: ensure bytes reach disk before we swap directories.
--            if let Ok(f) = fs::File::open(&target) {
--                let _ = f.sync_all();
--            }
--        }
--    }
--
--    best_effort_fsync_dir(dst);
--    Ok(())
--}
--
--fn copy_dir_recursive(src: &Path, dst: &Path) -> std::io::Result<()> {
--    // We can't rely on rename() between temp_dir and profile_root: temp_dir may live on another
--    // filesystem/mount (EXDEV). Copy into a staging dir under profile_root, then swap in place.
--    fs::create_dir_all(dst)?;
--
--    for entry in WalkDir::new(src) {
--        let entry = entry?;
--        let p = entry.path();
--        let rel = match p.strip_prefix(src) {
--            Ok(r) => r,
--            Err(_) => continue,
--        };
--
--        // Skip the root itself.
--        if rel.as_os_str().is_empty() {
--            continue;
--        }
--
--        let target = dst.join(rel);
--        if entry.file_type().is_dir() {
--            fs::create_dir_all(&target)?;
--            continue;
--        }
--
--        if entry.file_type().is_file() {
--            if let Some(parent) = target.parent() {
--                fs::create_dir_all(parent)?;
--            }
--            fs::copy(p, &target)?;
--            // Best-effort: ensure bytes reach disk before we swap directories.
--            if let Ok(f) = fs::File::open(&target) {
--                let _ = f.sync_all();
--            }
--        }
--    }
--
--    best_effort_fsync_dir(dst);
--    Ok(())
--}
--
- fn ensure_backup_guard(state: &Arc<AppState>) -> Result<std::sync::MutexGuard<'_, ()>> {
-     state
-         .backup_guard
-@@ -905,39 +825,26 @@
-     for entry in &manifest.files {
-         let rel_path = Path::new(&entry.path);
-         if !validate_zip_entry_rel_path_windows(rel_path) {
--    let mut attachments_tmp_path: Option<PathBuf> = None;
--            // Prefer rename (fast) when temp_dir is on the same filesystem. Fall back to copy when it isn't.
--            match rename_with_retry(&extracted_attachments, &attachments_path) {
--                Ok(()) => {
--                    restored_attachments_created = true;
--                }
--                Err(e) if e.kind() == std::io::ErrorKind::CrossDeviceLink => {
--                    let staging =
--                        profile_root.join(format!("attachments.restore.{}", Uuid::new_v4()));
--                    attachments_tmp_path = Some(staging.clone());
--                    copy_dir_recursive(&extracted_attachments, &staging)
--                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
--                    rename_with_retry(&staging, &attachments_path)
--                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
--                    restored_attachments_created = true;
--                }
--                Err(_) => {
--                    return Err(ErrorCodeString::new("BACKUP_RESTORE_FAILED"));
--                }
--            }
-+            return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
-+        }
-+
-+        let mut zipped_file = archive
-             .by_name(&entry.path)
-             .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
-+
-         let target_path = temp_dir.path().join(rel_path);
-         if let Some(parent) = target_path.parent() {
-             fs::create_dir_all(parent)
-                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-         }
-+
-         let file = fs::File::create(&target_path)
-             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-         let mut writer = BufWriter::new(file);
-         let mut buffer = [0u8; 64 * 1024];
-         let mut hasher = Sha256::new();
-         let mut bytes_written = 0i64;
-+
-         loop {
-             let read = zipped_file
-                 .read(&mut buffer)
-@@ -948,17 +855,21 @@
-             writer
-                 .write_all(&buffer[..read])
-                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-+
-             bytes_written = bytes_written
-                 .checked_add(read as i64)
-                 .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
-             total_written = total_written
-                 .checked_add(read as i64)
-                 .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
-+
-             if bytes_written > MAX_RESTORE_ENTRY_BYTES || total_written > MAX_RESTORE_TOTAL_BYTES {
-                 return Err(ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"));
-             }
-+
-             hasher.update(&buffer[..read]);
-         }
-+
-         writer
-             .flush()
-             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-@@ -966,6 +877,7 @@
-             .get_ref()
-             .sync_all()
-             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-+
-         let sha256 = hex::encode(hasher.finalize());
-         if sha256 != entry.sha256 || bytes_written != entry.bytes {
-             return Err(ErrorCodeString::new("BACKUP_INTEGRITY_FAILED"));
-@@ -984,12 +896,14 @@
- 
-     let vault_backup_path = vault_path.with_extension(format!("old.{}", Uuid::new_v4()));
-     let attachments_backup_path = profile_root.join(format!("attachments.old.{}", Uuid::new_v4()));
-+
-     let mut moved_vault = false;
-     let mut vault_replaced = false;
-     let mut vault_tmp_path: Option<PathBuf> = None;
--    let mut attachments_tmp_path: Option<PathBuf> = None;
-+
-     let mut moved_attachments = false;
-     let mut restored_attachments_created = false;
-+
-     let restore_result: Result<()> = (|| {
-         if vault_path.exists() {
-             rename_with_retry(&vault_path, &vault_backup_path)
-@@ -1001,46 +915,26 @@
-         vault_tmp_path = Some(tmp.clone());
-         fs::copy(&extracted_vault, &tmp)
-             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
--        // Ensure the copied vault bytes reach disk before we swap it into place.
-         fs::File::open(&tmp)
-             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?
-             .sync_all()
-             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-+
-         rename_with_retry(&tmp, &vault_path)
-             .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-         vault_replaced = true;
- 
--        if let Some(tmp) = attachments_tmp_path.as_ref() {
--            if tmp.exists() {
--                let _ = fs::remove_dir_all(tmp);
--            }
--        }
--                let _ = rename_with_retry(&vault_backup_path, &vault_path);
-+        if attachments_path.exists() {
-             rename_with_retry(&attachments_path, &attachments_backup_path)
-                 .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-             moved_attachments = true;
-         }
- 
-         if extracted_attachments.exists() {
--            // Prefer rename (fast) when temp_dir is on the same filesystem. Fall back to copy when it isn't.
--            match rename_with_retry(&extracted_attachments, &attachments_path) {
--                Ok(()) => {
--                    restored_attachments_created = true;
--                }
--                Err(e) if e.kind() == std::io::ErrorKind::CrossDeviceLink => {
--                    let staging =
--                        profile_root.join(format!("attachments.restore.{}", Uuid::new_v4()));
--                    attachments_tmp_path = Some(staging.clone());
--                    copy_dir_recursive(&extracted_attachments, &staging)
--                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
--                    rename_with_retry(&staging, &attachments_path)
--                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
--                    restored_attachments_created = true;
--                }
--                Err(_) => {
--                    return Err(ErrorCodeString::new("BACKUP_RESTORE_FAILED"));
--                }
--            }
-+            rename_with_retry(&extracted_attachments, &attachments_path)
-+                .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-+            restored_attachments_created = true;
-+
-         } else {
-             if !attachments_path.exists() {
-                 fs::create_dir_all(&attachments_path)
-@@ -1054,8 +948,6 @@
-             if extracted_file.exists() {
-                 let target = profile_root.join(file_name);
- 
--                // Copy into the profile directory first, so we can swap atomically even if temp_dir
--                // lives on a different filesystem/mount.
-                 let tmp = profile_root.join(format!("{}.restore.{}", file_name, Uuid::new_v4()));
-                 fs::copy(&extracted_file, &tmp)
-                     .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-@@ -1096,13 +988,7 @@
-                 let _ = fs::remove_file(tmp);
-             }
-         }
--        if let Some(tmp) = attachments_tmp_path.as_ref() {
--            if tmp.exists() {
--                let _ = fs::remove_dir_all(tmp);
--            }
--        }
--        // Roll back to the pre-restore state as safely as we can.
--        // IMPORTANT: never delete the last known-good vault before we have restored it.
-+
-         if moved_vault && vault_backup_path.exists() {
-             #[cfg(windows)]
-             {
-@@ -1114,20 +1000,18 @@
-                 let _ = rename_with_retry(&vault_backup_path, &vault_path);
-             }
-         } else if !moved_vault && vault_replaced && vault_path.exists() {
--            // No prior vault existed; remove the partially restored file.
-             let _ = fs::remove_file(&vault_path);
-         }
-+
-         if moved_attachments && attachments_backup_path.exists() {
-             if attachments_path.exists() {
-                 let _ = fs::remove_dir_all(&attachments_path);
-             }
-             let _ = rename_with_retry(&attachments_backup_path, &attachments_path);
--        } else if !attachments_existed_before
--            && restored_attachments_created
--            && attachments_path.exists()
--        {
-+        } else if !attachments_existed_before && restored_attachments_created && attachments_path.exists() {
-             let _ = fs::remove_dir_all(&attachments_path);
-         }
-+
-         return Err(ErrorCodeString::new("BACKUP_RESTORE_FAILED"));
-     }
- 
diff --git a/src-tauri/Cargo.toml b/src-tauri/Cargo.toml
index de9dfd2..07c97fb 100644
--- a/src-tauri/Cargo.toml
+++ b/src-tauri/Cargo.toml
@@ -24,22 +24,25 @@ sha2 = "0.10"
 hex = "0.4"
 walkdir = "2.5"
 tempfile = "3.10"
-windows-sys = { version = "0.61", features = [
-  "Win32_Foundation",
-  "Win32_Storage_FileSystem",
-  "Win32_System_DataExchange",
-  "Win32_UI_WindowsAndMessaging"
-] }
 
 mime_guess = "2.0"
 
-webview2-com = "0.38.0"
-windows = "0.61"
 
 chacha20poly1305 = "0.10.1"
 zeroize = "1.8"
 base64 = "0.22"
 fs2 = "0.4"
 
+
+[target.'cfg(windows)'.dependencies]
+windows-sys = { version = "0.61", features = [
+  "Win32_Foundation",
+  "Win32_Storage_FileSystem",
+  "Win32_System_DataExchange",
+  "Win32_UI_WindowsAndMessaging"
+] }
+webview2-com = "0.38.0"
+windows = "0.61"
+
 [build-dependencies]
 tauri-build = { version = "2.4.0", features = [] }
diff --git a/src-tauri/src/commands/clipboard.rs b/src-tauri/src/commands/clipboard.rs
index 498ca58..a6dd35e 100644
--- a/src-tauri/src/commands/clipboard.rs
+++ b/src-tauri/src/commands/clipboard.rs
@@ -1,15 +1,6 @@
-#[cfg(target_os = "windows")]
 use crate::services::clipboard_service;
 
 #[tauri::command]
 pub fn clipboard_clear_all() -> Result<(), String> {
-    #[cfg(target_os = "windows")]
-    {
-        clipboard_service::clear_clipboard_all()
-    }
-
-    #[cfg(not(target_os = "windows"))]
-    {
-        Err("NOT_SUPPORTED".to_string())
-    }
+    clipboard_service::clear_clipboard_all()
 }
diff --git a/src-tauri/src/commands/workspace.rs b/src-tauri/src/commands/workspace.rs
index 18dfc1d..a478b7a 100644
--- a/src-tauri/src/commands/workspace.rs
+++ b/src-tauri/src/commands/workspace.rs
@@ -284,30 +284,10 @@ pub async fn workspace_open_in_explorer(
         if !root.exists() {
             return Err(ErrorCodeString::new("WORKSPACE_FOLDER_MISSING"));
         }
-
-        #[cfg(target_os = "windows")]
-        {
-            std::process::Command::new("explorer")
-                .arg(&root)
-                .spawn()
-                .map_err(|_| ErrorCodeString::new("WORKSPACE_OPEN_FAILED"))?;
-        }
-
-        #[cfg(target_os = "macos")]
-        {
-            std::process::Command::new("open")
-                .arg(&root)
-                .spawn()
-                .map_err(|_| ErrorCodeString::new("WORKSPACE_OPEN_FAILED"))?;
-        }
-
-        #[cfg(all(unix, not(target_os = "macos")))]
-        {
-            std::process::Command::new("xdg-open")
-                .arg(&root)
-                .spawn()
-                .map_err(|_| ErrorCodeString::new("WORKSPACE_OPEN_FAILED"))?;
-        }
+        std::process::Command::new("explorer")
+            .arg(&root)
+            .spawn()
+            .map_err(|_| ErrorCodeString::new("WORKSPACE_OPEN_FAILED"))?;
 
         Ok(true)
     })
diff --git a/src-tauri/src/data/fs/atomic_write.rs b/src-tauri/src/data/fs/atomic_write.rs
index cd2c589..c20034b 100644
--- a/src-tauri/src/data/fs/atomic_write.rs
+++ b/src-tauri/src/data/fs/atomic_write.rs
@@ -1,12 +1,9 @@
 use std::fs::{self, OpenOptions};
-#[cfg(unix)]
-use std::os::unix::fs::OpenOptionsExt;
 use std::io::{self, Write};
 use std::path::Path;
 use std::time::Duration;
 use uuid::Uuid;
 
-#[cfg(windows)]
 fn replace_platform(from: &Path, to: &Path) -> io::Result<()> {
     use std::iter;
     use std::os::windows::ffi::OsStrExt;
@@ -34,33 +31,19 @@ fn replace_platform(from: &Path, to: &Path) -> io::Result<()> {
     }
 }
 
-#[cfg(not(windows))]
-fn replace_platform(from: &Path, to: &Path) -> io::Result<()> {
-    // On POSIX, rename() overwrites atomically.
-    fs::rename(from, to)
-}
 
-#[cfg(unix)]
-fn best_effort_fsync_dir(dir: &Path) {
-    if let Ok(f) = fs::File::open(dir) {
-        let _ = f.sync_all();
-    }
-}
 
 fn best_effort_fsync_parent_dir(_path: &Path) {
-    #[cfg(unix)]
-    {
-        if let Some(parent) = _path.parent() {
-            best_effort_fsync_dir(parent);
-        }
-    }
+    // Windows-only build: directory fsync semantics differ; file sync_all + MoveFileExW(WRITE_THROUGH) is best-effort.
+    let _ = _path;
 }
 
+
 /// Atomic file write:
 /// - write to temp in same directory
 /// - fsync temp
 /// - atomically replace target with temp
-/// - fsync parent dir (best-effort on unix)
+/// - best-effort fsync parent dir (no-op on Windows-only build)
 pub fn write_atomic(path: &Path, bytes: &[u8]) -> io::Result<()> {
     fn replace_with_retry(from: &Path, to: &Path) -> io::Result<()> {
         let mut last: Option<io::Error> = None;
@@ -98,11 +81,6 @@ pub fn write_atomic(path: &Path, bytes: &[u8]) -> io::Result<()> {
         // 1) write temp
         let mut opts = OpenOptions::new();
         opts.write(true).create_new(true);
-        #[cfg(unix)]
-        {
-            // Secrets should not be readable by other users.
-            opts.mode(0o600);
-        }
         let mut f = opts.open(&tmp_path)?;
         f.write_all(bytes)?;
         f.sync_all()?;
diff --git a/src-tauri/src/data/profiles/paths.rs b/src-tauri/src/data/profiles/paths.rs
index 851bb4d..94a4650 100644
--- a/src-tauri/src/data/profiles/paths.rs
+++ b/src-tauri/src/data/profiles/paths.rs
@@ -20,13 +20,6 @@ fn validate_profile_id(id: &str) -> Result<()> {
     }
 }
 
-#[cfg(unix)]
-fn set_dir_private(path: &Path) -> std::io::Result<()> {
-    use std::os::unix::fs::PermissionsExt;
-    fs::set_permissions(path, fs::Permissions::from_mode(0o700))
-}
-
-#[cfg(not(unix))]
 fn set_dir_private(_path: &Path) -> std::io::Result<()> {
     Ok(())
 }
diff --git a/src-tauri/src/main.rs b/src-tauri/src/main.rs
index c1cb657..6c8d983 100644
--- a/src-tauri/src/main.rs
+++ b/src-tauri/src/main.rs
@@ -1,5 +1,9 @@
 #![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
 
+#[cfg(not(windows))]
+compile_error!("This application is Windows-only.");
+
+
 mod app_state;
 mod commands;
 mod data {
@@ -58,9 +62,7 @@ use services::security_service;
 use tauri::{Manager, WindowEvent};
 use tauri_plugin_dialog::{DialogExt, MessageDialogKind};
 
-#[cfg(windows)]
 use windows::core::Interface;
-#[cfg(windows)]
 use webview2_com::Microsoft::Web::WebView2::Win32::ICoreWebView2Settings4;
 
 fn main() {
@@ -98,7 +100,6 @@ fn main() {
             // Windows/WebView2: disable Chromium "Saved info" (form autofill suggestions)
             // because it breaks dark theme and can expose sensitive suggestions.
             // NOTE: HTML autocomplete="off" is not reliably respected by Chromium/WebView2.
-            #[cfg(windows)]
             {
                 if let Some(main_webview) = app.get_webview_window("main") {
                     let _ = main_webview.with_webview(|webview| unsafe {
diff --git a/src-tauri/src/services/backup_service.rs b/src-tauri/src/services/backup_service.rs
index f608840..5010235 100644
--- a/src-tauri/src/services/backup_service.rs
+++ b/src-tauri/src/services/backup_service.rs
@@ -29,7 +29,6 @@ use crate::error::{ErrorCodeString, Result};
 use crate::services::{security_service, settings_service};
 use crate::types::UserSettings;
 
-#[cfg(windows)]
 fn replace_file_windows(src: &Path, dst: &Path) -> std::io::Result<()> {
     use std::iter;
     use std::os::windows::ffi::OsStrExt;
@@ -171,32 +170,12 @@ fn validate_profile_id_component(profile_id: &str) -> bool {
 
 
 
-
-#[cfg(unix)]
-fn best_effort_fsync_dir(dir: &Path) {
-    #[cfg(unix)]
-    {
-        if let Ok(f) = std::fs::File::open(dir) {
-            let _ = f.sync_all();
-        }
-    }
-}
-
 fn best_effort_fsync_rename_dirs(_src: &Path, _dst: &Path) {
-    #[cfg(unix)]
-    {
-        let sp = _src.parent();
-        let dp = _dst.parent();
-        if let Some(p) = sp {
-            best_effort_fsync_dir(p);
-        }
-        if dp.is_some() && dp != sp {
-            best_effort_fsync_dir(dp.unwrap());
-        }
-    }
+    // Windows-only build: directory fsync is not portable; keep best-effort hook as no-op.
+    let _ = (_src, _dst);
 }
 
-#[cfg(windows)]
+
 fn rename_platform(src: &Path, dst: &Path) -> std::io::Result<()> {
     use std::iter;
     use std::os::windows::ffi::OsStrExt;
@@ -208,10 +187,6 @@ fn rename_platform(src: &Path, dst: &Path) -> std::io::Result<()> {
     if ok == 0 { Err(std::io::Error::last_os_error()) } else { Ok(()) }
 }
 
-#[cfg(not(windows))]
-fn rename_platform(src: &Path, dst: &Path) -> std::io::Result<()> {
-    fs::rename(src, dst)
-}
 
 fn rename_with_retry(src: &Path, dst: &Path) -> std::io::Result<()> {
     use std::time::Duration;
@@ -478,17 +453,7 @@ fn create_archive(
     writer
         .finish()
         .map_err(|_| ErrorCodeString::new("BACKUP_ZIP_WRITE_FAILED"))?;
-
-    let replace_result = {
-        #[cfg(windows)]
-        {
-            replace_file_windows(&tmp_dest, destination)
-        }
-        #[cfg(not(windows))]
-        {
-            fs::rename(&tmp_dest, destination)
-        }
-    };
+    let replace_result = replace_file_windows(&tmp_dest, destination);
 
     if replace_result.is_err() {
         if tmp_dest.exists() {
@@ -954,21 +919,11 @@ fn restore_archive_to_profile(
                     .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?
                     .sync_all()
                     .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-
                 let replaced = (|| {
-                    #[cfg(windows)]
-                    {
-                        replace_file_windows(&tmp, &target)
-                            .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-                        best_effort_fsync_rename_dirs(&tmp, &target);
-                        return Ok(());
-                    }
-                    #[cfg(not(windows))]
-                    {
-                        rename_with_retry(&tmp, &target)
-                            .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
-                        return Ok(());
-                    }
+                    replace_file_windows(&tmp, &target)
+                        .map_err(|_| ErrorCodeString::new("BACKUP_RESTORE_FAILED"))?;
+                    best_effort_fsync_rename_dirs(&tmp, &target);
+                    Ok(())
                 })();
 
                 if replaced.is_err() {
@@ -988,15 +943,10 @@ fn restore_archive_to_profile(
             }
         }
         if moved_vault && vault_backup_path.exists() {
-            #[cfg(windows)]
             {
                 let _ = replace_file_windows(&vault_backup_path, &vault_path);
                 best_effort_fsync_rename_dirs(&vault_backup_path, &vault_path);
             }
-            #[cfg(not(windows))]
-            {
-                let _ = rename_with_retry(&vault_backup_path, &vault_path);
-            }
         } else if !moved_vault && vault_replaced && vault_path.exists() {
             let _ = fs::remove_file(&vault_path);
         }
diff --git a/src-tauri/src/services/clipboard_service.rs b/src-tauri/src/services/clipboard_service.rs
index 446c2d1..358723a 100644
--- a/src-tauri/src/services/clipboard_service.rs
+++ b/src-tauri/src/services/clipboard_service.rs
@@ -1,18 +1,12 @@
-#[cfg(target_os = "windows")]
 use std::ptr;
 
-#[cfg(target_os = "windows")]
 use std::time::Duration;
 
-#[cfg(target_os = "windows")]
 use windows_sys::Win32::Foundation::GetLastError;
-#[cfg(target_os = "windows")]
 use windows_sys::Win32::System::DataExchange::{CloseClipboard, EmptyClipboard, OpenClipboard};
 
-#[cfg(target_os = "windows")]
 struct ClipboardGuard;
 
-#[cfg(target_os = "windows")]
 impl Drop for ClipboardGuard {
     fn drop(&mut self) {
         unsafe {
@@ -24,7 +18,6 @@ impl Drop for ClipboardGuard {
 /// Clears the entire Windows clipboard (all formats).
 /// Uses OpenClipboard -> EmptyClipboard -> CloseClipboard.
 /// Retries because clipboard may be temporarily locked by other processes.
-#[cfg(target_os = "windows")]
 pub fn clear_clipboard_all() -> Result<(), String> {
     const ATTEMPTS: usize = 60;
     const SLEEP_MS: u64 = 25;
diff --git a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
index 76483fa..6a9bd5f 100644
--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -892,38 +892,16 @@ fn recover_incomplete_profile_transitions(
 }
 
 
-
-#[cfg(unix)]
-fn best_effort_fsync_dir(dir: &Path) {
-    if let Ok(f) = std::fs::File::open(dir) {
-        let _ = f.sync_all();
-    }
-}
-
 fn best_effort_fsync_parent_dir(_path: &Path) {
-    #[cfg(unix)]
-    {
-        if let Some(parent) = _path.parent() {
-            best_effort_fsync_dir(parent);
-        }
-    }
+    // Windows-only build: directory fsync not portable; keep hook as no-op.
+    let _ = _path;
 }
 
 fn best_effort_fsync_rename_dirs(_from: &Path, _to: &Path) {
-    #[cfg(unix)]
-    {
-        if let Some(p) = _from.parent() {
-            best_effort_fsync_dir(p);
-        }
-        let from_parent = _from.parent();
-        let to_parent = _to.parent();
-        if to_parent.is_some() && to_parent != from_parent {
-            best_effort_fsync_dir(to_parent.unwrap());
-        }
-    }
+    let _ = (_from, _to);
 }
 
-#[cfg(windows)]
+
 fn rename_platform(from: &Path, to: &Path) -> io::Result<()> {
     use std::iter;
     use std::os::windows::ffi::OsStrExt;
@@ -940,10 +918,6 @@ fn rename_platform(from: &Path, to: &Path) -> io::Result<()> {
     }
 }
 
-#[cfg(not(windows))]
-fn rename_platform(from: &Path, to: &Path) -> io::Result<()> {
-    std::fs::rename(from, to)
-}
 
 fn rename_retry(from: &Path, to: &Path, attempts: u32, base_delay: Duration) -> io::Result<()> {
     let mut i = 0;
@@ -987,7 +961,6 @@ fn remove_file_retry(path: &Path, attempts: u32, base_delay: Duration) -> io::Re
     }
 }
 
-#[cfg(windows)]
 fn replace_platform(from: &Path, to: &Path) -> io::Result<()> {
     use std::iter;
     use std::os::windows::ffi::OsStrExt;
@@ -1012,11 +985,6 @@ fn replace_platform(from: &Path, to: &Path) -> io::Result<()> {
     }
 }
 
-#[cfg(not(windows))]
-fn replace_platform(from: &Path, to: &Path) -> io::Result<()> {
-    // On POSIX, rename() overwrites atomically.
-    std::fs::rename(from, to)
-}
 
 fn replace_file_retry(from: &Path, to: &Path, attempts: u32, base_delay: Duration) -> io::Result<()> {
     let mut i = 0;
