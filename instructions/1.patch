diff -ruN base/Password-Manager-by-ChatGPT-2222222222/src-tauri/Cargo.toml mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/Cargo.toml
--- base/Password-Manager-by-ChatGPT-2222222222/src-tauri/Cargo.toml	2026-01-19 06:37:46.000000000 +0000
+++ mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/Cargo.toml	2026-01-19 11:18:12.978627982 +0000
@@ -36,6 +36,8 @@
   "Win32_Foundation",
   "Win32_Storage_FileSystem",
   "Win32_System_DataExchange",
+  "Win32_System_Memory",
+  "Win32_Security_Cryptography",
   "Win32_UI_WindowsAndMessaging"
 ] }
 webview2-com = "0.38.0"
diff -ruN base/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/crypto/dpapi.rs mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/crypto/dpapi.rs
--- base/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/crypto/dpapi.rs	1970-01-01 00:00:00.000000000 +0000
+++ mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/crypto/dpapi.rs	2026-01-19 11:35:00.346701293 +0000
@@ -0,0 +1,115 @@
+use crate::error::{ErrorCodeString, Result};
+
+#[cfg(windows)]
+pub fn protect(plaintext: &[u8], entropy: Option<&[u8]>) -> Result<Vec<u8>> {
+    use std::ptr;
+    use windows_sys::Win32::Security::Cryptography::{
+        CryptProtectData, DATA_BLOB, CRYPTPROTECT_UI_FORBIDDEN,
+    };
+    use windows_sys::Win32::System::Memory::LocalFree;
+
+    unsafe {
+        let mut in_blob = DATA_BLOB {
+            cbData: plaintext.len() as u32,
+            pbData: plaintext.as_ptr() as *mut u8,
+        };
+        let mut out_blob = DATA_BLOB {
+            cbData: 0,
+            pbData: ptr::null_mut(),
+        };
+
+        let mut ent_blob = DATA_BLOB {
+            cbData: 0,
+            pbData: ptr::null_mut(),
+        };
+        let ent_ptr: *mut DATA_BLOB = match entropy {
+            Some(e) if !e.is_empty() => {
+                ent_blob.cbData = e.len() as u32;
+                ent_blob.pbData = e.as_ptr() as *mut u8;
+                &mut ent_blob as *mut DATA_BLOB
+            }
+            _ => ptr::null_mut(),
+        };
+
+        let ok = CryptProtectData(
+            &mut in_blob as *mut DATA_BLOB,
+            ptr::null(),
+            ent_ptr,
+            ptr::null_mut(),
+            ptr::null_mut(),
+            CRYPTPROTECT_UI_FORBIDDEN,
+            &mut out_blob as *mut DATA_BLOB,
+        );
+
+        if ok == 0 {
+            return Err(ErrorCodeString::new("DPAPI_PROTECT_FAILED"));
+        }
+
+        let out = std::slice::from_raw_parts(out_blob.pbData as *const u8, out_blob.cbData as usize)
+            .to_vec();
+        let _ = LocalFree(out_blob.pbData as isize);
+        Ok(out)
+    }
+}
+
+#[cfg(windows)]
+pub fn unprotect(ciphertext: &[u8], entropy: Option<&[u8]>) -> Result<Vec<u8>> {
+    use std::ptr;
+    use windows_sys::Win32::Security::Cryptography::{
+        CryptUnprotectData, DATA_BLOB, CRYPTPROTECT_UI_FORBIDDEN,
+    };
+    use windows_sys::Win32::System::Memory::LocalFree;
+
+    unsafe {
+        let mut in_blob = DATA_BLOB {
+            cbData: ciphertext.len() as u32,
+            pbData: ciphertext.as_ptr() as *mut u8,
+        };
+        let mut out_blob = DATA_BLOB {
+            cbData: 0,
+            pbData: ptr::null_mut(),
+        };
+
+        let mut ent_blob = DATA_BLOB {
+            cbData: 0,
+            pbData: ptr::null_mut(),
+        };
+        let ent_ptr: *mut DATA_BLOB = match entropy {
+            Some(e) if !e.is_empty() => {
+                ent_blob.cbData = e.len() as u32;
+                ent_blob.pbData = e.as_ptr() as *mut u8;
+                &mut ent_blob as *mut DATA_BLOB
+            }
+            _ => ptr::null_mut(),
+        };
+
+        let ok = CryptUnprotectData(
+            &mut in_blob as *mut DATA_BLOB,
+            ptr::null_mut(),
+            ent_ptr,
+            ptr::null_mut(),
+            ptr::null_mut(),
+            CRYPTPROTECT_UI_FORBIDDEN,
+            &mut out_blob as *mut DATA_BLOB,
+        );
+
+        if ok == 0 {
+            return Err(ErrorCodeString::new("DPAPI_UNPROTECT_FAILED"));
+        }
+
+        let out = std::slice::from_raw_parts(out_blob.pbData as *const u8, out_blob.cbData as usize)
+            .to_vec();
+        let _ = LocalFree(out_blob.pbData as isize);
+        Ok(out)
+    }
+}
+
+#[cfg(not(windows))]
+pub fn protect(_plaintext: &[u8], _entropy: Option<&[u8]>) -> Result<Vec<u8>> {
+    Err(ErrorCodeString::new("WINDOWS_ONLY"))
+}
+
+#[cfg(not(windows))]
+pub fn unprotect(_ciphertext: &[u8], _entropy: Option<&[u8]>) -> Result<Vec<u8>> {
+    Err(ErrorCodeString::new("WINDOWS_ONLY"))
+}
Binary files base/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/crypto/master_key.rs and mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/crypto/master_key.rs differ
diff -ruN base/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/profiles/paths.rs mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/profiles/paths.rs
--- base/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/profiles/paths.rs	2026-01-19 06:37:46.000000000 +0000
+++ mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/data/profiles/paths.rs	2026-01-19 11:19:40.158639514 +0000
@@ -127,6 +127,14 @@
     Ok(profile_dir(sp, profile_id)?.join("key_check.bin"))
 }
 
+pub fn vault_key_path(sp: &StoragePaths, profile_id: &str) -> Result<PathBuf> {
+    Ok(profile_dir(sp, profile_id)?.join("vault_key.bin"))
+}
+
+pub fn dpapi_key_path(sp: &StoragePaths, profile_id: &str) -> Result<PathBuf> {
+    Ok(profile_dir(sp, profile_id)?.join("dpapi_key.bin"))
+}
+
 pub fn attachment_file_path(
     sp: &StoragePaths,
     profile_id: &str,
diff -ruN base/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/main.rs mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/main.rs
--- base/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/main.rs	2026-01-19 06:37:46.000000000 +0000
+++ mod/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/main.rs	2026-01-19 11:18:58.822916261 +0000
@@ -16,6 +16,8 @@
     }
     pub mod crypto {
         pub mod cipher;
+        pub mod dpapi;
+        pub mod master_key;
         pub mod kdf;
         pub mod key_check;
     }
