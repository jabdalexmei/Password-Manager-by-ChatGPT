--- a/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/commands/security.rs	2026-01-19 05:33:53.000000000 +0000
+++ b/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/commands/security.rs	2026-01-19 05:46:29.125621176 +0000
@@ -6,6 +6,7 @@
 use crate::error::{ErrorCodeString, Result};
 use crate::services::security_service;
 use crate::types::ProfileMeta;
+use zeroize::Zeroizing;
 
 #[tauri::command]
 pub async fn login_vault(
@@ -16,7 +17,8 @@
     let app_state = state.inner().clone();
 
     tauri::async_runtime::spawn_blocking(move || {
-        security_service::login_vault(&id, password, &app_state)
+        let password = password.map(Zeroizing::new);
+        security_service::login_vault(&id, password.as_ref().map(|p| p.as_str()), &app_state)
     })
     .await
     .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
@@ -48,7 +50,8 @@
 ) -> Result<ProfileMeta> {
     let app_state = state.inner().clone();
     tauri::async_runtime::spawn_blocking(move || {
-        security_service::set_profile_password(&id, &password, &app_state)
+        let password = Zeroizing::new(password);
+        security_service::set_profile_password(&id, password.as_str(), &app_state)
     })
     .await
     .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
@@ -62,7 +65,8 @@
 ) -> Result<bool> {
     let app_state = state.inner().clone();
     tauri::async_runtime::spawn_blocking(move || {
-        security_service::change_profile_password(&id, &password, &app_state)
+        let password = Zeroizing::new(password);
+        security_service::change_profile_password(&id, password.as_str(), &app_state)
     })
     .await
     .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
--- a/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/services/security_service.rs	2026-01-19 05:33:53.000000000 +0000
+++ b/Password-Manager-by-ChatGPT-2222222222/src-tauri/src/services/security_service.rs	2026-01-19 05:57:26.733437328 +0000
@@ -12,6 +12,7 @@
 use rusqlite::serialize::OwnedData;
 use rusqlite::DatabaseName;
 use zeroize::{Zeroize, Zeroizing};
+use walkdir::WalkDir;
 
 use crate::app_state::{AppState, VaultSession};
 use crate::data::crypto::{cipher, kdf, key_check};
@@ -353,7 +354,8 @@
         if is_dir_nonempty(backup_root).unwrap_or(false) {
             recover_incomplete_profile_transitions(storage_paths, profile_id, profile_name)?;
         }
-        let _ = std::fs::remove_dir_all(backup_root);
+        remove_dir_all_retry(backup_root, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
     }
 
     std::fs::create_dir_all(backup_root).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
@@ -379,11 +381,155 @@
     write_atomic(&marker_path, b"1").map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
 }
 
+
+fn best_effort_encrypt_set_password_backups(
+    profile_id: &str,
+    key: &[u8; cipher::KEY_LEN],
+    backup_root: &Path,
+) {
+    // If cleanup fails after a successful set-password transition, backup_root may still contain
+    // plaintext copies of the old vault/attachments. We cannot guarantee secure deletion on modern
+    // filesystems/SSDs, so we best-effort *cryptographically* protect any leftover plaintext by
+    // encrypting it in place.
+
+    // Encrypt plaintext vault backup if present.
+    let vault_backup_path = backup_root.join("vault.db.bak");
+    if vault_backup_path.exists()
+        && !file_has_prefix(&vault_backup_path, &cipher::PM_ENC_MAGIC)
+        && file_has_sqlite_magic(&vault_backup_path)
+    {
+        match std::fs::read(&vault_backup_path) {
+            Ok(plain) => match cipher::encrypt_vault_blob(profile_id, key, &plain) {
+                Ok(blob) => {
+                    if let Err(e) = write_atomic(&vault_backup_path, &blob) {
+                        log::warn!(
+                            "[SECURITY][best_effort_encrypt_set_password_backups] profile_id={} action=encrypt_vault_backup_failed path={:?} err={}",
+                            profile_id,
+                            vault_backup_path,
+                            e
+                        );
+                    }
+                }
+                Err(e) => {
+                    log::warn!(
+                        "[SECURITY][best_effort_encrypt_set_password_backups] profile_id={} action=encrypt_vault_backup_failed path={:?} err={:?}",
+                        profile_id,
+                        vault_backup_path,
+                        e
+                    );
+                }
+            },
+            Err(e) => {
+                log::warn!(
+                    "[SECURITY][best_effort_encrypt_set_password_backups] profile_id={} action=read_vault_backup_failed path={:?} err={}",
+                    profile_id,
+                    vault_backup_path,
+                    e
+                );
+            }
+        }
+    }
+
+    // Encrypt any plaintext attachment backups in place (if present).
+    let attachments_plain_backup_dir = backup_root.join("attachments_plain");
+    if attachments_plain_backup_dir.exists() {
+        for entry in WalkDir::new(&attachments_plain_backup_dir)
+            .into_iter()
+            .filter_map(|e| e.ok())
+        {
+            if !entry.file_type().is_file() {
+                continue;
+            }
+            let path = entry.path();
+            let file_name = match path.file_name().and_then(|n| n.to_str()) {
+                Some(n) => n,
+                None => continue,
+            };
+            if !file_name.ends_with(".bin") {
+                continue;
+            }
+            if file_has_prefix(path, &cipher::PM_ENC_MAGIC) {
+                continue;
+            }
+            let attachment_id = match attachment_id_from_path(path) {
+                Some(id) => id,
+                None => continue,
+            };
+
+            match std::fs::read(path) {
+                Ok(plain) => match cipher::encrypt_attachment_blob(profile_id, &attachment_id, key, &plain) {
+                    Ok(blob) => {
+                        if let Err(e) = write_atomic(path, &blob) {
+                            log::warn!(
+                                "[SECURITY][best_effort_encrypt_set_password_backups] profile_id={} action=encrypt_attachment_backup_failed attachment_id={} path={:?} err={}",
+                                profile_id,
+                                attachment_id,
+                                path,
+                                e
+                            );
+                        }
+                    }
+                    Err(e) => {
+                        log::warn!(
+                            "[SECURITY][best_effort_encrypt_set_password_backups] profile_id={} action=encrypt_attachment_backup_failed attachment_id={} path={:?} err={:?}",
+                            profile_id,
+                            attachment_id,
+                            path,
+                            e
+                        );
+                    }
+                },
+                Err(e) => {
+                    log::warn!(
+                        "[SECURITY][best_effort_encrypt_set_password_backups] profile_id={} action=read_attachment_backup_failed attachment_id={} path={:?} err={}",
+                        profile_id,
+                        attachment_id,
+                        path,
+                        e
+                    );
+                }
+            }
+        }
+    }
+}
+
+fn best_effort_encrypt_set_password_backups_with_password(
+    storage_paths: &crate::data::storage_paths::StoragePaths,
+    profile_id: &str,
+    password: &str,
+    backup_root: &Path,
+) {
+    let salt_path = match kdf_salt_path(storage_paths, profile_id) {
+        Ok(p) => p,
+        Err(_) => return,
+    };
+    let salt = match std::fs::read(&salt_path) {
+        Ok(s) => s,
+        Err(_) => return,
+    };
+    if salt.len() != 16 {
+        return;
+    }
+
+    let key = match kdf::derive_master_key(password, &salt) {
+        Ok(k) => Zeroizing::new(k),
+        Err(_) => return,
+    };
+
+    let ok = key_check::verify_key_check_file(storage_paths, profile_id, &*key).unwrap_or(false);
+    if !ok {
+        return;
+    }
+
+    best_effort_encrypt_set_password_backups(profile_id, &*key, backup_root);
+}
+
 fn recover_set_password_transition(
     storage_paths: &crate::data::storage_paths::StoragePaths,
     profile_id: &str,
     profile_name: &str,
     backup_root: &Path,
+    maybe_password: Option<&str>,
 ) -> Result<()> {
     if !is_dir_nonempty(backup_root).unwrap_or(false) {
         return Ok(());
@@ -434,8 +580,8 @@
             // Complete attachments swap if needed.
             if attachments_dir.exists() {
                 if attachments_plain_backup_dir.exists() {
-                    std::fs::remove_dir_all(&attachments_plain_backup_dir)
-                        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+                    remove_dir_all_retry(&attachments_plain_backup_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
                 }
                 rename_retry(
                     &attachments_dir,
@@ -447,8 +593,8 @@
             }
 
             if attachments_dir.exists() {
-                std::fs::remove_dir_all(&attachments_dir)
-                    .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+                remove_dir_all_retry(&attachments_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
             }
 
             if let Err(e) = rename_retry(
@@ -501,7 +647,25 @@
         // Remove any stale SQLite sidecars (WAL/SHM/journal) that could have been left from a prior plaintext vault.
         cleanup_sqlite_sidecars(&vault_path);
 
-        let _ = std::fs::remove_dir_all(backup_root);
+        // Cleanup backup root. If deletion fails and we have the user's password,
+        // best-effort encrypt any leftover plaintext backups to avoid data-at-rest leakage.
+        if let Err(e) = remove_dir_all_retry(backup_root, 40, Duration::from_millis(50)) {
+            log::warn!(
+                "[SECURITY][recover_set_password_transition] profile_id={} action=cleanup_failed backup_root={:?} err={}",
+                profile_id,
+                backup_root,
+                e
+            );
+            if let Some(pwd) = maybe_password {
+                best_effort_encrypt_set_password_backups_with_password(
+                    storage_paths,
+                    profile_id,
+                    pwd,
+                    backup_root,
+                );
+                let _ = remove_dir_all_retry(backup_root, 40, Duration::from_millis(50));
+            }
+        }
         return Ok(());
     }
 
@@ -547,8 +711,8 @@
 
     if attachments_plain_backup_dir.exists() {
         if attachments_dir.exists() {
-            std::fs::remove_dir_all(&attachments_dir)
-                .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+            remove_dir_all_retry(&attachments_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
         }
         rename_retry(
             &attachments_plain_backup_dir,
@@ -561,13 +725,13 @@
 
     // Ensure staging dir does not survive a rollback.
     if attachments_staging_dir.exists() {
-        std::fs::remove_dir_all(&attachments_staging_dir)
-            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+        remove_dir_all_retry(&attachments_staging_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
     }
 
     registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, false)?;
     clear_pool(profile_id);
-    let _ = std::fs::remove_dir_all(backup_root);
+    best_effort_remove_dir_all_retry(backup_root, 40, Duration::from_millis(50));
     Ok(())
 }
 
@@ -637,14 +801,14 @@
                     .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
                 } else {
                     // Backup already exists; clear current dir to make room for staging swap.
-                    std::fs::remove_dir_all(&attachments_dir)
-                        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+                    remove_dir_all_retry(&attachments_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
                 }
             }
 
             if attachments_dir.exists() {
-                std::fs::remove_dir_all(&attachments_dir)
-                    .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+                remove_dir_all_retry(&attachments_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
             }
 
             if let Err(e) = rename_retry(
@@ -697,7 +861,8 @@
         // Remove any stale SQLite sidecars (WAL/SHM/journal) that could have been left from a prior plaintext vault.
         cleanup_sqlite_sidecars(&vault_path);
 
-        let _ = std::fs::remove_dir_all(backup_root);
+        // Cleanup backup root (best-effort).
+        best_effort_remove_dir_all_retry(backup_root, 40, Duration::from_millis(50));
         return Ok(());
     }
 
@@ -731,8 +896,8 @@
 
     if attachments_backup_dir.exists() {
         if attachments_dir.exists() {
-            std::fs::remove_dir_all(&attachments_dir)
-                .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+            remove_dir_all_retry(&attachments_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
         }
         rename_retry(
             &attachments_backup_dir,
@@ -745,14 +910,14 @@
 
     // Remove any staging dir left from a partially completed swap.
     if attachments_staging_dir.exists() {
-        std::fs::remove_dir_all(&attachments_staging_dir)
-            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+        remove_dir_all_retry(&attachments_staging_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
     }
 
     // After rollback, the profile is still protected.
     registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, true)?;
     clear_pool(profile_id);
-    let _ = std::fs::remove_dir_all(backup_root);
+    best_effort_remove_dir_all_retry(backup_root, 40, Duration::from_millis(50));
     Ok(())
 }
 
@@ -804,8 +969,8 @@
             if attachments_plain_staging_dir.exists() {
                 if attachments_dir.exists() {
                     if attachments_encrypted_backup_dir.exists() {
-                        std::fs::remove_dir_all(&attachments_encrypted_backup_dir)
-                            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+                        remove_dir_all_retry(&attachments_encrypted_backup_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
                     }
                     rename_retry(
                         &attachments_dir,
@@ -817,8 +982,8 @@
                 }
 
                 if attachments_dir.exists() {
-                    std::fs::remove_dir_all(&attachments_dir)
-                        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+                    remove_dir_all_retry(&attachments_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
                 }
 
                 if let Err(e) = rename_retry(
@@ -884,7 +1049,7 @@
 
                 registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, false)?;
                 clear_pool(profile_id);
-                let _ = std::fs::remove_dir_all(backup_root);
+                best_effort_remove_dir_all_retry(backup_root, 40, Duration::from_millis(50));
                 return Ok(());
             }
         }
@@ -912,8 +1077,8 @@
 
     if attachments_encrypted_backup_dir.exists() {
         if attachments_dir.exists() {
-            std::fs::remove_dir_all(&attachments_dir)
-                .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+            remove_dir_all_retry(&attachments_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
         }
         rename_retry(
             &attachments_encrypted_backup_dir,
@@ -926,29 +1091,30 @@
 
     // Remove any leftover plain staging dir.
     if attachments_plain_staging_dir.exists() {
-        std::fs::remove_dir_all(&attachments_plain_staging_dir)
-            .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+        remove_dir_all_retry(&attachments_plain_staging_dir, 40, Duration::from_millis(50))
+            .map_err(|_| ErrorCodeString::new(\"PROFILE_STORAGE_WRITE\"))?;
     }
 
     registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, true)?;
     clear_pool(profile_id);
-    let _ = std::fs::remove_dir_all(backup_root);
+    best_effort_remove_dir_all_retry(backup_root, 40, Duration::from_millis(50));
     Ok(())
 }
 
 
 
-fn recover_incomplete_profile_transitions(
+fn recover_incomplete_profile_transitions_with_password(
     storage_paths: &crate::data::storage_paths::StoragePaths,
     profile_id: &str,
     profile_name: &str,
+    maybe_password: Option<&str>,
 ) -> Result<()> {
     let profile_root = profile_dir(storage_paths, profile_id)?;
     let tmp_root = profile_root.join("tmp");
 
     let set_root = tmp_root.join("set_password_backup");
     if set_root.exists() {
-        recover_set_password_transition(storage_paths, profile_id, profile_name, &set_root)?;
+        recover_set_password_transition(storage_paths, profile_id, profile_name, &set_root, maybe_password)?;
     }
 
     let change_root = tmp_root.join("change_password_backup");
@@ -964,6 +1130,14 @@
     Ok(())
 }
 
+fn recover_incomplete_profile_transitions(
+    storage_paths: &crate::data::storage_paths::StoragePaths,
+    profile_id: &str,
+    profile_name: &str,
+) -> Result<()> {
+    recover_incomplete_profile_transitions_with_password(storage_paths, profile_id, profile_name, None)
+}
+
 fn best_effort_fsync_parent_dir(_path: &Path) {
     // Windows-only build: directory fsync not portable; keep hook as no-op.
     let _ = _path;
@@ -1033,6 +1207,38 @@
     }
 }
 
+
+fn remove_dir_all_retry(path: &Path, attempts: u32, base_delay: Duration) -> io::Result<()> {
+    let mut i = 0;
+    loop {
+        match std::fs::remove_dir_all(path) {
+            Ok(()) => {
+                best_effort_fsync_parent_dir(path);
+                return Ok(());
+            }
+            Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(()),
+            Err(e) => {
+                i += 1;
+                if i >= attempts {
+                    return Err(e);
+                }
+                let backoff_ms = base_delay.as_millis() as u64 * i as u64;
+                std::thread::sleep(Duration::from_millis(backoff_ms.max(25).min(1500)));
+            }
+        }
+    }
+}
+
+fn best_effort_remove_dir_all_retry(path: &Path, attempts: u32, base_delay: Duration) {
+    if let Err(e) = remove_dir_all_retry(path, attempts, base_delay) {
+        log::warn!(
+            "[SECURITY][best_effort_remove_dir_all_retry] path={:?} err={}",
+            path,
+            e
+        );
+    }
+}
+
 fn replace_platform(from: &Path, to: &Path) -> io::Result<()> {
     use std::iter;
     use std::os::windows::ffi::OsStrExt;
@@ -1081,7 +1287,7 @@
 
 fn prepare_empty_dir(path: &Path) -> Result<()> {
     if path.exists() {
-        std::fs::remove_dir_all(path)
+        remove_dir_all_retry(path, 40, Duration::from_millis(50))
             .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
     }
     std::fs::create_dir_all(path)
@@ -1171,24 +1377,24 @@
     Ok(())
 }
 
-pub fn login_vault(id: &str, password: Option<String>, state: &Arc<AppState>) -> Result<bool> {
+pub fn login_vault(id: &str, password: Option<&str>, state: &Arc<AppState>) -> Result<bool> {
     let storage_paths = state.get_storage_paths()?;
     let mut profile = registry::get_profile(&storage_paths, id)?
         .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
 
     // If a previous set/change/remove password operation crashed mid-flight,
     // recover the on-disk profile state before attempting to open the vault.
-    recover_incomplete_profile_transitions(&storage_paths, id, &profile.name)?;
+    recover_incomplete_profile_transitions_with_password(&storage_paths, id, &profile.name, password)?;
     profile = registry::get_profile(&storage_paths, id)?
         .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
 
-    let pwd = password.unwrap_or_default();
+    let pwd = password.unwrap_or("");
     let is_passwordless = !profile.has_password;
 
     if is_passwordless {
         init_database_passwordless(&storage_paths, id)?;
     } else {
-        open_protected_vault_session(id, &pwd, &storage_paths, state)?;
+        open_protected_vault_session(id, pwd, &storage_paths, state)?;
     }
 
     if let Ok(mut active) = state.active_profile.lock() {
@@ -1360,7 +1566,7 @@
         drain_and_drop_profile_pools(id, Duration::from_secs(5));
         clear_pool(id);
 
-        recover_incomplete_profile_transitions(&storage_paths, id, &profile.name)?;
+        recover_incomplete_profile_transitions_with_password(&storage_paths, id, &profile.name, password)?;
 
         let vault_path = vault_db_path(&storage_paths, id)?;
         if !vault_path.exists() {
@@ -1542,7 +1748,7 @@
             let _ = std::fs::remove_file(&rb.key_check_new_path);
 
             if rb.attachments_swapped {
-                let _ = std::fs::remove_dir_all(&rb.attachments_dir);
+                best_effort_remove_dir_all_retry(&rb.attachments_dir, 40, Duration::from_millis(50));
                 let _ = rename_retry(&rb.attachments_backup_dir, &rb.attachments_dir, 20, Duration::from_millis(50));
             }
 
@@ -1642,7 +1848,7 @@
 
         // Swap attachments dir to encrypted form.
         if attachments_backup_dir.exists() {
-            let _ = std::fs::remove_dir_all(&attachments_backup_dir);
+            remove_dir_all_retry(&attachments_backup_dir, 40, Duration::from_millis(50)).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
         }
         rename_retry(&attachments_dir, &attachments_backup_dir, 20, Duration::from_millis(50))
             .map_err(|_| {
@@ -1693,9 +1899,25 @@
             return Err(err);
         }
 
+        // Now that the vault file has been replaced by an encrypted blob, old WAL/SHM sidecars are stale.
+        cleanup_sqlite_sidecars(&vault_path);
+
+        // Delete the transition backup root. If it cannot be deleted (e.g. transient AV lock),
+        // best-effort encrypt the leftover plaintext backups (vault.db.bak / attachments_plain)
+        // so a stuck backup directory does not become a plaintext data-at-rest leak.
+        if let Err(e) = remove_dir_all_retry(&backup_root, 40, Duration::from_millis(50)) {
+            log::warn!(
+                "[SECURITY][set_profile_password] profile_id={} action=cleanup_failed backup_root={:?} err={}",
+                id,
+                backup_root,
+                e
+            );
+            best_effort_encrypt_set_password_backups(id, &*key, &backup_root);
+            best_effort_remove_dir_all_retry(&backup_root, 40, Duration::from_millis(50));
+        }
+
         // Switch runtime session to protected in-memory session so app stays unlocked.
         // (mem_conn already validated above)
-
         {
             let mut session = state
                 .vault_session
@@ -1723,7 +1945,7 @@
         // Now that the vault file has been replaced by an encrypted blob, old WAL/SHM sidecars are stale.
         cleanup_sqlite_sidecars(&vault_path);
 
-        let _ = std::fs::remove_dir_all(&backup_root);
+        best_effort_remove_dir_all_retry(&backup_root, 40, Duration::from_millis(50));
 
         Ok(meta)
     })();
@@ -1781,7 +2003,7 @@
     drain_and_drop_profile_pools(id, Duration::from_secs(5));
     clear_pool(id);
 
-    recover_incomplete_profile_transitions(&storage_paths, id, &profile.name)?;
+    recover_incomplete_profile_transitions_with_password(&storage_paths, id, &profile.name, password)?;
 
     ensure_profile_dirs(&storage_paths, id)
         .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
@@ -1847,7 +2069,7 @@
         let _ = std::fs::remove_file(&rb.key_check_new_path);
 
         if rb.attachments_swapped {
-            let _ = std::fs::remove_dir_all(&rb.attachments_dir);
+            best_effort_remove_dir_all_retry(&rb.attachments_dir, 40, Duration::from_millis(50));
             let _ = rename_retry(&rb.attachments_backup_dir, &rb.attachments_dir, 20, Duration::from_millis(50));
         }
 
@@ -1923,7 +2145,7 @@
 
     // Swap attachments dir.
     if attachments_backup_dir.exists() {
-        let _ = std::fs::remove_dir_all(&attachments_backup_dir);
+        remove_dir_all_retry(&attachments_backup_dir, 40, Duration::from_millis(50)).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
     }
     rename_retry(&attachments_dir, &attachments_backup_dir, 20, Duration::from_millis(50))
         .map_err(|_| {
@@ -1988,7 +2210,7 @@
         s.key = new_key;
     }
 
-    let _ = std::fs::remove_dir_all(&backup_root);
+    best_effort_remove_dir_all_retry(&backup_root, 40, Duration::from_millis(50));
     Ok(true)
 }
 
@@ -2023,7 +2245,7 @@
     );
 
     if rb.attachments_swapped {
-        let _ = std::fs::remove_dir_all(&rb.attachments_dir);
+        best_effort_remove_dir_all_retry(&rb.attachments_dir, 40, Duration::from_millis(50));
         let _ = rename_retry(&rb.attachments_backup_dir, &rb.attachments_dir, 20, Duration::from_millis(50));
     }
 
@@ -2086,7 +2308,7 @@
     drain_and_drop_profile_pools(id, Duration::from_secs(5));
     clear_pool(id);
 
-    recover_incomplete_profile_transitions(&storage_paths, id, &profile.name)?;
+    recover_incomplete_profile_transitions_with_password(&storage_paths, id, &profile.name, password)?;
 
     let profile_root = profile_dir(&storage_paths, id)?;
     let backup_root = profile_root.join("tmp").join("remove_password_backup");
@@ -2178,7 +2400,7 @@
     // Attachments migration to plaintext.
     let staging_dir = backup_root.join("attachments_plain_staging");
     if staging_dir.exists() {
-        let _ = std::fs::remove_dir_all(&staging_dir);
+        best_effort_remove_dir_all_retry(&staging_dir, 40, Duration::from_millis(50));
     }
     if std::fs::create_dir_all(&staging_dir).is_err() {
         rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
@@ -2234,7 +2456,7 @@
         }
     }
     if attachments_backup_dir.exists() {
-        let _ = std::fs::remove_dir_all(&attachments_backup_dir);
+        remove_dir_all_retry(&attachments_backup_dir, 40, Duration::from_millis(50)).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
     }
     if rename_retry(&attachments_dir, &attachments_backup_dir, 20, Duration::from_millis(50)).is_err() {
         rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
@@ -2282,7 +2504,7 @@
     *session_guard = None;
     clear_pool(id);
 
-    let _ = std::fs::remove_dir_all(&backup_root);
+    best_effort_remove_dir_all_retry(&backup_root, 40, Duration::from_millis(50));
     Ok(updated.into())
 }
 
