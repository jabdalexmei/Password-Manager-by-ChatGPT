diff --git a/src-tauri/src/app_state.rs b/src-tauri/src/app_state.rs
--- a/src-tauri/src/app_state.rs
+++ b/src-tauri/src/app_state.rs
@@ -91,6 +91,26 @@ impl AppState {
     }
 
     pub fn set_workspace_root(&self, workspace_root: std::path::PathBuf) -> Result<()> {
+        // If the requested workspace is already active in this process, don't try to re-lock it.
+        // On Windows, re-acquiring the same lock from the same process can fail (WORKSPACE_ALREADY_IN_USE).
+        {
+            let storage_paths = self
+                .storage_paths
+                .lock()
+                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+
+            if let Ok(current) = storage_paths.workspace_root() {
+                let current_can =
+                    std::fs::canonicalize(current).unwrap_or_else(|_| current.clone());
+                let requested_can = std::fs::canonicalize(&workspace_root)
+                    .unwrap_or_else(|_| workspace_root.clone());
+
+                if current_can == requested_can {
+                    return Ok(());
+                }
+            }
+        }
+
         // Preflight create to ensure workspace_root exists before we attempt to lock.
         // This is safe even if locking fails (no user data is modified here).
         let profiles_dir = workspace_root.join("Profiles");
         std::fs::create_dir_all(&profiles_dir)
             .map_err(|_| ErrorCodeString::new("WORKSPACE_PROFILES_CREATE_FAILED"))?;

diff --git a/src-tauri/src/commands/workspace.rs b/src-tauri/src/commands/workspace.rs
--- a/src-tauri/src/commands/workspace.rs
+++ b/src-tauri/src/commands/workspace.rs
@@ -194,6 +194,23 @@ pub async fn workspace_select(
 
         let resolved = resolve_workspace_path(&app_dir, &record);
         validate_workspace_root(&resolved)?;
+
+        // If user selects the already-open workspace, treat it as a no-op.
+        // This avoids re-locking .pm-workspace.lock (which can fail on Windows) and avoids
+        // unnecessarily logging out an active profile/session.
+        if registry.active_workspace_id.as_deref() == Some(&id) {
+            if let Ok(sp) = app_state.get_storage_paths() {
+                if let Ok(current) = sp.workspace_root() {
+                    let current_can = std::fs::canonicalize(current)
+                        .unwrap_or_else(|_| current.clone());
+                    let resolved_can = std::fs::canonicalize(&resolved)
+                        .unwrap_or_else(|_| resolved.clone());
+                    if current_can == resolved_can {
+                        return Ok(true);
+                    }
+                }
+            }
+        }
         app_state.logout_and_cleanup()?;
         app_state.set_workspace_root(resolved)?;
         registry.active_workspace_id = Some(id);
         if let Err(err) = save_registry(&app_dir, &registry) {
