
### Patch 1 — защита от path traversal через `profile_id`

```diff
*** Begin Patch
*** Update File: src-tauri/src/data/profiles/paths.rs
@@
 use std::fs;
-use std::path::PathBuf;
+use std::path::{Component, Path, PathBuf};
 
 use crate::data::storage_paths::StoragePaths;
 use crate::error::{ErrorCodeString, Result};
 
+fn validate_profile_id(id: &str) -> Result<()> {
+    if id.trim().is_empty() {
+        return Err(ErrorCodeString::new("PROFILE_ID_INVALID"));
+    }
+
+    // Profile IDs are used as directory names under the workspace storage.
+    // Reject anything that looks like a path (separators, prefixes, parent dirs, etc).
+    let p = Path::new(id);
+    let mut components = p.components();
+
+    match (components.next(), components.next()) {
+        (Some(Component::Normal(_)), None) => Ok(()),
+        _ => Err(ErrorCodeString::new("PROFILE_ID_INVALID")),
+    }
+}
+
+
 pub fn profiles_root(sp: &StoragePaths) -> Result<PathBuf> {
     Ok(sp.profiles_root()?.to_path_buf())
 }
@@
 pub fn profile_dir(sp: &StoragePaths, id: &str) -> Result<PathBuf> {
+    validate_profile_id(id)?;
     Ok(profiles_root(sp)?.join(id))
 }
*** End Patch
```

```diff
*** Begin Patch
*** Update File: src-tauri/src/services/backup_service.rs
@@
 fn validate_zip_entry_rel_path_windows(rel: &Path) -> bool {
@@
     true
 }
 
+fn validate_profile_id_component(profile_id: &str) -> bool {
+    let p = Path::new(profile_id);
+    let mut components = p.components();
+
+    matches!((components.next(), components.next()), (Some(Component::Normal(_)), None))
+}
+
+
 fn rename_with_retry(src: &Path, dst: &Path) -> std::io::Result<()> {
@@
 fn read_backup_manifest_and_name(backup_path: &Path) -> Result<(BackupManifest, String)> {
@@
     if manifest.format_version != 1 {
         return Err(ErrorCodeString::new("BACKUP_UNSUPPORTED_FORMAT"));
     }
 
+    if !validate_profile_id_component(&manifest.profile_id) {
+        return Err(ErrorCodeString::new("BACKUP_MANIFEST_INVALID"));
+    }
+
     if let Some(name) = manifest.profile_name.clone() {
         return Ok((manifest, name));
     }
@@
     if manifest.format_version != 1 {
         return Err(ErrorCodeString::new("BACKUP_UNSUPPORTED_FORMAT"));
     }
 
+    if !validate_profile_id_component(&manifest.profile_id) {
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+    }
+
     if manifest.profile_id != target_profile_id {
         return Err(ErrorCodeString::new("BACKUP_PROFILE_MISMATCH"));
     }
*** End Patch
```

### Patch 2 — zeroize для ключа и plaintext DB при persist

```diff
*** Begin Patch
*** Update File: src-tauri/src/services/security_service.rs
@@
             let serialized = session
                 .conn
                 .serialize(DatabaseName::Main)
                 .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
 
-            let bytes: Vec<u8> = serialized.to_vec();
+            let bytes = Zeroizing::new(serialized.to_vec());
 
             let profile_id = session.profile_id.clone();
-            let key_material: [u8; 32] = *session.key;
+            let key_material = Zeroizing::new(*session.key);
 
             Some((profile_id, key_material, bytes))
         } else {
             None
         }
@@
     if let Some((profile_id, key_material, bytes)) = maybe_bytes_and_meta {
         let storage_paths = state.get_storage_paths()?;
-        let encrypted = cipher::encrypt_vault_blob(&profile_id, &key_material, bytes.as_slice())?;
+        let encrypted = cipher::encrypt_vault_blob(&profile_id, &*key_material, bytes.as_slice())?;
         cipher::write_encrypted_file(&vault_db_path(&storage_paths, &profile_id)?, &encrypted)?;
         return Ok(Some(profile_id));
     }
*** End Patch
```

### Patch 3 — registry: использовать общий atomic_write (без риска “удалил старое и не записал новое”)

```diff
*** Begin Patch
*** Update File: src-tauri/src/data/profiles/registry.rs
@@
 use std::fs;
 use std::path::PathBuf;
 use uuid::Uuid;
 
+use crate::data::fs::atomic_write::write_atomic;
 use crate::data::profiles::paths::{ensure_profiles_dir, profile_config_path, registry_path};
 use crate::data::storage_paths::StoragePaths;
 use crate::error::{ErrorCodeString, Result};
 use crate::types::ProfileMeta;
@@
 fn save_registry(sp: &StoragePaths, registry: &ProfileRegistry) -> Result<()> {
@@
     let serialized = serde_json::to_string_pretty(registry)
         .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
-    write_atomic(&path, &serialized)
+    write_atomic(&path, serialized.as_bytes()).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))
 }
 
-fn write_atomic(path: &PathBuf, contents: &str) -> Result<()> {
-    let parent = path
-        .parent()
-        .ok_or_else(|| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
-    let file_name = path
-        .file_name()
-        .and_then(|name| name.to_str())
-        .ok_or_else(|| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
-    let temp_path = parent.join(format!("{file_name}.{}.tmp", Uuid::new_v4()));
-
-    fs::write(&temp_path, contents).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
-
-    if fs::rename(&temp_path, path).is_err() {
-        if path.exists() {
-            let _ = fs::remove_file(path);
-        }
-        if let Err(_) = fs::rename(&temp_path, path) {
-            let _ = fs::remove_file(&temp_path);
-            return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
-        }
-    }
-
-    Ok(())
-}
@@
-    if let Err(err) = write_atomic(&config_path, &serialized_config) {
+    if write_atomic(&config_path, serialized_config.as_bytes()).is_err() {
         let _ = fs::remove_dir_all(&profile_dir);
-        return Err(err);
+        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
     }
@@
-    if let Err(err) = write_atomic(&config_path, &serialized_config) {
+    if write_atomic(&config_path, serialized_config.as_bytes()).is_err() {
@@
-        return Err(err);
+        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
     }
*** End Patch
```

