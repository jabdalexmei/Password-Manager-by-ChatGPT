diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/app_state.rs b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/app_state.rs
index 0ea24d2..2b6c51e 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/app_state.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/app_state.rs
@@ -1,6 +1,8 @@
+use std::collections::HashMap;
+use std::path::PathBuf;
 use std::sync::atomic::AtomicBool;
 use std::sync::{Arc, Mutex};
 
 use crate::data::storage_paths::StoragePaths;
 use crate::error::{ErrorCodeString, Result};
 
 use zeroize::Zeroizing;
 
 pub struct VaultSession {
     pub profile_id: String,
     pub conn: rusqlite::Connection,
     pub key: Zeroizing<[u8; 32]>,
 }
 
+#[derive(Clone)]
+pub struct PendingPickedFile {
+    pub id: String,
+    pub path: PathBuf,
+    pub file_name: String,
+    pub byte_size: u64,
+}
+
+pub struct PendingAttachmentPick {
+    pub created_at_ms: u128,
+    pub files: Vec<PendingPickedFile>,
+}
+
 pub struct AppState {
     pub active_profile: Mutex<Option<String>>,
     pub storage_paths: Mutex<StoragePaths>,
 
     pub vault_session: Mutex<Option<VaultSession>>,
     pub vault_persist_guard: Mutex<()>,
     pub vault_persist_requested: AtomicBool,
     pub vault_persist_in_flight: AtomicBool,
     pub backup_guard: Mutex<()>,
+
+    // One-time picks created by backend-native dialogs.
+    // Frontend only receives opaque ids (token + file ids), never filesystem paths.
+    pub pending_attachment_picks: Mutex<HashMap<String, PendingAttachmentPick>>,
 }
 
 impl AppState {
     pub fn new(storage_paths: StoragePaths) -> Self {
         Self {
             active_profile: Mutex::new(None),
             storage_paths: Mutex::new(storage_paths),
 
             vault_session: Mutex::new(None),
             vault_persist_guard: Mutex::new(()),
             vault_persist_requested: AtomicBool::new(false),
             vault_persist_in_flight: AtomicBool::new(false),
             backup_guard: Mutex::new(()),
+
+            pending_attachment_picks: Mutex::new(HashMap::new()),
         }
     }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/types.rs b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/types.rs
index 76c8ff7..53aa0d9 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/types.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/types.rs
@@ -21,6 +21,20 @@ pub struct AttachmentMeta {
     pub deleted_at: Option<String>,
 }
 
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct AttachmentPickFile {
+    pub id: String,
+    pub file_name: String,
+    pub byte_size: i64,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct AttachmentPickPayload {
+    pub token: String,
+    pub files: Vec<AttachmentPickFile>,
+}
+
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct AttachmentPreviewPayload {
     pub attachment_id: String,
     pub file_name: String,
     pub mime_type: String,
     pub byte_size: i64,
     pub base64_data: String,
 }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/services/attachments_service.rs b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/services/attachments_service.rs
index 3f39b70..d0bb236 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/services/attachments_service.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/services/attachments_service.rs
@@ -1,6 +1,6 @@
 use std::fs;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use base64::{engine::general_purpose, Engine as _};
 use chrono::Utc;
 use tauri::{AppHandle, Manager};
 
 use crate::app_state::AppState;
 use crate::data::crypto::cipher;
 use crate::data::profiles::paths::{attachments_preview_root, attachments_root, profile_root};
 use crate::data::sqlite::repo_impl;
 use crate::error::{ErrorCodeString, Result};
 use crate::services::{security_service};
 use crate::types::{AttachmentMeta, AttachmentPreviewPayload};
 
 const MAX_ATTACHMENT_BYTES: usize = 10 * 1024 * 1024;
 const MAX_PREVIEW_BYTES: usize = 512 * 1024;
@@ -54,18 +54,24 @@ fn ensure_target_dir(target: &Path) -> Result<()> {
     Ok(())
 }
 
 pub fn add_attachment_from_path(
     app: &AppHandle,
     datacard_id: String,
     source_path: String,
 ) -> Result<AttachmentMeta> {
+    let source = PathBuf::from(source_path);
+    add_attachment_from_fs_path(app, datacard_id, &source)
+}
+
+pub fn add_attachment_from_fs_path(
+    app: &AppHandle,
+    datacard_id: String,
+    source: &Path,
+) -> Result<AttachmentMeta> {
     let session = require_logged_in(app)?;
 
-    let source = Path::new(&source_path);
-    let file_name = source
+    let file_name = source
         .file_name()
         .and_then(|s| s.to_str())
         .ok_or_else(|| ErrorCodeString::new("ATTACHMENT_INVALID_FILE_NAME"))?
         .to_string();
 
     let bytes = fs::read(source).map_err(|_| ErrorCodeString::new("ATTACHMENT_READ_FAILED"))?;
     if bytes.len() > MAX_ATTACHMENT_BYTES {
         return Err(ErrorCodeString::new("ATTACHMENT_TOO_LARGE"));
     }
 
     let mime = mime_guess::from_path(source)
         .first_raw()
         .map(|s| s.to_string());
@@ -129,6 +135,7 @@ pub fn add_attachment_from_path(
 
     Ok(meta)
 }
 
 pub fn list_attachments(app: &AppHandle, datacard_id: String) -> Result<Vec<AttachmentMeta>> {
     let session = require_logged_in(app)?;
     repo_impl::list_attachments_by_datacard(&session.state, &session.profile_id, &datacard_id)
 }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/commands/attachments.rs b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/commands/attachments.rs
index 9b8f0cf..f4d89d2 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/commands/attachments.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/commands/attachments.rs
@@ -1,38 +1,182 @@
+use std::time::{SystemTime, UNIX_EPOCH};
+
+use tauri_plugin_dialog::{DialogExt, FilePath};
+use uuid::Uuid;
+
+use crate::app_state::{AppState, PendingAttachmentPick, PendingPickedFile};
 use crate::error::{ErrorCodeString, Result};
 use crate::services::attachments_service;
-use crate::types::{AttachmentMeta, AttachmentPreviewPayload};
-use tauri::AppHandle;
+use crate::types::{
+    AttachmentMeta, AttachmentPickFile, AttachmentPickPayload, AttachmentPreviewPayload,
+};
+use tauri::{AppHandle, Manager};
 
 #[tauri::command]
 pub async fn list_attachments(app: AppHandle, datacard_id: String) -> Result<Vec<AttachmentMeta>> {
     tauri::async_runtime::spawn_blocking(move || attachments_service::list_attachments(&app, datacard_id))
         .await
         .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
 
-#[tauri::command]
-pub async fn add_attachment_from_path(
-    app: AppHandle,
-    datacard_id: String,
-    source_path: String,
-) -> Result<AttachmentMeta> {
-    tauri::async_runtime::spawn_blocking(move || {
-        attachments_service::add_attachment_from_path(&app, datacard_id, source_path)
-    })
-    .await
-    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+fn now_ms() -> Result<u128> {
+    SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .map(|d| d.as_millis())
+        .map_err(|_| ErrorCodeString::new("TIME_UNAVAILABLE"))
 }
 
 #[tauri::command]
 pub async fn remove_attachment(app: AppHandle, attachment_id: String) -> Result<()> {
     tauri::async_runtime::spawn_blocking(move || attachments_service::remove_attachment(&app, attachment_id))
         .await
         .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
 
 #[tauri::command]
 pub async fn purge_attachment(app: AppHandle, attachment_id: String) -> Result<()> {
     tauri::async_runtime::spawn_blocking(move || attachments_service::purge_attachment(&app, attachment_id))
         .await
         .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
 
 #[tauri::command]
 pub async fn get_attachment_bytes_base64(
     app: AppHandle,
     attachment_id: String,
 ) -> Result<AttachmentPreviewPayload> {
     tauri::async_runtime::spawn_blocking(move || {
         attachments_service::get_attachment_bytes_base64(&app, attachment_id)
     })
     .await
     .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
 
 #[tauri::command]
 pub async fn get_attachment_preview(
     app: AppHandle,
     attachment_id: String,
 ) -> Result<AttachmentPreviewPayload> {
     tauri::async_runtime::spawn_blocking(move || attachments_service::get_attachment_preview(&app, attachment_id))
         .await
         .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
 
-#[tauri::command]
-pub async fn save_attachment_to_path(
-    app: AppHandle,
-    attachment_id: String,
-    target_path: String,
-) -> Result<()> {
-    tauri::async_runtime::spawn_blocking(move || {
-        attachments_service::save_attachment_to_path(&app, attachment_id, target_path)
-    })
-    .await
-    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+fn file_path_to_pathbuf(fp: FilePath) -> Result<std::path::PathBuf> {
+    match fp {
+        FilePath::Path(p) => Ok(p),
+        _ => Err(ErrorCodeString::new("DIALOG_UNSUPPORTED_FILE_URI")),
+    }
+}
+
+fn cleanup_stale_picks(state: &AppState, now: u128) -> Result<()> {
+    const MAX_AGE_MS: u128 = 10 * 60 * 1000;
+    const MAX_ENTRIES: usize = 16;
+
+    let mut map = state
+        .pending_attachment_picks
+        .lock()
+        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+
+    map.retain(|_, v| now.saturating_sub(v.created_at_ms) <= MAX_AGE_MS);
+    if map.len() > MAX_ENTRIES {
+        // Drop arbitrary extras (oldest-first would require sorting; not worth it here)
+        while map.len() > MAX_ENTRIES {
+            if let Some(key) = map.keys().next().cloned() {
+                map.remove(&key);
+            } else {
+                break;
+            }
+        }
+    }
+    Ok(())
+}
+
+#[tauri::command]
+pub async fn attachments_pick_files(app: AppHandle) -> Result<Option<AttachmentPickPayload>> {
+    tauri::async_runtime::spawn_blocking(move || {
+        let state = app.state::<std::sync::Arc<AppState>>().inner().clone();
+        let now = now_ms()?;
+        cleanup_stale_picks(&state, now)?;
+
+        let selection = app.dialog().file().blocking_pick_files();
+        let Some(paths) = selection else {
+            return Ok(None);
+        };
+
+        let mut files: Vec<PendingPickedFile> = Vec::new();
+        for fp in paths {
+            let path = file_path_to_pathbuf(fp)?;
+            let file_name = path
+                .file_name()
+                .and_then(|s| s.to_str())
+                .ok_or_else(|| ErrorCodeString::new("ATTACHMENT_INVALID_FILE_NAME"))?
+                .to_string();
+            let byte_size = std::fs::metadata(&path)
+                .map(|m| m.len())
+                .map_err(|_| ErrorCodeString::new("ATTACHMENT_READ_FAILED"))?;
+            files.push(PendingPickedFile {
+                id: Uuid::new_v4().to_string(),
+                path,
+                file_name,
+                byte_size,
+            });
+        }
+
+        if files.is_empty() {
+            return Ok(None);
+        }
+
+        let token = Uuid::new_v4().to_string();
+        {
+            let mut map = state
+                .pending_attachment_picks
+                .lock()
+                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+            map.insert(
+                token.clone(),
+                PendingAttachmentPick {
+                    created_at_ms: now,
+                    files: files.clone(),
+                },
+            );
+        }
+
+        let payload = AttachmentPickPayload {
+            token,
+            files: files
+                .into_iter()
+                .map(|f| AttachmentPickFile {
+                    id: f.id,
+                    file_name: f.file_name,
+                    byte_size: f.byte_size as i64,
+                })
+                .collect(),
+        };
+        Ok(Some(payload))
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
+#[tauri::command]
+pub async fn attachments_discard_pick(app: AppHandle, token: String) -> Result<()> {
+    tauri::async_runtime::spawn_blocking(move || {
+        let state = app.state::<std::sync::Arc<AppState>>().inner().clone();
+        let mut map = state
+            .pending_attachment_picks
+            .lock()
+            .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+        map.remove(&token);
+        Ok(())
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
+#[tauri::command]
+pub async fn add_attachments_from_pick(
+    app: AppHandle,
+    datacard_id: String,
+    token: String,
+    file_ids: Option<Vec<String>>,
+) -> Result<Vec<AttachmentMeta>> {
+    tauri::async_runtime::spawn_blocking(move || {
+        let state = app.state::<std::sync::Arc<AppState>>().inner().clone();
+        let pick = {
+            let mut map = state
+                .pending_attachment_picks
+                .lock()
+                .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+            map.remove(&token)
+                .ok_or_else(|| ErrorCodeString::new("ATTACHMENT_PICK_NOT_FOUND"))?
+        };
+
+        let wanted: Option<std::collections::HashSet<String>> =
+            file_ids.map(|ids| ids.into_iter().collect());
+
+        let mut out: Vec<AttachmentMeta> = Vec::new();
+        for f in pick.files {
+            if let Some(set) = &wanted {
+                if !set.contains(&f.id) {
+                    continue;
+                }
+            }
+            let meta = attachments_service::add_attachment_from_fs_path(&app, datacard_id.clone(), &f.path)?;
+            out.push(meta);
+        }
+        Ok(out)
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
+#[tauri::command]
+pub async fn add_attachments_via_dialog(
+    app: AppHandle,
+    datacard_id: String,
+) -> Result<Vec<AttachmentMeta>> {
+    tauri::async_runtime::spawn_blocking(move || {
+        let selection = app.dialog().file().blocking_pick_files();
+        let Some(paths) = selection else {
+            return Ok(Vec::new());
+        };
+
+        let mut out: Vec<AttachmentMeta> = Vec::new();
+        for fp in paths {
+            let path = file_path_to_pathbuf(fp)?;
+            let meta = attachments_service::add_attachment_from_fs_path(&app, datacard_id.clone(), &path)?;
+            out.push(meta);
+        }
+        Ok(out)
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
+#[tauri::command]
+pub async fn save_attachment_via_dialog(app: AppHandle, attachment_id: String) -> Result<bool> {
+    tauri::async_runtime::spawn_blocking(move || {
+        // We re-use the existing service logic, but we DO NOT accept a frontend-provided path.
+        // Instead we show a native save dialog and write to the chosen path.
+        let preview = attachments_service::get_attachment_preview(&app, attachment_id.clone())?;
+        let default_name = preview.file_name.clone();
+
+        let selection = app
+            .dialog()
+            .file()
+            .set_file_name(default_name)
+            .blocking_save_file();
+
+        let Some(fp) = selection else {
+            return Ok(false);
+        };
+
+        let target = file_path_to_pathbuf(fp)?;
+        attachments_service::save_attachment_to_path(&app, attachment_id, target.to_string_lossy().to_string())?;
+        Ok(true)
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
 }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/main.rs b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/main.rs
index 0fd7c9a..7f4c7c0 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/main.rs
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src-tauri/src/main.rs
@@ -72,7 +72,11 @@ fn main() {
             is_logged_in,
             health_check,
             list_attachments,
-            add_attachment_from_path,
+            attachments_pick_files,
+            attachments_discard_pick,
+            add_attachments_from_pick,
+            add_attachments_via_dialog,
             remove_attachment,
             purge_attachment,
             get_attachment_bytes_base64,
             get_attachment_preview,
-            save_attachment_to_path,
+            save_attachment_via_dialog,
             backup_create,
             backup_restore,
             backup_inspect,
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src/features/Vault/api/vaultApi.ts b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src/features/Vault/api/vaultApi.ts
index 8c4bcab..45b0d28 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src/features/Vault/api/vaultApi.ts
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src/features/Vault/api/vaultApi.ts
@@ -171,25 +171,53 @@ export async function listAttachments(datacardId: string): Promise<BackendAttachm
   return invoke('list_attachments', { datacardId });
 }
 
-export async function addAttachmentFromPath(
-  datacardId: string,
-  sourcePath: string
-): Promise<BackendAttachmentMeta> {
-  return invoke('add_attachment_from_path', { datacardId, sourcePath });
-}
+export type AttachmentPickFileDto = {
+  id: string;
+  fileName: string;
+  byteSize: number;
+};
+
+export type AttachmentPickPayloadDto = {
+  token: string;
+  files: AttachmentPickFileDto[];
+};
+
+type BackendAttachmentPickFile = { id: string; file_name: string; byte_size: number };
+type BackendAttachmentPickPayload = { token: string; files: BackendAttachmentPickFile[] };
+
+export async function attachmentsPickFiles(): Promise<AttachmentPickPayloadDto | null> {
+  const payload = await invoke<BackendAttachmentPickPayload | null>('attachments_pick_files');
+  if (!payload) return null;
+  return {
+    token: payload.token,
+    files: payload.files.map((f) => ({
+      id: f.id,
+      fileName: f.file_name,
+      byteSize: f.byte_size,
+    })),
+  };
+}
+
+export async function attachmentsDiscardPick(token: string): Promise<void> {
+  await invoke('attachments_discard_pick', { token });
+}
+
+export async function addAttachmentsFromPick(
+  datacardId: string,
+  token: string,
+  fileIds?: string[]
+): Promise<BackendAttachmentMeta[]> {
+  return invoke('add_attachments_from_pick', { datacardId, token, fileIds: fileIds ?? null });
+}
+
+export async function addAttachmentsViaDialog(datacardId: string): Promise<BackendAttachmentMeta[]> {
+  return invoke('add_attachments_via_dialog', { datacardId });
+}
 
 export async function removeAttachment(attachmentId: string): Promise<void> {
   return invoke('remove_attachment', { attachmentId });
 }
 
 export async function purgeAttachment(attachmentId: string): Promise<void> {
   return invoke('purge_attachment', { attachmentId });
 }
 
-export async function saveAttachmentToPath(
-  attachmentId: string,
-  targetPath: string
-): Promise<void> {
-  return invoke('save_attachment_to_path', { attachmentId, targetPath });
+export async function saveAttachmentViaDialog(attachmentId: string): Promise<boolean> {
+  return invoke('save_attachment_via_dialog', { attachmentId });
 }
diff --git a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src/features/Vault/components/Details/useDetails.tsx b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src/features/Vault/components/Details/useDetails.tsx
index 8c6da3f..4f0c1a1 100644
--- a/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src/features/Vault/components/Details/useDetails.tsx
+++ b/Password-Manager-by-ChatGPT-codex-github-mention-11-after-update/src/features/Vault/components/Details/useDetails.tsx
@@ -4,7 +4,7 @@ import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
 import {
   getAttachmentBytesBase64,
-  addAttachmentFromPath,
+  addAttachmentsViaDialog,
   listAttachments,
   purgeAttachment,
   removeAttachment,
-  saveAttachmentToPath,
+  saveAttachmentViaDialog,
 } from '../../api/vaultApi';
 import { useToasts } from '../../../../shared/ui/ToastProvider';
 import { useI18n } from '../../../../shared/i18n/useI18n';
@@ -191,23 +191,15 @@ export function useDetails({
   const onAddAttachment = useCallback(async () => {
     if (!card || isTrashMode) return;
     try {
-      const { open } = await import('@tauri-apps/plugin-dialog');
-      const selection = await open({ multiple: true });
-      const paths = Array.isArray(selection)
-        ? selection.filter((p): p is string => typeof p === 'string')
-        : selection && typeof selection === 'string'
-          ? [selection]
-          : [];
-      if (!paths.length) return;
-
-      for (const path of paths) {
-        await addAttachmentFromPath(card.id, path);
-      }
+      const added = await addAttachmentsViaDialog(card.id);
+      if (!added.length) return; // cancelled
       await refreshAttachments();
       showToast(t('toast.attachmentAddSuccess'), 'success');
     } catch (err) {
       console.error(err);
       showToast(t('toast.attachmentAddError'), 'erro
