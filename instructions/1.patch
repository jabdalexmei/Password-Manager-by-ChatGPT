diff -ruN /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/app_state.rs /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/app_state.rs
--- /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/app_state.rs	2026-01-23 03:29:45.000000000 +0000
+++ /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/app_state.rs	2026-01-23 07:54:12.238071498 +0000
@@ -173,7 +173,6 @@
     pub fn logout_and_cleanup(self: &Arc<Self>) -> Result<()> {
         crate::services::security_service::lock_vault(self)?;
 
-        crate::data::sqlite::pool::clear_all_pools();
 
         self.clear_security_state()?;
 
diff -ruN /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/commands/profiles.rs /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/commands/profiles.rs
--- /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/commands/profiles.rs	2026-01-23 03:29:45.000000000 +0000
+++ /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/commands/profiles.rs	2026-01-23 08:04:49.247612596 +0000
@@ -66,7 +66,6 @@
             .as_ref()
             .map(|s| s.profile_id == id)
             .unwrap_or(false);
-        crate::data::sqlite::pool::clear_pool(&id);
         if should_lock {
             app_state.logout_and_cleanup()?;
         }
@@ -130,7 +129,6 @@
             }
 
             if let Some(old_id) = &old_active_profile_id {
-                crate::data::sqlite::pool::clear_pool(old_id);
             }
         }
 
@@ -139,7 +137,7 @@
         }
         profiles_service::set_active_profile(&storage_paths, &id)?;
 
-        // Preserve legacy behavior: passwordless profiles auto-unlock on selection.
+        // Passwordless profiles can unlock on selection (no password needed to unwrap master key).
         let profile = registry::get_profile(&storage_paths, &id)?
             .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
         if !profile.has_password {
diff -ruN /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/data/sqlite/pool.rs /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/data/sqlite/pool.rs
--- /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/data/sqlite/pool.rs	2026-01-23 03:29:45.000000000 +0000
+++ /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/data/sqlite/pool.rs	1970-01-01 00:00:00.000000000 +0000
@@ -1,12 +0,0 @@
-// This module intentionally provides no-op pool invalidation helpers.
-//
-// Older versions of the app used r2d2 to pool file-backed SQLite connections.
-// The current storage model keeps SQLite in memory and persists an encrypted blob (vault.db),
-// so there are no file-backed SQLite connections to pool.
-//
-// We keep these functions because many call sites legitimately want to invalidate any
-// cached connections after restore / password transitions.
-
-pub fn clear_pool(_profile_id: &str) {}
-
-pub fn clear_all_pools() {}
diff -ruN /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/main.rs /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/main.rs
--- /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/main.rs	2026-01-23 03:29:45.000000000 +0000
+++ /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/main.rs	2026-01-23 07:53:56.185612252 +0000
@@ -31,7 +31,6 @@
         pub mod diagnostics;
         pub mod init;
         pub mod migrations;
-        pub mod pool;
         pub mod repo_impl;
     }
 }
diff -ruN /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/services/backup_service.rs /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/services/backup_service.rs
--- /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/services/backup_service.rs	2026-01-23 03:29:45.000000000 +0000
+++ /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/services/backup_service.rs	2026-01-23 08:05:11.001080893 +0000
@@ -13,6 +13,8 @@
 
 use crate::app_state::AppState;
 
+use crate::data::crypto::cipher;
+
 // Restore hard limits (anti zip-bomb / decompression bomb DoS)
 const MAX_RESTORE_FILES: usize = 4096;
 const MAX_RESTORE_ENTRY_BYTES: i64 = 64 * 1024 * 1024;
@@ -179,6 +181,116 @@
 }
 
 
+// Backup restore safety: we refuse to write any file that looks like plaintext vault data.
+// Under the "always encrypted at-rest" invariant, a plaintext SQLite header must never
+// appear on disk during restore.
+const SQLITE_MAGIC: &[u8; 16] = b"SQLite format 3\0";
+
+// Passwordless vault_key.bin prefix (master key stored in a self-describing, unwrapped format).
+const PASSWORDLESS_MASTER_KEY_PREFIX: &[u8; 6] = b"PMMK1:";
+
+fn expected_restore_header_len(manifest: &BackupManifest, entry_path: &str) -> usize {
+    let enc_header_len = cipher::PM_ENC_MAGIC.len() + 1;
+
+    match entry_path {
+        "vault.db" => SQLITE_MAGIC.len().max(enc_header_len),
+        "key_check.bin" => enc_header_len,
+        "vault_key.bin" => {
+            if manifest.vault_mode == "protected" {
+                enc_header_len
+            } else if manifest.vault_mode == "passwordless" {
+                PASSWORDLESS_MASTER_KEY_PREFIX.len() + manifest.profile_id.as_bytes().len() + 1
+            } else {
+                enc_header_len
+            }
+        }
+        _ => {
+            if entry_path.starts_with("attachments/") {
+                enc_header_len
+            } else {
+                0
+            }
+        }
+    }
+}
+
+fn validate_encrypted_blob_header(entry_path: &str, header: &[u8]) -> Result<()> {
+    let enc_header_len = cipher::PM_ENC_MAGIC.len() + 1;
+    if header.len() < enc_header_len {
+        log::error!(
+            "[BACKUP][restore] invalid_blob_header path={} reason=too_short len={}",
+            entry_path,
+            header.len()
+        );
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+    }
+
+    if &header[..cipher::PM_ENC_MAGIC.len()] != cipher::PM_ENC_MAGIC {
+        log::error!(
+            "[BACKUP][restore] insecure_entry path={} reason=missing_magic",
+            entry_path
+        );
+        return Err(ErrorCodeString::new("BACKUP_PLAINTEXT_REJECTED"));
+    }
+    if header[cipher::PM_ENC_MAGIC.len()] != cipher::PM_ENC_VERSION {
+        log::error!(
+            "[BACKUP][restore] invalid_blob_header path={} reason=unsupported_version v={}",
+            entry_path,
+            header[cipher::PM_ENC_MAGIC.len()]
+        );
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+    }
+
+    Ok(())
+}
+
+fn validate_backup_entry_header(manifest: &BackupManifest, entry_path: &str, header: &[u8]) -> Result<()> {
+    if entry_path == "vault.db" {
+        if header.len() >= SQLITE_MAGIC.len() && &header[..SQLITE_MAGIC.len()] == SQLITE_MAGIC {
+            log::error!(
+                "[BACKUP][restore] insecure_entry path={} reason=sqlite_plaintext",
+                entry_path
+            );
+            return Err(ErrorCodeString::new("BACKUP_PLAINTEXT_REJECTED"));
+        }
+        return validate_encrypted_blob_header(entry_path, header);
+    }
+
+    if entry_path.starts_with("attachments/") || entry_path == "key_check.bin" {
+        return validate_encrypted_blob_header(entry_path, header);
+    }
+
+    if entry_path == "vault_key.bin" {
+        if manifest.vault_mode == "protected" {
+            return validate_encrypted_blob_header(entry_path, header);
+        }
+        if manifest.vault_mode == "passwordless" {
+            let expected_len = PASSWORDLESS_MASTER_KEY_PREFIX.len() + manifest.profile_id.as_bytes().len() + 1;
+            if header.len() < expected_len {
+                return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+            }
+            if &header[..PASSWORDLESS_MASTER_KEY_PREFIX.len()] != PASSWORDLESS_MASTER_KEY_PREFIX {
+                return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+            }
+            let pid = manifest.profile_id.as_bytes();
+            let start = PASSWORDLESS_MASTER_KEY_PREFIX.len();
+            let end = start + pid.len();
+            if &header[start..end] != pid {
+                return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+            }
+            if header[end] != 0 {
+                return Err(ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"));
+            }
+            return Ok(());
+        }
+        return Err(ErrorCodeString::new("BACKUP_MANIFEST_INVALID"));
+    }
+
+    Ok(())
+}
+
+
+
 
 
 fn best_effort_fsync_rename_dirs(_src: &Path, _dst: &Path) {
@@ -864,6 +976,17 @@
         let mut zipped_file = archive
             .by_name(&entry.path)
             .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+let header_len = expected_restore_header_len(manifest, &entry.path);
+let mut pre_read: Vec<u8> = Vec::new();
+if header_len > 0 {
+    pre_read.resize(header_len, 0);
+    let n = zipped_file
+        .read(&mut pre_read)
+        .map_err(|_| ErrorCodeString::new("BACKUP_ARCHIVE_INVALID"))?;
+    pre_read.truncate(n);
+    validate_backup_entry_header(manifest, &entry.path, &pre_read)?;
+}
+
 
         let target_path = staging_root.as_path().join(rel_path);
         if let Some(parent) = target_path.parent() {
@@ -878,6 +1001,24 @@
         let mut hasher = Sha256::new();
         let mut bytes_written = 0i64;
 
+if !pre_read.is_empty() {
+    writer
+        .write_all(&pre_read)
+        .map_err(|e| map_restore_io_error("write_extracted_file", Some(&target_path), None, e))?;
+    bytes_written = bytes_written
+        .checked_add(pre_read.len() as i64)
+        .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
+    total_written = total_written
+        .checked_add(pre_read.len() as i64)
+        .ok_or_else(|| ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"))?;
+
+    if bytes_written > MAX_RESTORE_ENTRY_BYTES || total_written > MAX_RESTORE_TOTAL_BYTES {
+        return Err(ErrorCodeString::new("BACKUP_ARCHIVE_TOO_LARGE"));
+    }
+
+    hasher.update(&pre_read);
+}
+
         loop {
             let read = zipped_file
                 .read(&mut buffer)
@@ -1108,7 +1249,6 @@
     let _guard = ensure_backup_guard(state)?;
     // Persist any in-memory changes before restore to avoid data loss on rollback.
     security_service::lock_vault(state)?;
-    crate::data::sqlite::pool::clear_all_pools();
     let sp = state.get_storage_paths()?;
 
     let backup_path = PathBuf::from(&backup_path);
@@ -1208,3 +1348,66 @@
 
     Ok(Some(result.path))
 }
+
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn test_manifest(vault_mode: &str, profile_id: &str) -> BackupManifest {
+        BackupManifest {
+            format_version: 1,
+            created_at_utc: "2026-01-23T00:00:00Z".to_string(),
+            app_version: "test".to_string(),
+            profile_id: profile_id.to_string(),
+            profile_name: Some("Test".to_string()),
+            vault_mode: vault_mode.to_string(),
+            files: vec![],
+        }
+    }
+
+    #[test]
+    fn restore_rejects_plaintext_sqlite_vault_db_header() {
+        let manifest = test_manifest("passwordless", "p1");
+        let err = validate_backup_entry_header(&manifest, "vault.db", SQLITE_MAGIC).unwrap_err();
+        assert_eq!(err.code, "BACKUP_PLAINTEXT_REJECTED");
+    }
+
+    #[test]
+    fn restore_accepts_encrypted_vault_db_header() {
+        let manifest = test_manifest("passwordless", "p1");
+        let mut header = Vec::new();
+        header.extend_from_slice(&cipher::PM_ENC_MAGIC);
+        header.push(cipher::PM_ENC_VERSION);
+        header.extend_from_slice(&[0u8; 8]);
+        validate_backup_entry_header(&manifest, "vault.db", &header).unwrap();
+    }
+
+    #[test]
+    fn restore_accepts_passwordless_vault_key_prefix_and_profile_id() {
+        let manifest = test_manifest("passwordless", "abc");
+        let mut header = Vec::new();
+        header.extend_from_slice(PASSWORDLESS_MASTER_KEY_PREFIX);
+        header.extend_from_slice(manifest.profile_id.as_bytes());
+        header.push(0);
+        validate_backup_entry_header(&manifest, "vault_key.bin", &header).unwrap();
+    }
+
+    #[test]
+    fn restore_rejects_protected_vault_key_in_passwordless_manifest() {
+        let manifest = test_manifest("passwordless", "abc");
+        let mut header = Vec::new();
+        header.extend_from_slice(&cipher::PM_ENC_MAGIC);
+        header.push(cipher::PM_ENC_VERSION);
+        header.extend_from_slice(&[0u8; 8]);
+        let err = validate_backup_entry_header(&manifest, "vault_key.bin", &header).unwrap_err();
+        assert_eq!(err.code, "BACKUP_ARCHIVE_INVALID");
+    }
+
+    #[test]
+    fn expected_header_len_for_passwordless_vault_key_includes_profile_id() {
+        let manifest = test_manifest("passwordless", "abc");
+        let len = expected_restore_header_len(&manifest, "vault_key.bin");
+        assert_eq!(len, PASSWORDLESS_MASTER_KEY_PREFIX.len() + 3 + 1);
+    }
+}
diff -ruN /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/services/security_service.rs /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/services/security_service.rs
--- /mnt/data/repo_orig/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/services/security_service.rs	2026-01-23 03:29:45.000000000 +0000
+++ /mnt/data/repo_mod/Password-Manager-by-ChatGPT-codex-github-mention-remove-legacy-dpapi-handling-and-enforce-por/src-tauri/src/services/security_service.rs	2026-01-23 08:05:24.359381352 +0000
@@ -20,7 +20,6 @@
 };
 use crate::data::profiles::registry;
 use crate::data::sqlite::migrations;
-use crate::data::sqlite::pool::clear_pool;
 use crate::error::{ErrorCodeString, Result};
 use crate::services::attachments_service;
 use crate::types::ProfileMeta;
@@ -135,37 +134,66 @@
     }
 }
 
-fn open_protected_vault_session(
-    profile_id: &str,
-    password: &str,
-    storage_paths: &crate::data::storage_paths::StoragePaths,
-    state: &Arc<AppState>,
-) -> Result<()> {
-    let salt_path = kdf_salt_path(storage_paths, profile_id)?;
-    if !salt_path.exists() {
-        return Err(ErrorCodeString::new("KDF_SALT_MISSING"));
-    }
-    let salt =
-        std::fs::read(&salt_path).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_READ"))?;
-    // Password is used ONLY to unwrap the master key (vault_key.bin). Vault data is always
-    // encrypted with the master key.
-    let wrapping_key = Zeroizing::new(kdf::derive_master_key(password, &salt)?);
 
-    if !key_check::verify_key_check_file(storage_paths, profile_id, &wrapping_key)? {
-        return Err(ErrorCodeString::new("INVALID_PASSWORD"));
+fn ensure_ciphertext_vault_on_disk(vault_path: &Path, profile_id: &str) -> Result<()> {
+    const SQLITE_MAGIC: &[u8; 16] = b"SQLite format 3\0";
+    if !vault_path.exists() {
+        return Err(ErrorCodeString::new("VAULT_CORRUPTED"));
     }
 
-    let master = Zeroizing::new(
-        master_key::read_master_key_wrapped_with_password(storage_paths, profile_id, &wrapping_key)?,
-    );
+    // Detect legacy/plaintext vaults early. A plaintext SQLite DB starting with the SQLite magic
+    // must never exist on disk under the "always encrypted" invariant.
+    let magic = read_file_prefix(vault_path, SQLITE_MAGIC.len())
+        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_READ"))?;
+    if magic.as_slice() == SQLITE_MAGIC {
+        log::error!(
+            "[SECURITY][vault_at_rest] profile_id={} action=plaintext_detected path={:?}",
+            profile_id,
+            vault_path
+        );
+        return Err(ErrorCodeString::new("VAULT_PLAINTEXT_DETECTED"));
+    }
 
-    let vault_path = vault_db_path(storage_paths, profile_id)?;
-    if !vault_path.exists() {
+    // Enforce our encrypted blob header ("PMENC1" + version).
+    let header_len = cipher::PM_ENC_MAGIC.len() + 1;
+    let header = read_file_prefix(vault_path, header_len)
+        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_READ"))?;
+    if header.len() != header_len {
+        return Err(ErrorCodeString::new("VAULT_CORRUPTED"));
+    }
+    if &header[..cipher::PM_ENC_MAGIC.len()] != cipher::PM_ENC_MAGIC {
         return Err(ErrorCodeString::new("VAULT_CORRUPTED"));
     }
+    if header[cipher::PM_ENC_MAGIC.len()] != cipher::PM_ENC_VERSION {
+        return Err(ErrorCodeString::new("VAULT_CORRUPTED"));
+    }
+
+    Ok(())
+}
+
+fn map_vault_decrypt_error(err: ErrorCodeString) -> ErrorCodeString {
+    match err.code.as_str() {
+        "CRYPTO_BLOB_INVALID" | "CRYPTO_VERSION_UNSUPPORTED" => ErrorCodeString::new("VAULT_CORRUPTED"),
+        "CRYPTO_DECRYPT_FAILED" => ErrorCodeString::new("VAULT_DECRYPT_FAILED"),
+        other => {
+            log::warn!("[SECURITY][vault_decrypt] unmapped_error_code={}", other);
+            ErrorCodeString::new("VAULT_DECRYPT_FAILED")
+        }
+    }
+}
+
+fn open_vault_session_with_master_key(
+    profile_id: &str,
+    master: Zeroizing<[u8; 32]>,
+    storage_paths: &crate::data::storage_paths::StoragePaths,
+    state: &Arc<AppState>,
+) -> Result<()> {
+    let vault_path = vault_db_path(storage_paths, profile_id)?;
+    ensure_ciphertext_vault_on_disk(&vault_path, profile_id)?;
+
     let encrypted = cipher::read_encrypted_file(&vault_path)?;
     let decrypted = cipher::decrypt_vault_blob(profile_id, &master, &encrypted)
-        .map_err(|_| ErrorCodeString::new("VAULT_DECRYPT_FAILED"))?;
+        .map_err(map_vault_decrypt_error)?;
 
     // If the stored DB image is marked WAL, SQLite may try to open -wal/-shm even for :memory:
     // deserialization and fail with SQLITE_CANTOPEN (14). Normalize header before deserialize.
@@ -226,80 +254,42 @@
     Ok(())
 }
 
-fn open_passwordless_vault_session(
+fn open_vault_session(
     profile_id: &str,
+    has_password: bool,
+    password: Option<&str>,
     storage_paths: &crate::data::storage_paths::StoragePaths,
     state: &Arc<AppState>,
 ) -> Result<()> {
-    // Passwordless portable mode: read the master key from vault_key.bin.
-    let master =
-        Zeroizing::new(master_key::read_master_key_passwordless_portable(
-            storage_paths,
-            profile_id,
-        )?);
+    let master = if has_password {
+        let password = password.filter(|p| !p.is_empty()).ok_or_else(|| ErrorCodeString::new("PASSWORD_REQUIRED"))?;
 
-    let vault_path = vault_db_path(storage_paths, profile_id)?;
-    if !vault_path.exists() {
-        return Err(ErrorCodeString::new("VAULT_CORRUPTED"));
-    }
-    let encrypted = cipher::read_encrypted_file(&vault_path)?;
-    let decrypted = cipher::decrypt_vault_blob(profile_id, &master, &encrypted)
-        .map_err(|_| ErrorCodeString::new("VAULT_DECRYPT_FAILED"))?;
+        let salt_path = kdf_salt_path(storage_paths, profile_id)?;
+        if !salt_path.exists() {
+            return Err(ErrorCodeString::new("KDF_SALT_MISSING"));
+        }
+        let salt =
+            std::fs::read(&salt_path).map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_READ"))?;
 
-    let mut decrypted = decrypted;
-    normalize_sqlite_header_disable_wal(
-        decrypted.as_mut_slice(),
-        profile_id,
-        "unlock_before_deserialize",
-    );
+        // Password is used ONLY to unwrap the master key (vault_key.bin). Vault data is always
+        // encrypted with the master key.
+        let wrapping_key = Zeroizing::new(kdf::derive_master_key(password, &salt)?);
 
-    let mut conn = rusqlite::Connection::open_in_memory().map_err(|e| {
-        log::error!(
-            "[SECURITY][login] profile_id={} step=open_in_memory err={}",
-            profile_id,
-            format_rusqlite_error(&e)
-        );
-        ErrorCodeString::new("DB_OPEN_FAILED")
-    })?;
-
-    apply_in_memory_pragmas(&conn, profile_id, "open_in_memory_before_deserialize")?;
-    let owned = owned_data_from_bytes(decrypted)?;
-    conn.deserialize(DatabaseName::Main, owned, false).map_err(|e| {
-        log::error!(
-            "[SECURITY][login] profile_id={} step=deserialize err={}",
-            profile_id,
-            format_rusqlite_error(&e)
-        );
-        ErrorCodeString::new("VAULT_CORRUPTED")
-    })?;
+        if !key_check::verify_key_check_file(storage_paths, profile_id, &wrapping_key)? {
+            return Err(ErrorCodeString::new("INVALID_PASSWORD"));
+        }
 
-    if let Err(e) = migrations::migrate_to_latest(&conn) {
-        log::error!(
-            "[SECURITY][login] profile_id={} step=migrate_to_latest failed code={}",
+        Zeroizing::new(
+            master_key::read_master_key_wrapped_with_password(storage_paths, profile_id, &wrapping_key)?,
+        )
+    } else {
+        Zeroizing::new(master_key::read_master_key_passwordless_portable(
+            storage_paths,
             profile_id,
-            e.code
-        );
-        return Err(e);
-    }
-    migrations::validate_core_schema(&conn)
-        .map_err(|_| ErrorCodeString::new("VAULT_CORRUPTED"))?;
-
-    best_effort_force_journal_mode_memory(&conn, profile_id, "unlock_after_deserialize");
-
-    {
-        let mut session = state
-            .vault_session
-            .lock()
-            .map_err(|_| ErrorCodeString::new("STATE_LOCK_POISONED"))?;
-
-        *session = Some(VaultSession {
-            profile_id: profile_id.to_string(),
-            conn,
-            key: master,
-        });
-    }
+        )?)
+    };
 
-    Ok(())
+    open_vault_session_with_master_key(profile_id, master, storage_paths, state)
 }
 
 fn is_dir_nonempty(dir: &Path) -> io::Result<bool> {
@@ -467,7 +457,6 @@
         let _ = remove_file_retry(&commit, 20, Duration::from_millis(50));
 
         registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, true)?;
-        clear_pool(profile_id);
         best_effort_remove_dir_all_retry(&tx_root, 40, Duration::from_millis(50));
         return Ok(());
     }
@@ -477,7 +466,6 @@
         .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
 
     registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, false)?;
-    clear_pool(profile_id);
     best_effort_remove_dir_all_retry(&tx_root, 40, Duration::from_millis(50));
     Ok(())
 }
@@ -564,7 +552,6 @@
         let _ = remove_file_retry(&key_check_final, 20, Duration::from_millis(50));
 
         registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, false)?;
-        clear_pool(profile_id);
         // Best-effort cleanup.
         let _ = remove_file_retry(&commit, 20, Duration::from_millis(50));
         best_effort_remove_dir_all_retry(&tx_root, 40, Duration::from_millis(50));
@@ -576,7 +563,6 @@
         .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
 
     registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, true)?;
-    clear_pool(profile_id);
     best_effort_remove_dir_all_retry(&tx_root, 40, Duration::from_millis(50));
     Ok(())
 }
@@ -662,7 +648,6 @@
         let _ = remove_file_retry(&tx_root.join("vault_key.bin.bak"), 20, Duration::from_millis(50));
         let _ = remove_file_retry(&tx_root.join("key_check.bin.bak"), 20, Duration::from_millis(50));
         let _ = remove_file_retry(&commit, 20, Duration::from_millis(50));
-        clear_pool(profile_id);
         best_effort_remove_dir_all_retry(&tx_root, 40, Duration::from_millis(50));
         return Ok(());
     }
@@ -671,7 +656,6 @@
     if let Err(_e) = rollback_change_password_tx(&tx_root, &vault_key_final, &key_check_final) {
         return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
     }
-    clear_pool(profile_id);
     best_effort_remove_dir_all_retry(&tx_root, 40, Duration::from_millis(50));
     Ok(())
 }
@@ -915,15 +899,12 @@
     profile = registry::get_profile(&storage_paths, id)?
         .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
 
-    let pwd = password.unwrap_or("");
-    let is_passwordless = !profile.has_password;
-
-    if is_passwordless {
-        open_passwordless_vault_session(id, &storage_paths, state)?;
-    } else {
-        open_protected_vault_session(id, pwd, &storage_paths, state)?;
+    if profile.has_password && password.filter(|p| !p.is_empty()).is_none() {
+        return Err(ErrorCodeString::new("PASSWORD_REQUIRED"));
     }
 
+    open_vault_session(id, profile.has_password, password, &storage_paths, state)?;
+
     if let Ok(mut active) = state.active_profile.lock() {
         *active = Some(id.to_string());
     }
@@ -1032,7 +1013,6 @@
     }
 
     if let Some(id) = cleanup_id.as_ref() {
-        clear_pool(id);
     }
 
     Ok(true)
@@ -1182,7 +1162,6 @@
         let _ = remove_dir_all_retry(&tx_root, 40, Duration::from_millis(50));
     }
 
-    clear_pool(id);
     Ok(updated.into())
 }
 
@@ -1398,7 +1377,6 @@
 
     let updated = registry::upsert_profile_with_id(&storage_paths, id, &profile.name, false)?;
 
-    clear_pool(id);
     best_effort_remove_dir_all_retry(&tx_root, 40, Duration::from_millis(50));
     Ok(updated.into())
 }
@@ -1465,3 +1443,38 @@
 pub fn health_check() -> Result<bool> {
     Ok(true)
 }
+
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn detects_plaintext_sqlite_vault_on_disk() {
+        const SQLITE_MAGIC: &[u8; 16] = b"SQLite format 3\0";
+
+        let dir = tempfile::tempdir().unwrap();
+        let vault_path = dir.path().join("vault.db");
+        let mut bytes = Vec::new();
+        bytes.extend_from_slice(SQLITE_MAGIC);
+        bytes.extend_from_slice(&[0u8; 64]);
+        std::fs::write(&vault_path, bytes).unwrap();
+
+        let err = ensure_ciphertext_vault_on_disk(&vault_path, "p1").unwrap_err();
+        assert_eq!(err.code, "VAULT_PLAINTEXT_DETECTED");
+    }
+
+    #[test]
+    fn accepts_encrypted_blob_header_for_vault_on_disk() {
+        let dir = tempfile::tempdir().unwrap();
+        let vault_path = dir.path().join("vault.db");
+
+        let mut bytes = Vec::new();
+        bytes.extend_from_slice(&cipher::PM_ENC_MAGIC);
+        bytes.push(cipher::PM_ENC_VERSION);
+        bytes.extend_from_slice(&[0u8; 64]);
+        std::fs::write(&vault_path, bytes).unwrap();
+
+        ensure_ciphertext_vault_on_disk(&vault_path, "p1").unwrap();
+    }
+}
