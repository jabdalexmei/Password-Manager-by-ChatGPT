

```diff
*** a/src-tauri/src/data/sqlite/schema.sql
--- b/src-tauri/src/data/sqlite/schema.sql
***************
*** 1,220 ****
@@
 CREATE TABLE IF NOT EXISTS bank_cards (
   id           TEXT PRIMARY KEY,
   folder_id    TEXT NULL,
 
   title        TEXT,
   cardholder   TEXT NULL,
   card_number  TEXT NULL,
   expiry_month INTEGER NULL,
   expiry_year  INTEGER NULL,
   cvv          TEXT NULL,
   pin          TEXT NULL,
   note         TEXT NULL,
 
   is_favorite  INTEGER NOT NULL DEFAULT 0,
 
   tags_json    TEXT NOT NULL DEFAULT '[]',
 
   created_at   TEXT NOT NULL,
   updated_at   TEXT NOT NULL,
+  archived_at  TEXT NULL,
   deleted_at   TEXT NULL
 );
 
 CREATE INDEX IF NOT EXISTS idx_bank_cards_folder
 ON bank_cards(folder_id);
 
+CREATE INDEX IF NOT EXISTS idx_bank_cards_archived
+ON bank_cards(archived_at);
+
 CREATE INDEX IF NOT EXISTS idx_bank_cards_deleted
 ON bank_cards(deleted_at);
*** a/src-tauri/src/data/sqlite/migrations.rs
--- b/src-tauri/src/data/sqlite/migrations.rs
***************
*** 1,20 ****
 use rusqlite::Connection;
 use rusqlite::OptionalExtension;
 
 use crate::error::{ErrorCodeString, Result};
 
-const CURRENT_SCHEMA_VERSION: i32 = 3;
+const CURRENT_SCHEMA_VERSION: i32 = 4;
@@
 fn migrate_2_to_3(conn: &Connection) -> Result<()> {
     ensure_ui_preferences_table(conn)?;
 
     // Add per-datacard archived timestamp (soft-archive).
     if has_table(conn, "datacards")? && !has_column(conn, "datacards", "archived_at")? {
@@
     Ok(())
 }
 
+fn migrate_3_to_4(conn: &Connection) -> Result<()> {
+    ensure_ui_preferences_table(conn)?;
+
+    // Add per-bank-card archived timestamp (soft-archive).
+    if has_table(conn, "bank_cards")? && !has_column(conn, "bank_cards", "archived_at")? {
+        conn.execute_batch(
+            r#"
+ALTER TABLE bank_cards
+ADD COLUMN archived_at TEXT NULL;
+"#,
+        )
+        .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+
+        // Best-effort: if legacy tag-based archive exists, carry it over.
+        conn.execute_batch(
+            r#"
+UPDATE bank_cards
+SET archived_at = COALESCE(archived_at, updated_at)
+WHERE archived_at IS NULL
+  AND tags_json LIKE '%"archived"%';
+"#,
+        )
+        .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+    }
+
+    conn.execute_batch("PRAGMA user_version = 4;")
+        .map_err(|_| ErrorCodeString::new("DB_MIGRATION_FAILED"))?;
+
+    Ok(())
+}
+
 pub fn migrate_to_latest(conn: &Connection) -> Result<()> {
@@
     match version {
-        1 => {
-            migrate_1_to_2(conn)?;
-            migrate_2_to_3(conn)
-        }
-        2 => migrate_2_to_3(conn),
+        1 => {
+            migrate_1_to_2(conn)?;
+            migrate_2_to_3(conn)?;
+            migrate_3_to_4(conn)
+        }
+        2 => {
+            migrate_2_to_3(conn)?;
+            migrate_3_to_4(conn)
+        }
+        3 => migrate_3_to_4(conn),
         CURRENT_SCHEMA_VERSION => {
             ensure_ui_preferences_table(conn)?;
             Ok(())
         }
         _ => {
*** a/src-tauri/src/types.rs
--- b/src-tauri/src/types.rs
***************
*** 200,240 ****
 pub struct SetDataCardArchivedInput {
     pub id: String,
     pub is_archived: bool,
 }
 
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct SetBankCardArchivedInput {
+    pub id: String,
+    pub is_archived: bool,
+}
+
 #[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
 pub struct BankCardItem {
     pub id: String,
     pub folder_id: Option<String>,
     pub title: String,
     pub cardholder: Option<String>,
     pub card_number: Option<String>,
     pub expiry_month: Option<i32>,
     pub expiry_year: Option<i32>,
     pub cvv: Option<String>,
     pub pin: Option<String>,
     pub note: Option<String>,
     pub tags: Vec<String>,
     pub is_favorite: bool,
     pub created_at: String,
     pub updated_at: String,
+    pub archived_at: Option<String>,
     pub deleted_at: Option<String>,
 }
 
 #[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
 pub struct BankCardSummary {
     pub id: String,
     pub folder_id: Option<String>,
     pub title: String,
     pub cardholder: Option<String>,
     pub last4: Option<String>,
     pub note: Option<String>,
     pub tags: Vec<String>,
     pub is_favorite: bool,
     pub created_at: String,
     pub updated_at: String,
+    pub archived_at: Option<String>,
     pub deleted_at: Option<String>,
 }
*** a/src-tauri/src/data/sqlite/repo_impl.rs
--- b/src-tauri/src/data/sqlite/repo_impl.rs
***************
*** 1,25 ****
 use std::sync::Arc;
@@
 use crate::types::{
     AttachmentMeta, BankCardItem, BankCardSummary, CreateBankCardInput, CreateDataCardInput,
     DataCard, DataCardSummary, Folder, PasswordHistoryRow, SetBankCardFavoriteInput,
-    SetDataCardArchivedInput, SetDataCardFavoriteInput, UpdateBankCardInput, UpdateDataCardInput,
+    SetBankCardArchivedInput, SetDataCardArchivedInput, SetDataCardFavoriteInput, UpdateBankCardInput, UpdateDataCardInput,
 };
@@
 fn map_bank_card(row: &rusqlite::Row) -> rusqlite::Result<BankCardItem> {
     Ok(BankCardItem {
         id: row.get("id")?,
         folder_id: row.get("folder_id")?,
         title: row.get("title")?,
         cardholder: row.get("cardholder")?,
         card_number: row.get("card_number")?,
         expiry_month: row.get("expiry_month")?,
         expiry_year: row.get("expiry_year")?,
         cvv: row.get("cvv")?,
         pin: row.get("pin")?,
         note: row.get("note")?,
         tags: deserialize_json(row.get::<_, String>("tags_json")?)?,
         is_favorite: row.get::<_, i64>("is_favorite")? != 0,
         created_at: row.get("created_at")?,
         updated_at: row.get("updated_at")?,
+        archived_at: row.get("archived_at")?,
         deleted_at: row.get("deleted_at")?,
     })
 }
@@
 fn map_bank_card_summary(row: &rusqlite::Row) -> rusqlite::Result<BankCardSummary> {
     Ok(BankCardSummary {
         id: row.get("id")?,
         folder_id: row.get("folder_id")?,
         title: row.get("title")?,
         cardholder: row.get("cardholder")?,
         last4: row.get("last4")?,
         note: row.get("note")?,
         tags: deserialize_json(row.get::<_, String>("tags_json")?)?,
         is_favorite: row.get::<_, i64>("is_favorite")? != 0,
         created_at: row.get("created_at")?,
         updated_at: row.get("updated_at")?,
+        archived_at: row.get("archived_at")?,
         deleted_at: row.get("deleted_at")?,
     })
 }
@@
 pub fn list_bank_cards_summary(
     state: &Arc<AppState>,
     profile_id: &str,
 ) -> Result<Vec<BankCardSummary>> {
     with_connection(state, profile_id, |conn| {
         let mut stmt = conn
             .prepare(
                 r#"
                 SELECT
                   b.id,
                   b.folder_id,
                   b.title,
                   b.cardholder,
                   CASE
                     WHEN b.card_number IS NOT NULL AND LENGTH(TRIM(b.card_number)) >= 4
                     THEN SUBSTR(TRIM(b.card_number), LENGTH(TRIM(b.card_number)) - 3, 4)
                     ELSE NULL
                   END AS last4,
                   b.note,
                   b.tags_json,
                   b.is_favorite,
                   b.created_at,
                   b.updated_at,
+                  b.archived_at,
                   b.deleted_at
                 FROM bank_cards b
                 WHERE b.deleted_at IS NULL
                 ORDER BY b.updated_at DESC
                 "#,
             )
             .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
@@
     })
 }
+
+pub fn set_bankcard_archived(
+    state: &Arc<AppState>,
+    profile_id: &str,
+    input: &SetBankCardArchivedInput,
+) -> Result<bool> {
+    with_connection(state, profile_id, |conn| {
+        let archived_at: Option<String> = if input.is_archived {
+            Some(Utc::now().to_rfc3339())
+        } else {
+            None
+        };
+
+        let rows = conn
+            .execute(
+                "UPDATE bank_cards SET archived_at = ?1, updated_at = ?2 WHERE id = ?3 AND deleted_at IS NULL",
+                params![archived_at, Utc::now().to_rfc3339(), input.id],
+            )
+            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+
+        if rows == 0 {
+            return Err(ErrorCodeString::new("BANK_CARD_NOT_FOUND"));
+        }
+
+        Ok(true)
+    })
+}
*** a/src-tauri/src/services/bank_cards_service.rs
--- b/src-tauri/src/services/bank_cards_service.rs
***************
*** 1,20 ****
 use std::sync::Arc;
 
 use crate::app_state::AppState;
 use crate::error::Result;
 use crate::security_service;
-use crate::types::{BankCardItem, BankCardSummary, CreateBankCardInput, SetBankCardFavoriteInput, UpdateBankCardInput};
+use crate::types::{
+    BankCardItem, BankCardSummary, CreateBankCardInput, SetBankCardArchivedInput,
+    SetBankCardFavoriteInput, UpdateBankCardInput,
+};
 
 use crate::data::sqlite::repo_impl;
@@
 pub fn set_bank_card_favorite(
     input: SetBankCardFavoriteInput,
     state: &Arc<AppState>,
 ) -> Result<bool> {
     let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
     let updated = repo_impl::set_bank_card_favorite(state, &profile_id, &input)?;
     security_service::request_persist_active_vault(state.clone());
     Ok(updated)
 }
+
+pub fn set_bankcard_archived(
+    input: SetBankCardArchivedInput,
+    state: &Arc<AppState>,
+) -> Result<bool> {
+    let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
+    let updated = repo_impl::set_bankcard_archived(state, &profile_id, &input)?;
+    security_service::request_persist_active_vault(state.clone());
+    Ok(updated)
+}
*** a/src-tauri/src/commands/bank_cards.rs
--- b/src-tauri/src/commands/bank_cards.rs
***************
*** 1,18 ****
 use std::sync::Arc;
 
 use tauri::State;
 
 use crate::app_state::AppState;
 use crate::error::{ErrorCodeString, Result};
 use crate::services::bank_cards_service;
-use crate::types::{BankCardItem, BankCardSummary, CreateBankCardInput, SetBankCardFavoriteInput, UpdateBankCardInput};
+use crate::types::{
+    BankCardItem, BankCardSummary, CreateBankCardInput, SetBankCardArchivedInput,
+    SetBankCardFavoriteInput, UpdateBankCardInput,
+};
@@
 #[tauri::command]
 pub async fn set_bank_card_favorite(
     input: SetBankCardFavoriteInput,
     state: State<'_, Arc<AppState>>,
 ) -> Result<bool> {
@@
 }
+
+#[tauri::command]
+pub async fn set_bankcard_archived(
+    input: SetBankCardArchivedInput,
+    state: State<'_, Arc<AppState>>,
+) -> Result<bool> {
+    let app = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || {
+        bank_cards_service::set_bankcard_archived(input, &app)
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
*** a/src-tauri/src/main.rs
--- b/src-tauri/src/main.rs
***************
*** 140,170 ****
             // bank cards
             list_bank_cards,
             get_bank_card,
             create_bank_card,
             update_bank_card,
             set_bank_card_favorite,
+            set_bankcard_archived,
             move_bank_card_to_folder,
             delete_bank_card,
             list_deleted_bank_cards,
             restore_bank_card,
             purge_bank_card,
*** a/src-tauri/permissions/app-default.toml
--- b/src-tauri/permissions/app-default.toml
***************
*** 30,60 ****
   "list_bank_cards",
   "get_bank_card",
   "create_bank_card",
   "update_bank_card",
   "set_bank_card_favorite",
+  "set_bankcard_archived",
   "move_bank_card_to_folder",
   "delete_bank_card",
   "list_deleted_bank_cards",
   "restore_bank_card",
   "purge_bank_card",
*** a/src/features/Vault/api/vaultApi.ts
--- b/src/features/Vault/api/vaultApi.ts
***************
*** 1,140 ****
@@
 export async function setBankCardFavorite(input: { id: string; is_favorite: boolean }): Promise<boolean> {
   return invoke('set_bank_card_favorite', { input });
 }
+
+export async function setBankCardArchived(input: { id: string; is_archived: boolean }): Promise<boolean> {
+  return invoke('set_bankcard_archived', { input });
+}
*** a/src/features/Vault/types/backend.ts
--- b/src/features/Vault/types/backend.ts
***************
*** 1,120 ****
@@
 export type BackendBankCardItem = {
   id: string;
   folder_id: string | null;
   title: string;
   cardholder: string | null;
   card_number: string | null;
   expiry_month: number | null;
   expiry_year: number | null;
   cvv: string | null;
   pin: string | null;
   note: string | null;
   tags: string[];
   is_favorite: boolean;
   created_at: string;
   updated_at: string;
+  archived_at: string | null;
   deleted_at: string | null;
 };
 
 export type BackendBankCardSummary = {
   id: string;
   folder_id: string | null;
   title: string;
   cardholder: string | null;
   last4: string | null;
   note: string | null;
   tags: string[];
   is_favorite: boolean;
   created_at: string;
   updated_at: string;
+  archived_at: string | null;
   deleted_at: string | null;
 };
*** a/src/features/Vault/types/ui.ts
--- b/src/features/Vault/types/ui.ts
***************
*** 120,170 ****
 export type BankCardItem = {
   id: string;
   folderId: string | null;
   title: string;
   cardholder: string | null;
   cardNumber: string | null;
   expiryMonth: number | null;
   expiryYear: number | null;
   cvv: string | null;
   pin: string | null;
   note: string | null;
   tags: string[];
   isFavorite: boolean;
   createdAt: string;
   updatedAt: string;
+  archivedAt: string | null;
   deletedAt: string | null;
 };
 
 export type BankCardSummary = {
   id: string;
   folderId: string | null;
   title: string;
   cardholder: string | null;
   last4: string | null;
   note: string | null;
   tags: string[];
   isFavorite: boolean;
   createdAt: string;
   updatedAt: string;
+  archivedAt: string | null;
   deletedAt: string | null;
 };
*** a/src/features/Vault/types/mappers.ts
--- b/src/features/Vault/types/mappers.ts
***************
*** 1,120 ****
@@
 export function mapBankCardFromBackend(card: BackendBankCardItem): BankCardItem {
   return {
     id: card.id,
     folderId: card.folder_id ?? null,
     title: card.title,
     cardholder: card.cardholder ?? null,
     cardNumber: card.card_number ?? null,
     expiryMonth: card.expiry_month ?? null,
     expiryYear: card.expiry_year ?? null,
     cvv: card.cvv ?? null,
     pin: card.pin ?? null,
     note: card.note ?? null,
     tags: card.tags ?? [],
     isFavorite: card.is_favorite,
     createdAt: card.created_at,
     updatedAt: card.updated_at,
+    archivedAt: card.archived_at ?? null,
     deletedAt: card.deleted_at ?? null,
   };
 }
 
 export function mapBankCardSummaryFromBackend(card: BackendBankCardSummary): BankCardSummary {
   return {
     id: card.id,
     folderId: card.folder_id ?? null,
     title: card.title,
     cardholder: card.cardholder ?? null,
     last4: card.last4 ?? null,
     note: card.note ?? null,
     tags: card.tags ?? [],
     isFavorite: card.is_favorite,
     createdAt: card.created_at,
     updatedAt: card.updated_at,
+    archivedAt: card.archived_at ?? null,
     deletedAt: card.deleted_at ?? null,
   };
 }
*** a/src/features/Vault/hooks/useBankCards.ts
--- b/src/features/Vault/hooks/useBankCards.ts
***************
*** 1,220 ****
@@
-import { setBankCardFavorite } from '../api/vaultApi';
+import { setBankCardArchived, setBankCardFavorite } from '../api/vaultApi';
@@
-const isArchived = (card: BankCardSummary) => (card.tags ?? []).includes('archived');
+const isArchived = (card: BankCardSummary) => Boolean(card.archivedAt);
@@
 export function useBankCards(...) {
@@
   const toggleFavorite = useCallback(async (id: string) => {
     ...
   }, [...]);
+
+  const toggleArchive = useCallback(
+    async (id: string) => {
+      const current = cards.find((c) => c.id === id);
+      if (!current) return;
+
+      const nextArchived = !current.archivedAt;
+      try {
+        await setBankCardArchived({ id: current.id, is_archived: nextArchived });
+        const nextArchivedAt = nextArchived ? new Date().toISOString() : null;
+        setCards((prev) => prev.map((c) => (c.id === current.id ? { ...c, archivedAt: nextArchivedAt } : c)));
+      } catch (err) {
+        handleError(err);
+      }
+    },
+    [cards, handleError]
+  );
@@
   return {
     ...
     toggleFavorite,
+    toggleArchive,
     ...
   };
 }
