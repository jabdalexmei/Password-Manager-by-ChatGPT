--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -431,23 +431,66 @@
     let key_backup_path = backup_root.join("key_check.bin.bak");
 
     let attachments_dir = profile_root.join("attachments");
-    let attachments_backup_dir = backup_root.join("attachments_plain");
-    let attachments_staging_dir = backup_root.join("attachments_encrypted_staging");
+    let attachments_backup_dir = backup_root.join("attachments_old");
+    let attachments_staging_dir = backup_root.join("attachments_reencrypted_staging");
 
     let vault_ok = vault_path.exists() && file_has_prefix(&vault_path, &cipher::PM_ENC_MAGIC);
     let salt_ok = salt_path.exists();
     let key_ok = key_path.exists();
 
-    // If all protected materials exist and no backups remain, treat as committed.
-    if vault_ok
-        && salt_ok
-        && key_ok
-        && !vault_backup_path.exists()
-        && !salt_backup_path.exists()
-        && !key_backup_path.exists()
-        && !attachments_backup_dir.exists()
-        && !attachments_staging_dir.exists()
-    {
+    // If protected materials exist, prefer completing the transition.
+    // change_profile_password writes new vault/key material first, then swaps attachments.
+    // After a crash, we might have a new vault but attachments still old-key.
+    if vault_ok && salt_ok && key_ok {
+        if attachments_staging_dir.exists() {
+            // Complete attachments swap if needed.
+            if attachments_dir.exists() {
+                if !attachments_backup_dir.exists() {
+                    rename_retry(
+                        &attachments_dir,
+                        &attachments_backup_dir,
+                        20,
+                        Duration::from_millis(50),
+                    )
+                    .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+                } else {
+                    // Backup already exists; clear current dir to make room for staging swap.
+                    std::fs::remove_dir_all(&attachments_dir)
+                        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+                }
+            }
+
+            if attachments_dir.exists() {
+                std::fs::remove_dir_all(&attachments_dir)
+                    .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+            }
+
+            if let Err(e) = rename_retry(
+                &attachments_staging_dir,
+                &attachments_dir,
+                20,
+                Duration::from_millis(50),
+            ) {
+                // Best-effort rollback: restore original attachments dir if we moved it.
+                if attachments_backup_dir.exists() && !attachments_dir.exists() {
+                    let _ = rename_retry(
+                        &attachments_backup_dir,
+                        &attachments_dir,
+                        20,
+                        Duration::from_millis(50),
+                    );
+                }
+                log::warn!(
+                    "[SECURITY][recover_change_password_transition] profile_id={} action=attachments_swap_failed err={}",
+                    profile_id,
+                    e
+                );
+                return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+            }
+        }
+
+        registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, true)?;
+        clear_pool(profile_id);
         let _ = std::fs::remove_dir_all(backup_root);
         return Ok(());
     }
