У тебя сейчас сразу две проблемы, и они **обе видны по симптомам**:

1. `Failed to set password: [object Object]` — это не “молчание”, это значит что **ошибка с бэка прилетает как JSON-объект**, а не строка. У тебя `ErrorCodeString` сериализуется как `{ code: "..." }`, поэтому `String(e)` даёт `[object Object]`. Tauri-команды действительно возвращают ошибки на фронт как rejected Promise. ([Tauri][1])

2. Пароль “не ставится” на passwordless профиль почти наверняка потому, что на Windows **`vault.db` нельзя атомарно переименовать/заменить, пока файл открыт SQLite-коннектами** (даже если они “idle”). В твоём логе видно, что пул постоянно открывает `vault.db` (`[DB][pool] target=File(...vault.db)`) — значит файл почти всегда открыт. Это типичный Windows-лок по открытому хендлу (SQLite/пул). ([Stack Overflow][2])

Ниже — конкретный фикс, который:

* показывает реальный `code` на UI (вместо `[object Object]`);
* **дожидается**, пока все выданные пулом коннекты вернутся, **сбрасывает пул** и тем самым закрывает файловые хендлы перед записью encrypted blob;
* логирует код ошибки на Rust-стороне + логирует `io::Error` при записи encrypted файла.

---

## PATCH

### 1) Frontend: показываем `e.code` (а не `message`)

```diff
diff --git a/src/features/Vault/components/modals/SettingsModal.tsx b/src/features/Vault/components/modals/SettingsModal.tsx
index bb4a80a..a2f3c44 100644
--- a/src/features/Vault/components/modals/SettingsModal.tsx
+++ b/src/features/Vault/components/modals/SettingsModal.tsx
@@ -169,10 +169,24 @@ export function SettingsModal({ open, settings, isSaving, onCancel, onSave, profi
     } catch (e) {
       // eslint-disable-next-line no-console
       console.error('profile_set_password failed:', e);
-      const code = (e as any)?.message ?? String(e);
-      showToast(`${tVault('settingsModal.profile.setPasswordError')}: ${code}`, 'error');
+
+      // Backend returns `ErrorCodeString { code: string }` serialized over invoke,
+      // so the useful value is usually on `e.code` (not `message`).
+      const anyErr = e as any;
+      const code =
+        anyErr?.code ??
+        anyErr?.error?.code ??
+        anyErr?.message ??
+        (() => {
+          try {
+            return JSON.stringify(anyErr);
+          } catch {
+            return String(anyErr);
+          }
+        })();
+
+      showToast(`${tVault('settingsModal.profile.setPasswordError')}: ${code}`, 'error');
     } finally {
       setIsSettingPassword(false);
     }
```

После этого ты увидишь, **какой именно код** падает (`ENCRYPTED_FILE_WRITE`, `DB_BUSY`, `PROFILE_STORAGE_WRITE`, …).

---

### 2) Backend: реально освобождаем `vault.db` перед заменой (Windows)

**Идея:** под `MaintenanceGuard` запрещаем новые выдачи коннектов, затем ждём, пока все уже взятые вернутся, и только после этого дропаем пул (тем самым закрывая idle-хендлы).

```diff
diff --git a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
index e0c1c4b..9b3f9b0 100644
--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -11,7 +11,7 @@ use crate::data::profiles::registry;
 use crate::data::sqlite::init::init_database_passwordless;
 use crate::data::sqlite::migrations;
-use crate::data::sqlite::pool::clear_pool;
+use crate::data::sqlite::pool::{clear_pool, drain_and_drop_profile_pools};
 use crate::data::sqlite::pool::MaintenanceGuard;
 
 pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) -> Result<ProfileMeta> {
@@ -286,9 +286,12 @@ pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) -> Result<ProfileMeta> {
     ensure_profile_dirs(&storage_paths, id)
         .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
 
     // Close file-based sqlite connections before touching vault.db bytes.
-    clear_pool(id);
+    // 1) Block new connections via MaintenanceGuard
+    // 2) Wait for checked-out connections to be returned
+    // 3) Drop pools to close idle connections and release OS file handles (Windows)
+    drain_and_drop_profile_pools(id, Duration::from_secs(5));
+    clear_pool(id);
```

---

### 3) Backend: логируем код ошибки в `set_profile_password`

```diff
diff --git a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
index 9b3f9b0..4c1c0a9 100644
--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -264,7 +264,11 @@ pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) -> Result<ProfileMeta> {
-    let storage_paths = state.get_storage_paths()?;
+    let res = (|| {
+        let storage_paths = state.get_storage_paths()?;
 
-    let profile = registry::get_profile(&storage_paths, id)?
+        let profile = registry::get_profile(&storage_paths, id)?
         .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
 
         // ...
-    match registry::upsert_profile_with_id(&storage_paths, id, &profile.name, true) {
+        match registry::upsert_profile_with_id(&storage_paths, id, &profile.name, true) {
             Ok(updated) => Ok(updated.into()),
             Err(_) => Ok(ProfileMeta { id: profile.id, name: profile.name, has_password: true }),
-    }
+        }
+    })();
+
+    if let Err(err) = &res {
+        log::error!("[SECURITY][set_profile_password] failed: code={}", err.code);
+    }
+    res
 }
```

---

### 4) Backend: логируем реальную `io::Error` при записи encrypted файла

```diff
diff --git a/src-tauri/src/data/crypto/cipher.rs b/src-tauri/src/data/crypto/cipher.rs
index 7b7d2d1..c27ed63 100644
--- a/src-tauri/src/data/crypto/cipher.rs
+++ b/src-tauri/src/data/crypto/cipher.rs
@@ -80,7 +80,10 @@ pub fn decrypt_bytes(key: &[u8; KEY_LEN], aad: &[u8], blob: &[u8]) -> Result<Vec<u8>> {
 }
 
 pub fn write_encrypted_file(path: &std::path::Path, blob: &[u8]) -> Result<()> {
-    write_atomic(path, blob).map_err(|_| ErrorCodeString::new("ENCRYPTED_FILE_WRITE"))
+    write_atomic(path, blob).map_err(|e| {
+        log::error!("[CRYPTO][write_encrypted_file] failed path={:?} err={:?}", path, e);
+        ErrorCodeString::new("ENCRYPTED_FILE_WRITE")
+    })
 }
```

---

## Что ты увидишь после этого

1. В тосте будет **чёткий код**, например `ENCRYPTED_FILE_WRITE` или `DB_BUSY`.
2. Если это `ENCRYPTED_FILE_WRITE`, в Rust-логе появится **настоящая причина** (`PermissionDenied`, `Access is denied`, и т.п.), и после drain/drop пулов оно обычно исчезает.
3. Если это вдруг не про файл-лок, а, например, `PROFILE_STORAGE_WRITE` — сразу станет видно куда копать.

Следующий шаг после твоего прогона: просто пришли **код из тоста** (теперь он будет нормальный), и строку из Rust-лога вида
`[CRYPTO][write_encrypted_file] failed ... err=...` — и мы добьём 100% без гаданий.

[1]: https://v2.tauri.app/develop/calling-rust/?utm_source=chatgpt.com "Calling Rust from the Frontend"
[2]: https://stackoverflow.com/questions/151026/how-do-i-unlock-an-sqlite-database?utm_source=chatgpt.com "How do I unlock an SQLite database?"
