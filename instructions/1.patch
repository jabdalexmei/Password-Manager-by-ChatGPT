

```diff
*** a/src-tauri/src/data/sqlite/repo_impl.rs
--- b/src-tauri/src/data/sqlite/repo_impl.rs
***************
*** 1,25 ****
  use chrono::Utc;
  use rusqlite::params;
  use rusqlite::types::Type;
  use rusqlite::OptionalExtension;
  use rusqlite::Connection;
  use uuid::Uuid;
@@
  use crate::types::{
      AttachmentMeta, BankCardItem, BankCardSummary, CreateBankCardInput, CreateDataCardInput,
-     DataCard, DataCardSummary, Folder, PasswordHistoryRow, SetBankCardArchivedInput,
+     CustomField, DataCard, DataCardSummary, Folder, PasswordHistoryRow, SetBankCardArchivedInput,
      SetBankCardFavoriteInput, SetDataCardArchivedInput, SetDataCardFavoriteInput,
      UpdateBankCardInput, UpdateDataCardInput,
  };
@@
  fn serialize_json<T: serde::Serialize>(value: &T) -> Result<String> {
      serde_json::to_string(value).map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))
  }
+
+fn normalize_for_search(input: &str) -> String {
+    input.to_lowercase()
+}
+
+fn matches_all_tokens(haystack: &str, query: &str) -> bool {
+    let q = normalize_for_search(query);
+    let tokens: Vec<&str> = q.split_whitespace().filter(|t| !t.is_empty()).collect();
+    if tokens.is_empty() {
+        return true;
+    }
+    let h = normalize_for_search(haystack);
+    tokens.into_iter().all(|t| h.contains(t))
+}
+
+pub fn search_datacard_ids(
+    state: &Arc<AppState>,
+    profile_id: &str,
+    query: &str,
+) -> Result<Vec<String>> {
+    with_connection(state, profile_id, |conn| {
+        let mut stmt = conn
+            .prepare(
+                r#"
+SELECT
+  d.id,
+  d.title,
+  d.url,
+  d.email,
+  d.recovery_email,
+  d.username,
+  d.mobile_phone,
+  d.note,
+  d.password_value,
+  d.tags_json,
+  d.custom_fields_json,
+  f.name AS folder_name,
+  (
+    SELECT GROUP_CONCAT(a.file_name, '\n')
+    FROM attachments a
+    WHERE a.datacard_id = d.id
+      AND a.deleted_at IS NULL
+  ) AS attachment_names
+FROM datacards d
+LEFT JOIN folders f ON f.id = d.folder_id
+"#,
+            )
+            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+
+        let rows = stmt
+            .query_map([], |row| {
+                let id: String = row.get("id")?;
+                let title: String = row.get("title")?;
+                let url: Option<String> = row.get("url")?;
+                let email: Option<String> = row.get("email")?;
+                let recovery_email: Option<String> = row.get("recovery_email")?;
+                let username: Option<String> = row.get("username")?;
+                let mobile_phone: Option<String> = row.get("mobile_phone")?;
+                let note: Option<String> = row.get("note")?;
+                let password: Option<String> = row.get("password_value")?;
+                let tags_json: String = row.get("tags_json")?;
+                let custom_fields_json: String = row.get("custom_fields_json")?;
+                let folder_name: Option<String> = row.get("folder_name")?;
+                let attachment_names: Option<String> = row.get("attachment_names")?;
+
+                let tags: Vec<String> = deserialize_json(tags_json).unwrap_or_default();
+                let custom_fields: Vec<CustomField> = deserialize_json(custom_fields_json).unwrap_or_default();
+
+                let mut blob = String::new();
+                blob.push_str(&title);
+                blob.push('\n');
+                if let Some(v) = url { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = email { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = recovery_email { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = username { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = mobile_phone { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = note { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = password { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = folder_name { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = attachment_names { blob.push_str(&v); blob.push('\n'); }
+
+                for t in tags {
+                    blob.push_str(&t);
+                    blob.push('\n');
+                }
+
+                for cf in custom_fields {
+                    blob.push_str(&cf.key);
+                    blob.push(':');
+                    blob.push_str(&cf.value);
+                    blob.push('\n');
+                }
+
+                // ВАЖНО: намеренно НЕ включаем в поиск:
+                // - seed_phrase_value
+                // - totp_uri
+                Ok((id, blob))
+            })
+            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+
+        let mut out: Vec<String> = Vec::new();
+        for row in rows {
+            let (id, blob) = row.map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+            if matches_all_tokens(&blob, query) {
+                out.push(id);
+            }
+        }
+        Ok(out)
+    })
+}
+
+pub fn search_bank_card_ids(
+    state: &Arc<AppState>,
+    profile_id: &str,
+    query: &str,
+) -> Result<Vec<String>> {
+    with_connection(state, profile_id, |conn| {
+        let mut stmt = conn
+            .prepare(
+                r#"
+SELECT
+  b.id,
+  b.title,
+  b.holder,
+  b.number,
+  b.note,
+  b.tags_json,
+  f.name AS folder_name
+FROM bank_cards b
+LEFT JOIN folders f ON f.id = b.folder_id
+"#,
+            )
+            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+
+        let rows = stmt
+            .query_map([], |row| {
+                let id: String = row.get("id")?;
+                let title: String = row.get("title")?;
+                let holder: Option<String> = row.get("holder")?;
+                let number: Option<String> = row.get("number")?;
+                let note: Option<String> = row.get("note")?;
+                let tags_json: String = row.get("tags_json")?;
+                let folder_name: Option<String> = row.get("folder_name")?;
+
+                let tags: Vec<String> = deserialize_json(tags_json).unwrap_or_default();
+
+                let mut blob = String::new();
+                blob.push_str(&title);
+                blob.push('\n');
+                if let Some(v) = holder { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = number { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = note { blob.push_str(&v); blob.push('\n'); }
+                if let Some(v) = folder_name { blob.push_str(&v); blob.push('\n'); }
+                for t in tags { blob.push_str(&t); blob.push('\n'); }
+
+                // ВАЖНО: намеренно НЕ включаем в поиск:
+                // - cvc (CVV)
+                // - expiry_mm_yy (Expiry)
+                // - pin (если добавишь в будущем)
+                Ok((id, blob))
+            })
+            .map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+
+        let mut out: Vec<String> = Vec::new();
+        for row in rows {
+            let (id, blob) = row.map_err(|_| ErrorCodeString::new("DB_QUERY_FAILED"))?;
+            if matches_all_tokens(&blob, query) {
+                out.push(id);
+            }
+        }
+        Ok(out)
+    })
+}
*** a/src-tauri/src/services/datacards_service.rs
--- b/src-tauri/src/services/datacards_service.rs
***************
*** 1,20 ****
  use std::sync::Arc;
@@
  use crate::data::sqlite::repo_impl;
@@
  pub fn list_deleted_datacards_summary(state: &Arc<AppState>) -> Result<Vec<DataCardSummary>> {
@@
  }
+
+pub fn search_datacard_ids(query: String, state: &Arc<AppState>) -> Result<Vec<String>> {
+    let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
+    repo_impl::search_datacard_ids(state, &profile_id, &query)
+}
*** a/src-tauri/src/services/bank_cards_service.rs
--- b/src-tauri/src/services/bank_cards_service.rs
***************
*** 1,30 ****
  use std::sync::Arc;
@@
  use crate::data::sqlite::repo_impl;
@@
  pub fn set_bankcard_archived(
@@
  }
+
+pub fn search_bank_card_ids(query: String, state: &Arc<AppState>) -> Result<Vec<String>> {
+    let profile_id = security_service::require_unlocked_active_profile(state)?.profile_id;
+    repo_impl::search_bank_card_ids(state, &profile_id, &query)
+}
*** a/src-tauri/src/commands/datacards.rs
--- b/src-tauri/src/commands/datacards.rs
***************
*** 1,12 ****
  use std::sync::Arc;
@@
  use crate::types::{
@@
  };
@@
  pub async fn set_datacard_favorite(
@@
  }
+
+#[tauri::command]
+pub async fn search_datacards(
+    query: String,
+    state: State<'_, Arc<AppState>>,
+) -> Result<Vec<String>> {
+    let app = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || datacards_service::search_datacard_ids(query, &app))
+        .await
+        .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
*** a/src-tauri/src/commands/bank_cards.rs
--- b/src-tauri/src/commands/bank_cards.rs
***************
*** 1,18 ****
  use std::sync::Arc;
@@
  use crate::types::{
@@
  };
@@
  pub async fn set_bankcard_archived(
@@
  }
+
+#[tauri::command]
+pub async fn search_bank_cards(
+    query: String,
+    state: State<'_, Arc<AppState>>,
+) -> Result<Vec<String>> {
+    let app = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || bank_cards_service::search_bank_card_ids(query, &app))
+        .await
+        .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
*** a/src-tauri/src/main.rs
--- b/src-tauri/src/main.rs
***************
*** 135,200 ****
          .invoke_handler(tauri::generate_handler![
@@
              set_datacard_favorite,
              set_datacard_archived,
+             search_datacards,
@@
              set_bank_card_favorite,
              set_bankcard_archived,
+             search_bank_cards,
@@
          ])
*** a/src-tauri/permissions/app-default.toml
--- b/src-tauri/permissions/app-default.toml
***************
*** 1,120 ****
  commands.allow = [
@@
    "set_datacard_archived",
+   "search_datacards",
@@
    "set_bankcard_archived",
+   "search_bank_cards",
@@
  ]
*** a/src/features/Vault/api/vaultApi.ts
--- b/src/features/Vault/api/vaultApi.ts
***************
*** 1,40 ****
  import { invoke } from '@tauri-apps/api/core';
@@
  export async function setBankCardArchived(input: { id: string; is_archived: boolean }): Promise<boolean> {
    return invoke('set_bankcard_archived', { input });
  }
+
+export async function searchDataCards(query: string): Promise<string[]> {
+  return invoke('search_datacards', { query });
+}
+
+export async function searchBankCards(query: string): Promise<string[]> {
+  return invoke('search_bank_cards', { query });
+}
*** a/src/features/Vault/hooks/useVault.ts
--- b/src/features/Vault/hooks/useVault.ts
***************
*** 1,20 ****
  import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
@@
  import {
@@
-  setDataCardArchived,
+  setDataCardArchived,
+  searchDataCards,
  } from '../api/vaultApi';
@@
   const [searchInput, setSearchInput] = useState('');
   const debouncedSearchQuery = useDebouncedValue(searchInput, 200);
+  const [searchMatchIds, setSearchMatchIds] = useState<Set<string> | null>(null);
+
+  useEffect(() => {
+    const q = debouncedSearchQuery.trim();
+    if (!q) {
+      setSearchMatchIds(null);
+      return;
+    }
+
+    let cancelled = false;
+    searchDataCards(q)
+      .then((ids) => {
+        if (cancelled) return;
+        setSearchMatchIds(new Set(ids));
+      })
+      .catch((err) => {
+        console.error(err);
+        if (cancelled) return;
+        setSearchMatchIds(new Set());
+      });
+
+    return () => {
+      cancelled = true;
+    };
+  }, [debouncedSearchQuery]);
@@
-    if (!debouncedSearchQuery.trim()) return pool;
-
-    const query = debouncedSearchQuery.toLowerCase();
-    return pool.filter((card) => {
-      const fields = [card.title, card.username, card.email, card.url, card.metaLine, ...(card.tags || [])];
-      return fields.some((field) => field && field.toLowerCase().includes(query));
-    });
-  }, [cards, debouncedSearchQuery, deletedCards, filters, selectedNav]);
+    if (!debouncedSearchQuery.trim()) return pool;
+    if (!searchMatchIds) return pool;
+    return pool.filter((card) => searchMatchIds.has(card.id));
+  }, [cards, debouncedSearchQuery, deletedCards, filters, searchMatchIds, selectedNav]);
*** a/src/features/Vault/hooks/useBankCards.ts
--- b/src/features/Vault/hooks/useBankCards.ts
***************
*** 1,16 ****
  import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
@@
- import { setBankCardArchived, setBankCardFavorite } from '../api/vaultApi';
+ import { searchBankCards, setBankCardArchived, setBankCardFavorite } from '../api/vaultApi';
@@
   const [searchInput, setSearchInput] = useState('');
   const debouncedSearchQuery = useDebouncedValue(searchInput, 200);
+  const [searchMatchIds, setSearchMatchIds] = useState<Set<string> | null>(null);
+
+  useEffect(() => {
+    const q = debouncedSearchQuery.trim();
+    if (!q) {
+      setSearchMatchIds(null);
+      return;
+    }
+
+    let cancelled = false;
+    searchBankCards(q)
+      .then((ids) => {
+        if (cancelled) return;
+        setSearchMatchIds(new Set(ids));
+      })
+      .catch((err) => {
+        console.error(err);
+        if (cancelled) return;
+        setSearchMatchIds(new Set());
+      });
+
+    return () => {
+      cancelled = true;
+    };
+  }, [debouncedSearchQuery]);
@@
-    if (!debouncedSearchQuery.trim()) return pool;
-
-    const query = debouncedSearchQuery.toLowerCase();
-    return pool.filter((card) => {
-      const fields = [card.title, card.metaLine, ...(card.tags || [])];
-      return fields.some((field) => field && field.toLowerCase().includes(query));
-    });
-  }, [cards, debouncedSearchQuery, deletedCards, selectedNav]);
+    if (!debouncedSearchQuery.trim()) return pool;
+    if (!searchMatchIds) return pool;
+    return pool.filter((card) => searchMatchIds.has(card.id));
+  }, [cards, debouncedSearchQuery, deletedCards, searchMatchIds, selectedNav]);
```

