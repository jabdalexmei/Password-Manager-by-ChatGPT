diff --git a/src-tauri/src/data/profiles/registry.rs b/src-tauri/src/data/profiles/registry.rs
index 9b60d00..0600249 100644
--- a/src-tauri/src/data/profiles/registry.rs
+++ b/src-tauri/src/data/profiles/registry.rs
@@ -7,6 +7,7 @@ use uuid::Uuid;
 use crate::data::crypto::cipher::PM_ENC_MAGIC;
 use crate::data::fs::atomic_write::write_atomic;
 use crate::data::profiles::paths::{
+    dpapi_key_path,
     ensure_profiles_dir,
     key_check_path,
     kdf_salt_path,
@@ -14,6 +15,7 @@ use crate::data::profiles::paths::{
     profile_dir,
     registry_path,
     vault_db_path,
+    vault_key_path,
 };
 use crate::data::storage_paths::StoragePaths;
 use crate::error::{ErrorCodeString, Result};
@@ -212,23 +214,35 @@ fn vault_looks_plaintext(sp: &StoragePaths, id: &str) -> bool {
 }
 
 fn infer_has_password(sp: &StoragePaths, id: &str, record_has_password: bool) -> bool {
-    // If the vault is clearly a plaintext SQLite database, treat the profile as passwordless even
+    // Legacy: if the vault is clearly a plaintext SQLite database, treat the profile as passwordless even
     // if registry/config got out of sync (e.g. interrupted remove password / restore / bug).
     if vault_looks_plaintext(sp, id) {
         return false;
     }
 
-    // If the registry says protected, keep it protected unless we have positive evidence of passwordless.
-    if record_has_password {
+    // New security model: vault.db is ALWAYS encrypted on disk.
+    // The password requirement is determined by which master-key wrapper exists:
+    //   - dpapi_key.bin  -> passwordless (DPAPI unlock)
+    //   - vault_key.bin  -> password required (KDF unlock)
+    let dpapi_ok = dpapi_key_path(sp, id).ok().is_some_and(|p| p.exists());
+    if dpapi_ok {
+        return false;
+    }
+
+    let vault_key_ok = vault_key_path(sp, id).ok().is_some_and(|p| p.exists());
+    if vault_key_ok {
         return true;
     }
 
+    // Backwards-compatibility / partial upgrades: if we see salt+key_check, treat as password-protected.
     let salt_ok = kdf_salt_path(sp, id).ok().is_some_and(|p| p.exists());
     let key_ok = key_check_path(sp, id).ok().is_some_and(|p| p.exists());
     if salt_ok && key_ok {
         return true;
     }
-    vault_looks_encrypted(sp, id)
+
+    // Fall back to the registry value.
+    record_has_password
 }
 
 pub fn list_profiles(sp: &StoragePaths) -> Result<Vec<ProfileMeta>> {
@@ -422,4 +436,4 @@ pub fn get_profile(sp: &StoragePaths, id: &str) -> Result<Option<ProfileRecord>>
         None => return Ok(None),
     };
     Ok(Some(registry.profiles[idx].clone()))
-}
+}
\ No newline at end of file
diff --git a/src-tauri/src/services/profiles_service.rs b/src-tauri/src/services/profiles_service.rs
index 57d1345..35f2f76 100644
--- a/src-tauri/src/services/profiles_service.rs
+++ b/src-tauri/src/services/profiles_service.rs
@@ -1,10 +1,11 @@
 use crate::data::crypto::kdf::{derive_master_key, generate_kdf_salt};
+use crate::data::crypto::master_key;
 use crate::data::crypto::key_check;
 use crate::data::fs::atomic_write::write_atomic;
 use crate::data::profiles::paths::{ensure_profile_dirs, kdf_salt_path};
 use crate::data::profiles::registry;
 use crate::data::settings::config;
-use crate::data::sqlite::init::{init_database_passwordless, init_database_protected_encrypted};
+use crate::data::sqlite::init::init_database_protected_encrypted;
 use crate::data::storage_paths::StoragePaths;
 use crate::error::{ErrorCodeString, Result};
 use crate::services::settings_service::get_settings;
@@ -37,18 +38,27 @@ pub fn create_profile(
         ensure_profile_dirs(sp, &profile.id)
             .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
 
+        // New security model: vault.db is ALWAYS an encrypted blob on disk.
+        // Password vs passwordless only changes how the master key is wrapped:
+        //   - password mode: master key is wrapped by a KDF-derived wrapping key (vault_key.bin + salt + key_check)
+        //   - passwordless: master key is wrapped by Windows DPAPI (dpapi_key.bin)
+
+        let mk = master_key::generate_master_key();
+        init_database_protected_encrypted(sp, &profile.id, &mk)?;
+
         let is_passwordless = password.as_ref().map(|p| p.is_empty()).unwrap_or(true);
         if is_passwordless {
-            init_database_passwordless(sp, &profile.id)?;
+            master_key::write_master_key_wrapped_with_dpapi(sp, &profile.id, &mk)?;
         } else {
             let salt = generate_kdf_salt();
             let salt_path = kdf_salt_path(sp, &profile.id)?;
             write_atomic(&salt_path, &salt)
                 .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+
             let pwd = password.unwrap_or_default();
-            let key = Zeroizing::new(derive_master_key(&pwd, &salt)?);
-            key_check::create_key_check_file(sp, &profile.id, &key)?;
-            init_database_protected_encrypted(sp, &profile.id, &key)?;
+            let wrapping = Zeroizing::new(derive_master_key(&pwd, &salt)?);
+            key_check::create_key_check_file(sp, &profile.id, &wrapping)?;
+            master_key::write_master_key_wrapped_with_password(sp, &profile.id, &wrapping, &mk)?;
         }
 
         let _ = get_settings(sp, &profile.id)?;
