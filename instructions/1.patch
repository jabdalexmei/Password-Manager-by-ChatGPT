diff --git a/package.json b/package.json
index 4e6aa2f..a5fdab3 100644
--- a/package.json
+++ b/package.json
@@ -1,19 +1,21 @@
 {
   "name": "Password-Manager",
   "version": "0.1.0",
   "private": true,
   "type": "module",
   "scripts": {
     "dev": "vite",
-    "build": "vite build",
-    "analyze": "vite build --mode analyze",
+    "zxing:guard": "node scripts/check-no-zxing-imports.mjs",
+    "build": "npm run zxing:guard && vite build",
+    "analyze": "npm run zxing:guard && vite build --mode analyze",
     "tauri:dev": "tauri dev",
     "tauri:build": "tauri build",
     "theme:check": "node scripts/check-theme-colors.mjs",
     "icons:check": "node scripts/check-no-inline-svg.mjs"
   },
   "dependencies": {
     "@zxing/browser": "^0.1.5",
     "@tauri-apps/api": "2.0.0",
     "@tauri-apps/plugin-dialog": "^2.0.0",
diff --git a/scripts/check-no-zxing-imports.mjs b/scripts/check-no-zxing-imports.mjs
new file mode 100644
index 0000000..b9e37b7
--- /dev/null
+++ b/scripts/check-no-zxing-imports.mjs
@@ -0,0 +1,107 @@
+import { readdir, readFile } from 'node:fs/promises';
+import path from 'node:path';
+
+const projectRoot = process.cwd();
+const srcRoot = path.join(projectRoot, 'src');
+
+// The only allowed place to mention @zxing/* is the loader.
+const allowedFile = path.join(srcRoot, 'shared', 'lib', 'zxingLoader.ts');
+
+/**
+ * @param {string} dir
+ * @returns {Promise<string[]>}
+ */
+async function walk(dir) {
+  const entries = await readdir(dir, { withFileTypes: true });
+  const out = [];
+  for (const e of entries) {
+    const full = path.join(dir, e.name);
+    if (e.isDirectory()) {
+      out.push(...(await walk(full)));
+      continue;
+    }
+    if (/\.(ts|tsx)$/.test(e.name)) out.push(full);
+  }
+  return out;
+}
+
+/**
+ * @param {string} file
+ * @param {string} content
+ * @returns {Array<{line: number, text: string}>}
+ */
+function findOffenses(file, content) {
+  if (path.resolve(file) === path.resolve(allowedFile)) return [];
+
+  // Catch:
+  //  - import ... from '@zxing/...'
+  //  - await import('@zxing/...')
+  //  - require('@zxing/...')
+  const patterns = [
+    /from\s+['"]@zxing\//,
+    /import\s*\(\s*['"]@zxing\//,
+    /require\s*\(\s*['"]@zxing\//,
+    /['"]@zxing\//, // belt & suspenders: any mention outside loader is forbidden
+  ];
+
+  const lines = content.split(/\r?\n/);
+  /** @type {Array<{line: number, text: string}>} */
+  const hits = [];
+
+  for (let i = 0; i < lines.length; i++) {
+    const lineText = lines[i];
+    if (patterns.some((p) => p.test(lineText))) {
+      hits.push({ line: i + 1, text: lineText });
+    }
+  }
+  return hits;
+}
+
+const files = await walk(srcRoot);
+/** @type {Array<{file: string, hits: Array<{line: number, text: string}>}>} */
+const bad = [];
+
+for (const f of files) {
+  const content = await readFile(f, 'utf8');
+  const hits = findOffenses(f, content);
+  if (hits.length) bad.push({ file: f, hits });
+}
+
+if (bad.length) {
+  console.error('✖ Forbidden @zxing/* usage detected outside src/shared/lib/zxingLoader.ts');
+  console.error('  Use the loader instead to keep ZXing lazy and prevent chunk regressions.\n');
+  for (const item of bad) {
+    const rel = path.relative(projectRoot, item.file);
+    console.error(`- ${rel}`);
+    for (const h of item.hits) {
+      console.error(`    L${h.line}: ${h.text}`);
+    }
+    console.error('');
+  }
+  process.exit(1);
+}
+
+console.log('✓ ZXing import guard passed');
diff --git a/src/shared/lib/zxingLoader.ts b/src/shared/lib/zxingLoader.ts
new file mode 100644
index 0000000..d84f35d
--- /dev/null
+++ b/src/shared/lib/zxingLoader.ts
@@ -0,0 +1,44 @@
+type ZxingBrowserModule = typeof import('@zxing/browser');
+
+let zxingBrowserPromise: Promise<ZxingBrowserModule> | null = null;
+
+async function loadZxingBrowser(): Promise<ZxingBrowserModule> {
+  if (!zxingBrowserPromise) {
+    zxingBrowserPromise = import('@zxing/browser');
+  }
+  return zxingBrowserPromise;
+}
+
+export async function decodeQrFromImageFile(file: File): Promise<string> {
+  const url = URL.createObjectURL(file);
+  try {
+    const { BrowserQRCodeReader } = await loadZxingBrowser();
+    const reader = new BrowserQRCodeReader();
+    const decoded = await reader.decodeFromImageUrl(url);
+    return decoded.getText();
+  } finally {
+    URL.revokeObjectURL(url);
+  }
+}
diff --git a/src/features/Vault/components/modals/Add2FAModal.tsx b/src/features/Vault/components/modals/Add2FAModal.tsx
index 3b5b8d1..c4a0c53 100644
--- a/src/features/Vault/components/modals/Add2FAModal.tsx
+++ b/src/features/Vault/components/modals/Add2FAModal.tsx
@@ -1,6 +1,7 @@
 import React, { useEffect, useMemo, useState } from 'react';
 import { useTranslation } from '../../../../shared/lib/i18n';
 import { normalizeTotpInput } from '../../utils/totp';
+import { decodeQrFromImageFile } from '../../../../shared/lib/zxingLoader';
 
 type Props = {
   isOpen: boolean;
@@ -59,26 +60,19 @@ export const Add2FAModal: React.FC<Props> = ({
   };
 
   const handleQrFile = async (file: File) => {
     setError(null);
     setBusy(true);
     try {
-      const url = URL.createObjectURL(file);
-      try {
-        const { BrowserQRCodeReader } = await import('@zxing/browser');
-        const reader = new BrowserQRCodeReader();
-        const decoded = await reader.decodeFromImageUrl(url);
-        const text = decoded.getText();
-        const norm = normalizeTotpInput(text, defaults);
-        if (!norm.ok) {
-          setError(t(`twoFactor.error.${norm.error}`));
-          return;
-        }
-        setTextValue(norm.uri);
-      } finally {
-        URL.revokeObjectURL(url);
-      }
+      const text = await decodeQrFromImageFile(file);
+      const norm = normalizeTotpInput(text, defaults);
+      if (!norm.ok) {
+        setError(t(`twoFactor.error.${norm.error}`));
+        return;
+      }
+      setTextValue(norm.uri);
     } catch {
       setError(t('twoFactor.error.QR_DECODE_FAILED'));
     } finally {
       setBusy(false);
     }
   };
