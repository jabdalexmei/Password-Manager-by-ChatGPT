diff -ruN a/src-tauri/src/data/fs/atomic_write.rs b/src-tauri/src/data/fs/atomic_write.rs
--- a/src-tauri/src/data/fs/atomic_write.rs	2026-01-18 00:13:20.000000000 +0000
+++ b/src-tauri/src/data/fs/atomic_write.rs	2026-01-18 00:19:05.284886234 +0000
@@ -1,4 +1,4 @@
-use std::fs::{self, OpenOptions};
+use std::fs::{self, OpenOptions, File};
 #[cfg(unix)]
 use std::os::unix::fs::OpenOptionsExt;
 use std::io::{self, Write};
@@ -33,6 +33,18 @@
         Err(last.unwrap_or_else(|| io::Error::new(io::ErrorKind::Other, "rename failed")))
     }
 
+    fn sync_dir_best_effort(dir: &Path) {
+        #[cfg(unix)]
+        {
+            // Best-effort: ignore errors (some FS/OS might not support syncing dirs).
+            // fsync() on a file does not necessarily persist directory entry updates
+            // (rename/unlink) across crash/power-loss; syncing the directory helps.
+            if let Ok(f) = File::open(dir) {
+                let _ = f.sync_all();
+            }
+        }
+    }
+
     let parent = path.parent().ok_or_else(|| {
         io::Error::new(io::ErrorKind::InvalidInput, "write_atomic: path has no parent")
     })?;
@@ -67,10 +79,12 @@
 
         // 3) move temp into place
         rename_with_retry(&tmp_path, path)?;
+        sync_dir_best_effort(parent);
 
         // 4) remove backup
         if bak_path.exists() {
             let _ = fs::remove_file(&bak_path);
+            sync_dir_best_effort(parent);
         }
 
         Ok(())
@@ -80,7 +94,9 @@
     if result.is_err() {
         let _ = fs::remove_file(&tmp_path);
         if bak_path.exists() && !path.exists() {
-            let _ = fs::rename(&bak_path, path);
+            if fs::rename(&bak_path, path).is_ok() {
+                sync_dir_best_effort(parent);
+            }
         }
     }
 
diff -ruN a/src-tauri/src/data/profiles/registry.rs b/src-tauri/src/data/profiles/registry.rs
--- a/src-tauri/src/data/profiles/registry.rs	2026-01-18 00:13:20.000000000 +0000
+++ b/src-tauri/src/data/profiles/registry.rs	2026-01-18 00:21:27.786473801 +0000
@@ -193,10 +193,6 @@
 pub fn list_profiles(sp: &StoragePaths) -> Result<Vec<ProfileMeta>> {
     let mut registry = load_registry(sp)?;
 
-    // Crash-safe rename recovery for this profile (best-effort).
-    if recover_pending_profile_renames(sp, &mut registry) {
-        let _ = save_registry(sp, &registry);
-    }
     let mut dirty = false;
 
     // Crash-safe rename recovery: if a prior rename left a marker, finish it now.
@@ -301,11 +297,6 @@
     }
 
     let mut registry = load_registry(sp)?;
-
-    // Crash-safe rename recovery for this profile (best-effort).
-    if recover_pending_profile_renames(sp, &mut registry) {
-        let _ = save_registry(sp, &registry);
-    }
     if let Some(existing) = registry.profiles.iter_mut().find(|p| p.id == id) {
         existing.name = name.to_string();
         existing.has_password = has_password;
diff -ruN a/src-tauri/src/services/backup_service.rs b/src-tauri/src/services/backup_service.rs
--- a/src-tauri/src/services/backup_service.rs	2026-01-18 00:13:20.000000000 +0000
+++ b/src-tauri/src/services/backup_service.rs	2026-01-18 00:21:05.351119698 +0000
@@ -170,6 +170,32 @@
 }
 
 
+
+
+fn sync_dir_best_effort(dir: &Path) {
+    #[cfg(unix)]
+    {
+        if let Ok(f) = std::fs::File::open(dir) {
+            let _ = f.sync_all();
+        }
+    }
+}
+
+fn sync_rename_parents_best_effort(from: &Path, to: &Path) {
+    let from_dir = from.parent();
+    let to_dir = to.parent();
+
+    if let Some(d) = from_dir {
+        sync_dir_best_effort(d);
+    }
+
+    match (from_dir, to_dir) {
+        (Some(fd), Some(td)) if fd == td => {}
+        (_, Some(td)) => sync_dir_best_effort(td),
+        _ => {}
+    }
+}
+
 fn rename_with_retry(src: &Path, dst: &Path) -> std::io::Result<()> {
     use std::time::Duration;
 
@@ -179,7 +205,10 @@
     let mut last_err: Option<std::io::Error> = None;
     for _ in 0..ATTEMPTS {
         match fs::rename(src, dst) {
-            Ok(()) => return Ok(()),
+            Ok(()) => {
+                sync_rename_parents_best_effort(src, dst);
+                return Ok(());
+            }
             Err(e) => {
                 if e.kind() == std::io::ErrorKind::PermissionDenied {
                     last_err = Some(e);
diff -ruN a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
--- a/src-tauri/src/services/security_service.rs	2026-01-18 00:13:20.000000000 +0000
+++ b/src-tauri/src/services/security_service.rs	2026-01-18 00:20:22.652535164 +0000
@@ -927,11 +927,46 @@
     Ok(())
 }
 
+
+
+fn sync_dir_best_effort(dir: &Path) {
+    #[cfg(unix)]
+    {
+        if let Ok(f) = std::fs::File::open(dir) {
+            let _ = f.sync_all();
+        }
+    }
+}
+
+fn sync_rename_parents_best_effort(from: &Path, to: &Path) {
+    let from_dir = from.parent();
+    let to_dir = to.parent();
+
+    if let Some(d) = from_dir {
+        sync_dir_best_effort(d);
+    }
+
+    match (from_dir, to_dir) {
+        (Some(fd), Some(td)) if fd == td => {}
+        (_, Some(td)) => sync_dir_best_effort(td),
+        _ => {}
+    }
+}
+
+fn sync_unlink_parent_best_effort(path: &Path) {
+    if let Some(dir) = path.parent() {
+        sync_dir_best_effort(dir);
+    }
+}
+
 fn rename_retry(from: &Path, to: &Path, attempts: u32, base_delay: Duration) -> io::Result<()> {
     let mut i = 0;
     loop {
         match std::fs::rename(from, to) {
-            Ok(()) => return Ok(()),
+            Ok(()) => {
+                sync_rename_parents_best_effort(from, to);
+                return Ok(());
+            }
             Err(e) => {
                 i += 1;
                 if i >= attempts {
@@ -949,7 +984,12 @@
     let mut i = 0;
     loop {
         match std::fs::remove_file(path) {
-            Ok(()) => return Ok(()),
+            Ok(()) => {
+                if let Some(parent) = path.parent() {
+                    sync_dir_best_effort(parent);
+                }
+                return Ok(());
+            },
             Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(()),
             Err(e) => {
                 i += 1;
