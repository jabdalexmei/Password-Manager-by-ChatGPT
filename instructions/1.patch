

---

## ✅ Frontend: кнопка + confirm dialog

### `src/features/Vault/components/modals/SettingsModal.tsx`

```diff
*** Begin Patch
*** Update File: src/features/Vault/components/modals/SettingsModal.tsx
@@
 import React, { useCallback, useEffect, useMemo, useState } from 'react';
 import { BackendUserSettings } from '../../types/backend';
 import { useTranslation } from '../../../../shared/lib/i18n';
 import { useToaster } from '../../../../shared/components/Toaster';
+import ConfirmDialog from '../../../../shared/components/ConfirmDialog';
 import {
   changeProfilePassword,
+  removeProfilePassword,
   renameProfile,
   setProfilePassword,
   type ProfileMeta,
 } from '../../../../shared/lib/tauri';
 import { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from '../../../../shared/ui/dialog';
@@
   const [changePasswordOpen, setChangePasswordOpen] = useState(false);
   const [changePasswordValue, setChangePasswordValue] = useState('');
   const [changePasswordConfirm, setChangePasswordConfirm] = useState('');
   const [isChangingPassword, setIsChangingPassword] = useState(false);
 
+  const [removePasswordConfirmOpen, setRemovePasswordConfirmOpen] = useState(false);
+  const [isRemovingPassword, setIsRemovingPassword] = useState(false);
+
@@
   useEffect(() => {
     if (!changePasswordOpen) return;
     setChangePasswordValue('');
     setChangePasswordConfirm('');
   }, [changePasswordOpen]);
 
+  useEffect(() => {
+    if (profileHasPassword) return;
+    setRemovePasswordConfirmOpen(false);
+  }, [profileHasPassword]);
+
@@
   const handleChangePasswordSave = async () => {
@@
   };
 
+  const handleRemovePasswordConfirm = async () => {
+    if (!profileHasPassword) return;
+
+    setIsRemovingPassword(true);
+    try {
+      const updated = await removeProfilePassword(profileId);
+      onProfileUpdated?.(updated);
+      showToast(tVault('settingsModal.profile.removePasswordSuccess'));
+      setRemovePasswordConfirmOpen(false);
+    } catch {
+      showToast(tVault('settingsModal.profile.removePasswordError'), 'error');
+    } finally {
+      setIsRemovingPassword(false);
+    }
+  };
+
@@
           <div className="settings-profile-actions" role="group" aria-labelledby="profile-title">
@@
             <button
               className="btn btn-secondary settings-profile-action"
               type="button"
               onClick={() => setChangePasswordOpen(true)}
               disabled={busy || isRenamingProfile || isChangingPassword || !profileHasPassword}
             >
               {tVault('settingsModal.profile.changePasswordAction')}
             </button>
+
+            <button
+              className="btn btn-danger settings-profile-action"
+              type="button"
+              onClick={() => setRemovePasswordConfirmOpen(true)}
+              disabled={
+                busy ||
+                isRenamingProfile ||
+                isSettingPassword ||
+                isChangingPassword ||
+                isRemovingPassword ||
+                !profileHasPassword
+              }
+            >
+              {tVault('settingsModal.profile.removePasswordAction')}
+            </button>
           </div>
@@
     </Dialog>
 
@@
     </Dialog>
+
+    <ConfirmDialog
+      open={removePasswordConfirmOpen}
+      title={tVault('settingsModal.profile.removePasswordTitle')}
+      description={tVault('settingsModal.profile.removePasswordDescription')}
+      confirmLabel={tVault('settingsModal.profile.removePasswordConfirmAction')}
+      cancelLabel={tCommon('action.cancel')}
+      onConfirm={handleRemovePasswordConfirm}
+      onCancel={() => setRemovePasswordConfirmOpen(false)}
+      confirmDisabled={busy || isRemovingPassword}
+      cancelDisabled={busy || isRemovingPassword}
+    />
     </>
   );
 }
*** End Patch
```

---

## ✅ i18n: тексты для кнопки/подтверждения

### `src/i18n/locales/en/Vault.json`

```diff
*** Begin Patch
*** Update File: src/i18n/locales/en/Vault.json
@@
   "settingsModal.profile.changePasswordSuccess": "Password changed",
-  "settingsModal.profile.changePasswordError": "Failed to change password"
+  "settingsModal.profile.changePasswordError": "Failed to change password",
+
+  "settingsModal.profile.removePasswordAction": "Remove password",
+  "settingsModal.profile.removePasswordTitle": "Remove password",
+  "settingsModal.profile.removePasswordDescription": "This will remove the password from this profile and make it passwordless. Anyone with access to this device account will be able to open it.",
+  "settingsModal.profile.removePasswordConfirmAction": "Remove password",
+  "settingsModal.profile.removePasswordSuccess": "Password removed",
+  "settingsModal.profile.removePasswordError": "Failed to remove password"
 }
*** End Patch
```

---

## ✅ Backend: команда Tauri + миграция vault/attachments

### `src-tauri/src/commands/security.rs`

```diff
*** Begin Patch
*** Update File: src-tauri/src/commands/security.rs
@@
 pub async fn profile_change_password(
@@
 }
 
+#[tauri::command]
+pub async fn profile_remove_password(
+    id: String,
+    state: State<'_, Arc<AppState>>,
+) -> Result<ProfileMeta> {
+    let app_state = state.inner().clone();
+    tauri::async_runtime::spawn_blocking(move || {
+        security_service::remove_profile_password(&id, &app_state)
+    })
+    .await
+    .map_err(|_| ErrorCodeString::new("TASK_JOIN_FAILED"))?
+}
+
 #[tauri::command]
 pub async fn health_check() -> Result<bool> {
*** End Patch
```

### `src-tauri/src/main.rs`

```diff
*** Begin Patch
*** Update File: src-tauri/src/main.rs
@@
             profile_set_password,
             profile_change_password,
+            profile_remove_password,
             get_active_profile,
*** End Patch
```

### `src-tauri/permissions/app-default.toml`

```diff
*** Begin Patch
*** Update File: src-tauri/permissions/app-default.toml
@@
   "profile_set_password",
   "profile_change_password",
+  "profile_remove_password",
   "get_active_profile",
*** End Patch
```

---

## ✅ Core логика: remove password (с rollback)

### `src-tauri/src/services/security_service.rs`

```diff
*** Begin Patch
*** Update File: src-tauri/src/services/security_service.rs
@@
 use rusqlite::backup::Backup;
+use rusqlite::Connection;
 use rusqlite::OpenFlags;
 use rusqlite::ffi;
 use rusqlite::serialize::OwnedData;
 use rusqlite::DatabaseName;
 use zeroize::{Zeroize, Zeroizing};
@@
-use crate::data::profiles::paths::{ensure_profile_dirs, kdf_salt_path, vault_db_path};
+use crate::data::profiles::paths::{
+    ensure_profile_dirs, kdf_salt_path, key_check_path, profile_dir, vault_db_path,
+};
@@
 pub fn change_profile_password(id: &str, password: &str, state: &Arc<AppState>) -> Result<bool> {
@@
     Ok(true)
 }
 
+#[derive(Debug, Clone)]
+struct RemovePasswordRollback {
+    vault_path: std::path::PathBuf,
+    vault_backup_path: std::path::PathBuf,
+
+    salt_path: std::path::PathBuf,
+    salt_backup_path: std::path::PathBuf,
+    salt_moved: bool,
+
+    key_check_path: std::path::PathBuf,
+    key_check_backup_path: std::path::PathBuf,
+    key_check_moved: bool,
+
+    attachments_dir: std::path::PathBuf,
+    attachments_backup_dir: std::path::PathBuf,
+    attachments_swapped: bool,
+}
+
+fn rollback_remove_profile_password(
+    _state: &Arc<AppState>,
+    storage_paths: &crate::data::storage_paths::StoragePaths,
+    profile_id: &str,
+    profile_name: &str,
+    rb: &RemovePasswordRollback,
+) {
+    log::warn!(
+        "[SECURITY][remove_profile_password] rolling back failed operation for profile_id={}",
+        profile_id
+    );
+
+    if rb.attachments_swapped {
+        let _ = std::fs::remove_dir_all(&rb.attachments_dir);
+        let _ = std::fs::rename(&rb.attachments_backup_dir, &rb.attachments_dir);
+    }
+
+    let _ = std::fs::remove_file(&rb.vault_path);
+    let _ = std::fs::rename(&rb.vault_backup_path, &rb.vault_path);
+
+    if rb.salt_moved {
+        let _ = std::fs::rename(&rb.salt_backup_path, &rb.salt_path);
+    }
+
+    if rb.key_check_moved {
+        let _ = std::fs::rename(&rb.key_check_backup_path, &rb.key_check_path);
+    }
+
+    let _ = registry::upsert_profile_with_id(storage_paths, profile_id, profile_name, true);
+    clear_pool(profile_id);
+}
+
+pub fn remove_profile_password(id: &str, state: &Arc<AppState>) -> Result<ProfileMeta> {
+    let storage_paths = state.get_storage_paths()?;
+
+    let profile = registry::get_profile(&storage_paths, id)?
+        .ok_or_else(|| ErrorCodeString::new("PROFILE_NOT_FOUND"))?;
+
+    if !profile.has_password {
+        return Err(ErrorCodeString::new("PROFILE_NOT_PROTECTED"));
+    }
+
+    // Prevent concurrent persists while we migrate from encrypted/in-memory to passwordless/on-disk.
+    let _persist_guard = state
+        .vault_persist_guard
+        .lock()
+        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+
+    // Lock session for whole operation.
+    let mut session_guard = state
+        .vault_session
+        .lock()
+        .map_err(|_| ErrorCodeString::new("STATE_UNAVAILABLE"))?;
+    let session = session_guard
+        .as_ref()
+        .ok_or_else(|| ErrorCodeString::new("VAULT_LOCKED"))?;
+    if session.profile_id != id {
+        return Err(ErrorCodeString::new("VAULT_LOCKED"));
+    }
+
+    ensure_profile_dirs(&storage_paths, id)
+        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+
+    // Stop pools: rewriting vault.db and swapping attachments.
+    let _maintenance = MaintenanceGuard::new(id)?;
+    drain_and_drop_profile_pools(id, Duration::from_secs(5));
+    clear_pool(id);
+
+    let profile_root = profile_dir(&storage_paths, id)?;
+    let backup_root = profile_root.join("tmp").join("remove_password_backup");
+    if backup_root.exists() {
+        let _ = std::fs::remove_dir_all(&backup_root);
+    }
+    std::fs::create_dir_all(&backup_root)
+        .map_err(|_| ErrorCodeString::new("PROFILE_STORAGE_WRITE"))?;
+
+    let vault_path = vault_db_path(&storage_paths, id)?;
+    let vault_backup_path = backup_root.join("vault.db.bak");
+
+    let salt_path = kdf_salt_path(&storage_paths, id)?;
+    let salt_backup_path = backup_root.join("kdf_salt.bin.bak");
+
+    let key_path = key_check_path(&storage_paths, id)?;
+    let key_backup_path = backup_root.join("key_check.bin.bak");
+
+    let attachments_dir = profile_root.join("attachments");
+    let attachments_backup_dir = backup_root.join("attachments_encrypted");
+
+    let mut rb = RemovePasswordRollback {
+        vault_path: vault_path.clone(),
+        vault_backup_path: vault_backup_path.clone(),
+        salt_path: salt_path.clone(),
+        salt_backup_path: salt_backup_path.clone(),
+        salt_moved: false,
+        key_check_path: key_path.clone(),
+        key_check_backup_path: key_backup_path.clone(),
+        key_check_moved: false,
+        attachments_dir: attachments_dir.clone(),
+        attachments_backup_dir: attachments_backup_dir.clone(),
+        attachments_swapped: false,
+    };
+
+    if !vault_path.exists() {
+        return Err(ErrorCodeString::new("VAULT_NOT_FOUND"));
+    }
+    if std::fs::rename(&vault_path, &vault_backup_path).is_err() {
+        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+    }
+
+    if salt_path.exists() {
+        if std::fs::rename(&salt_path, &salt_backup_path).is_err() {
+            let _ = std::fs::rename(&vault_backup_path, &vault_path);
+            return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+        }
+        rb.salt_moved = true;
+    }
+
+    if key_path.exists() {
+        if std::fs::rename(&key_path, &key_backup_path).is_err() {
+            let _ = std::fs::rename(&vault_backup_path, &vault_path);
+            if rb.salt_moved {
+                let _ = std::fs::rename(&salt_backup_path, &salt_path);
+            }
+            return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+        }
+        rb.key_check_moved = true;
+    }
+
+    let db_bytes = session
+        .conn
+        .serialize(DatabaseName::Main)
+        .map_err(|_| {
+            rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+            ErrorCodeString::new("DB_QUERY_FAILED")
+        })?;
+
+    let key = Zeroizing::new(*session.key);
+
+    if write_atomic(&vault_path, db_bytes.as_slice()).is_err() {
+        rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+    }
+
+    // Ensure WAL (persistent) like init_database_passwordless.
+    {
+        let conn = Connection::open(&vault_path).map_err(|_| {
+            rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+            ErrorCodeString::new("DB_OPEN_FAILED")
+        })?;
+
+        let current: String = conn
+            .query_row("PRAGMA journal_mode;", [], |row| row.get(0))
+            .map_err(|_| {
+                rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+                ErrorCodeString::new("DB_QUERY_FAILED")
+            })?;
+
+        if current.to_uppercase() != "WAL" {
+            let _: String = conn
+                .query_row("PRAGMA journal_mode=WAL;", [], |row| row.get(0))
+                .map_err(|_| {
+                    rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+                    ErrorCodeString::new("DB_QUERY_FAILED")
+                })?;
+        }
+    }
+
+    // Attachments migration to plaintext.
+    let staging_dir = backup_root.join("attachments_plain_staging");
+    if staging_dir.exists() {
+        let _ = std::fs::remove_dir_all(&staging_dir);
+    }
+    if std::fs::create_dir_all(&staging_dir).is_err() {
+        rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+    }
+
+    if let Ok(entries) = std::fs::read_dir(&attachments_dir) {
+        for entry in entries.flatten() {
+            let path = entry.path();
+            if !path.is_file() {
+                continue;
+            }
+
+            let file_name = match path.file_name().and_then(|n| n.to_str()) {
+                Some(n) => n,
+                None => continue,
+            };
+
+            if !file_name.ends_with(".bin") {
+                continue;
+            }
+
+            let attachment_id = file_name.trim_end_matches(".bin");
+            let blob = std::fs::read(&path).map_err(|_| {
+                rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+                ErrorCodeString::new("ATTACHMENT_READ")
+            })?;
+
+            let plaintext = if blob.starts_with(&cipher::PM_ENC_MAGIC) {
+                cipher::decrypt_attachment_blob(id, attachment_id, &*key, &blob).map_err(|e| {
+                    rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+                    e
+                })?
+            } else {
+                blob
+            };
+
+            let out_path = staging_dir.join(file_name);
+            if write_atomic(&out_path, &plaintext).is_err() {
+                rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+                return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+            }
+        }
+    }
+
+    if attachments_backup_dir.exists() {
+        let _ = std::fs::remove_dir_all(&attachments_backup_dir);
+    }
+    if std::fs::rename(&attachments_dir, &attachments_backup_dir).is_err() {
+        rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+    }
+    rb.attachments_swapped = true;
+
+    if std::fs::rename(&staging_dir, &attachments_dir).is_err() {
+        rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+        return Err(ErrorCodeString::new("PROFILE_STORAGE_WRITE"));
+    }
+
+    let updated = match registry::upsert_profile_with_id(&storage_paths, id, &profile.name, false) {
+        Ok(u) => u,
+        Err(err) => {
+            rollback_remove_profile_password(state, &storage_paths, id, &profile.name, &rb);
+            return Err(err);
+        }
+    };
+
+    *session_guard = None;
+    clear_pool(id);
+
+    let _ = std::fs::remove_dir_all(&backup_root);
+    Ok(updated.into())
+}
*** End Patch
```

---
