diff --git a/src-tauri/src/services/security_service.rs b/src-tauri/src/services/security_service.rs
index 5e85c2c..0b8d9ef 100644
--- a/src-tauri/src/services/security_service.rs
+++ b/src-tauri/src/services/security_service.rs
@@ -1,10 +1,11 @@
 use std::ptr::NonNull;
 use std::path::Path;
 use std::sync::atomic::Ordering;
 use std::sync::Arc;
 use std::time::Duration;

 use rusqlite::backup::Backup;
+use rusqlite::OpenFlags;
 use rusqlite::ffi;
 use rusqlite::serialize::OwnedData;
 use rusqlite::DatabaseName;
 use zeroize::{Zeroize, Zeroizing};

@@ -270,13 +271,12 @@ pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) -> Result<ProfileMeta> {
         fn map_db_error(err: &rusqlite::Error) -> ErrorCodeString {
             match err {
                 rusqlite::Error::SqliteFailure(e, _) => {
                     use rusqlite::ErrorCode::*;
                     match e.code {
-                        DatabaseBusy | DatabaseLocked | Busy | Locked => {
-                            ErrorCodeString::new("DB_BUSY")
-                        }
+                        DatabaseBusy | DatabaseLocked => ErrorCodeString::new("DB_BUSY"),
                         _ => ErrorCodeString::new("DB_QUERY_FAILED"),
                     }
                 }
                 _ => ErrorCodeString::new("DB_QUERY_FAILED"),
             }
         }

@@ -305,16 +305,24 @@ pub fn set_profile_password(id: &str, password: &str, state: &Arc<AppState>) -> Result<ProfileMeta> {
         // Snapshot the file DB into memory using SQLite online backup, then serialize the in-memory DB.
         let bytes: Vec<u8> = {
-            let src = rusqlite::Connection::open(&vault_path)
+            // Open read-only to avoid taking write locks / WAL side-effects during snapshot.
+            let src = rusqlite::Connection::open_with_flags(
+                &vault_path,
+                OpenFlags::SQLITE_OPEN_READ_ONLY,
+            )
                 .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
             src.busy_timeout(Duration::from_secs(15))
                 .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;
-            migrations::migrate_to_latest(&src)?;
+
+            // IMPORTANT:
+            // Do NOT run migrations on the file DB here.
+            // On Windows/WAL with concurrent connections this can hit SQLITE_BUSY/LOCKED and fail the whole flow.
+            // We run migrations on the in-memory snapshot below (mem_conn), which is lock-free.

             let mut mem = rusqlite::Connection::open_in_memory()
                 .map_err(|_| ErrorCodeString::new("DB_OPEN_FAILED"))?;

             {
-                let mut backup = Backup::new(&src, &mut mem).map_err(|e| {
+                let backup = Backup::new(&src, &mut mem).map_err(|e| {
                     log::error!("[SECURITY][set_profile_password] backup init failed: {e:?}");
                     map_db_error(&e)
                 })?;
                 backup
                     .run_to_completion(5, Duration::from_millis(250), None)
                     .map_err(|e| {
                         log::error!("[SECURITY][set_profile_password] backup run failed: {e:?}");
                         map_db_error(&e)
                     })?;
             }

             let serialized = mem.serialize(DatabaseName::Main).map_err(|e| {
                 log::error!("[SECURITY][set_profile_password] serialize(mem) failed: {e:?}");
                 map_db_error(&e)
             })?;
             serialized.to_vec()
         };
